{
  "Demo1_LearnAboutUser.py": {
    "AddInput": {
      "type": "FunctionDef",
      "name": "AddInput",
      "md_content": [
        "**AddInput**: The function of AddInput is to process the input provided by the user and perform various operations based on the input.\n\n**parameters**:\n- inp: The input string provided by the user.\n- PrintAnswer: A boolean flag indicating whether to print the answer.\n- Print: A boolean flag indicating whether to print the input sentence.\n- PrintInputSentenceOverride: A boolean flag indicating whether to override the default behavior of printing the input sentence.\n- PrintInputSentenceOverrideValue: A boolean value specifying the override value for printing the input sentence.\n\n**Code Description**:\nThe AddInput function takes in an input string provided by the user and performs several operations based on the input. \n\nFirst, it checks if the input string does not end with a question mark, does not start with an asterisk, and the UseLastQuestionInContext flag is set to True. If these conditions are met, it appends the last question asked to the input string.\n\nNext, it calls the NAR.AddInput function with the input string and several optional parameters. The PrintAnswer, Print, PrintInputSentenceOverride, and PrintInputSentenceOverrideValue parameters control the printing behavior during the execution of the NAR.AddInput function.\n\nIf the input string ends with a question mark, it prints the GPT_Answer from the return value of the NAR.AddInput function.\n\nThe function also handles various special cases based on the input string. If the input string starts with \"//\", it returns an empty dictionary. If the input string starts with \"*volume=\", it returns an empty dictionary. If the input string starts with \"*prompt\", it generates and prints a prompt based on the current time, memory, and relevant view size. If the input string starts with \"<\" or \"(\", or contains \" :|:\", it performs additional operations related to Narsese encoding. If the QuestionPriming flag is set to True and the input string ends with a question mark, it queries the NAR system with the input string. If the AutoGroundNarsese flag is set to True, it performs grounding on the input string. It then processes the input string using the ProcessInput function and updates the current time.\n\nIf the input string starts with \"*memory\", it prints the contents of the memory. If the input string starts with \"*ground=\", it extracts the Narsese string from the input string and performs grounding on it. If the input string starts with \"*time\", it prints the current time. If the input string starts with \"*reset\", it resets the memory, atoms, current time, and calls the NAR.AddInput function with \"*reset\". If the input string starts with \"*buffer\", it generates and prints a memory view based on the current time, memory, and relevant view size. If the input string starts with \"*concurrent\", it calls the NAR.AddInput function with the input string and decrements the current time. If the input string starts with \"*\", it calls the NAR.AddInput function with the input string.\n\nIf none of the special cases are met, the input string is converted to lowercase. If the input string ends with a question mark, it generates a prompt based on the current time, memory, relevant view size, and the input string. It then calls the PromptProcess function with the generated prompt and input string, and updates the current time. If the input string does not end with a question mark, it calls the ProcessInput function with the input string and updates the current time.\n\nFinally, it eternalizes the memory based on the current time and eternalization distance, and stores the memory and atoms in a file.\n\n**Note**:\n- The AddInput function performs various operations based on the input string provided by the user.\n- The function handles special cases such as printing the memory, performing grounding, resetting the system, and generating prompts.\n- The function calls the NAR.AddInput function to process the input string and obtain the result.\n- The function updates the current time and stores the memory and atoms in a file."
      ],
      "code_start_line": 7,
      "code_end_line": 12,
      "parent": null,
      "params": [
        "inp"
      ],
      "have_return": false,
      "code_content": "def AddInput(inp):\n    if not inp.endswith(\"?\") and not inp.startswith(\"*\") and UseLastQuestionInContext:\n        inp = lastquestion + \" \" + inp\n    ret = NAR.AddInput(inp, PrintAnswer=False, Print=False, PrintInputSentenceOverride=True, PrintInputSentenceOverrideValue=False)\n    if inp.endswith(\"?\"):\n        print(ret[\"GPT_Answer\"])\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "NarsGPT.py/AddInput"
      ]
    },
    "RaiseQuestion": {
      "type": "FunctionDef",
      "name": "RaiseQuestion",
      "md_content": [
        "**RaiseQuestion**: The function of RaiseQuestion is to prompt the user to raise a question about a specific topic that is not addressed by any existing memory item. It then processes the user's input and performs necessary modifications to the answer before printing it and storing it as the last question.\n\n**parameters**:\n- None\n\n**Code Description**:\nThe `RaiseQuestion` function begins by declaring the `lastquestion` variable as a global variable. This variable will store the last question asked by the user.\n\nNext, the function calls the `NAR.AddInput` function to prompt the user to raise a question. The prompt includes the topic specified by the `LearnMoreAbout` variable. The function sets the `PrintAnswer`, `Print`, `PrintInputSentenceOverride`, and `PrintInputSentenceOverrideValue` parameters to control the printing behavior during the prompt.\n\nThe function then retrieves the answer from the returned dictionary and performs some modifications. It splits the answer at the question mark symbol (`?`) and adds it back to the answer, ensuring that the question mark is preserved. This modification is done to ensure that the printed answer ends with a question mark.\n\nThe modified answer is then printed to the console.\n\nNext, the function calls the `NAR.I_You_Exchange` function to perform a pronoun exchange in the answer. This function replaces pronouns such as \"you\" and \"your\" with their corresponding pronouns \"I\" and \"my\" to change the perspective from the user to the AI assistant.\n\nFinally, the function updates the `lastquestion` variable with the modified answer.\n\n**Note**: It is important to note that the `RaiseQuestion` function relies on the `NAR.AddInput` and `NAR.I_You_Exchange` functions to prompt the user and perform the pronoun exchange, respectively. The `lastquestion` variable is used to store the last question asked by the user.\n\n"
      ],
      "code_start_line": 14,
      "code_end_line": 20,
      "parent": null,
      "params": [],
      "have_return": false,
      "code_content": "def RaiseQuestion():\n    global lastquestion\n    ret = NAR.AddInput(f\"Raise a question about {LearnMoreAbout}, not addressed by any existing memory item?\", PrintAnswer=False, Print=False, PrintInputSentenceOverride=True, PrintInputSentenceOverrideValue=False)\n    ret[\"GPT_Answer\"] = ret[\"GPT_Answer\"].split(\"?\")[0] + \"?\"\n    print(ret[\"GPT_Answer\"])\n    NAR.I_You_Exchange(ret)\n    lastquestion = ret[\"GPT_Answer\"]\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "NarsGPT.py/I_You_Exchange",
        "NarsGPT.py/AddInput"
      ]
    }
  },
  "Demo2_BringCommands.py": {
    "build_prompt": {
      "type": "FunctionDef",
      "name": "build_prompt",
      "md_content": [
        "**build_prompt**: The function of build_prompt is to generate a prompt string for the OpenAI ChatCompletion API. \n\n**parameters**:\n- task: A string representing the task for which the prompt is being built.\n\n**Code Description**:\nThe build_prompt function takes a task as input and generates a prompt string by replacing the \"__TASK__\" placeholder in the prompt template with the given task. The prompt template is stored in the variable \"prompt\". \n\nIf there are any recent question-answer tuples (RECENT_QA_TUPLES), the function appends a section to the prompt string that includes the history of question-answer pairs. It iterates over each tuple in RECENT_QA_TUPLES and appends the question, the string \"ANSWER:\", and the corresponding answer to the prompt string. Each question-answer pair is separated by a newline character.\n\nIf there are no recent question-answer tuples, the function appends a section to the prompt string indicating that the Q&A history is empty.\n\nFinally, the function returns the generated prompt string.\n\nThe build_prompt function is called by the query function in the Demo2_BringCommands.py/query object. The query function uses the prompt generated by build_prompt as input to the OpenAI ChatCompletion API. It sends a request to the API with the prompt and retrieves the response. The response is then processed to extract the desired content, which is returned by the query function.\n\n**Note**: \n- The build_prompt function assumes that the variable \"prompt\" is defined and accessible within the scope of the function.\n- The function relies on the global variable RECENT_QA_TUPLES to determine if there are any recent question-answer tuples.\n- The function does not handle any exceptions or errors that may occur during the execution.\n\n**Output Example**:\nIf the task is \"Translate the following sentence to French: 'Hello, how are you?'\", and there are two recent question-answer tuples:\n- Q: \"What is the capital of France?\" A: \"Paris\"\n- Q: \"Who is the current President of the United States?\" A: \"Joe Biden\"\n\nThe output of the build_prompt function would be:\n\"Translate the following sentence to French: 'Hello, how are you?' Q&A history:\nWhat is the capital of France? ANSWER: Paris\nWho is the current President of the United States? ANSWER: Joe Biden\""
      ],
      "code_start_line": 13,
      "code_end_line": 21,
      "parent": null,
      "params": [
        "task"
      ],
      "have_return": true,
      "code_content": "def build_prompt(task):\n    prompt_temp = prompt.replace(\"__TASK__\", task)\n    if RECENT_QA_TUPLES:\n        prompt_temp += \"\\Q&A history:\"\n        for qa in RECENT_QA_TUPLES:\n            prompt_temp += qa[0] + \" ANSWER: \" + qa[1] + \"\\n\"\n    else:\n        prompt_temp += \"\\Q&A history: EMPTY\"\n    return prompt_temp\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "Demo2_BringCommands.py/query"
      ],
      "reference_who": []
    },
    "query": {
      "type": "FunctionDef",
      "name": "query",
      "md_content": [
        "**query**: The function of query is to send a request to the OpenAI ChatCompletion API with a prompt and retrieve the response.\n\n**parameters**:\n- task: A string representing the task for which the response is being queried.\n\n**Code Description**:\nThe query function takes a task as input and generates a prompt string by calling the build_prompt function. It then sends a request to the OpenAI ChatCompletion API with the generated prompt and retrieves the response. The response is processed to extract the desired content, which is returned by the query function.\n\nInside the function, a try-except block is used to handle any exceptions that may occur during the API call. If an exception is caught, an error message is printed, and the function waits for 10 seconds before retrying the API call.\n\nThe response from the API is stored in the variable \"response\". The desired content is extracted from the response using the following steps:\n- The \"choices\" key of the response contains a list of choices.\n- The first choice in the list is selected using indexing: response['choices'][0].\n- The selected choice contains a nested dictionary with the message content: response['choices'][0]['message']['content'].\n- The content is assigned to the variable \"ret\" and returned by the function.\n\n**Note**: \n- The function assumes that the build_prompt function is defined and accessible within the scope of the query function.\n- The function relies on the OpenAI package being imported and the ChatCompletion API being available.\n- The function does not handle any exceptions or errors that may occur during the execution.\n\n**Output Example**:\nIf the task is \"Translate the following sentence to French: 'Hello, how are you?'\", and the response from the API is \"Bonjour, comment ça va ?\", the output of the query function would be:\n\"Bonjour, comment ça va ?\""
      ],
      "code_start_line": 23,
      "code_end_line": 32,
      "parent": null,
      "params": [
        "task"
      ],
      "have_return": true,
      "code_content": "def query(task):\n    prompt = build_prompt(task)\n    while True:\n        try:\n            response = openai.ChatCompletion.create(model='gpt-3.5-turbo', messages=[ {\"role\": \"user\", \"content\": prompt}], max_tokens=200, temperature=0)\n            ret = response['choices'][0]['message']['content']\n            return ret\n        except Exception as e:\n            print(\"Error: API call failed, will try repeating it in 10 seconds!\", str(e))\n            time.sleep(10) #wait 10 seconds\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "Demo2_BringCommands.py/AddInput"
      ],
      "reference_who": [
        "Demo2_BringCommands.py/build_prompt"
      ]
    },
    "parseOutput": {
      "type": "FunctionDef",
      "name": "parseOutput",
      "md_content": [
        "**parseOutput**: The function of parseOutput is to process the output generated by a language model (LM) and perform specific actions based on the content of the output.\n\n**parameters**:\n- LM_output: A string representing the output generated by the language model.\n\n**Code Description**:\nThe `parseOutput` function takes in the `LM_output` as a parameter and performs the following actions:\n\n1. It first checks if the LM_output does not contain the character \"(\" using the `not in` operator. If this condition is true, it further checks if the LM_output does not end with the character \"?\". If both conditions are true, it prints an error message indicating that the question is not valid and exits the program with a status code of 0. Otherwise, it calls the `NAR.AddInput` function with specific arguments and returns the result.\n\n2. If the LM_output does contain the character \"(\", it returns None.\n\n**Note**: The `NAR.AddInput` function is called with various arguments depending on the conditions in the code. The specific arguments used in each case are not provided in the code snippet.\n\n**Output Example**: \n- If the LM_output does not contain \"(\", and does not end with \"?\", the function will print an error message and exit the program.\n- If the LM_output does not contain \"(\", but ends with \"?\", the function will call the `NAR.AddInput` function with specific arguments and return the result.\n- If the LM_output contains \"(\", the function will return None."
      ],
      "code_start_line": 34,
      "code_end_line": 40,
      "parent": null,
      "params": [
        "LM_output"
      ],
      "have_return": true,
      "code_content": "def parseOutput(LM_output):\n    if \"(\" not in LM_output:\n        if not LM_output.endswith(\"?\"):\n            print(\"ERROR: NOT VALID QUESTION: \", LM_output)\n            exit(0)\n        return NAR.AddInput(LM_output, PrintAnswer=False, Print=False, PrintInputSentenceOverride=True, PrintInputSentenceOverrideValue=False)\n    return None\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "Demo2_BringCommands.py/AddInput"
      ],
      "reference_who": [
        "NarsGPT.py/AddInput"
      ]
    },
    "AddInput": {
      "type": "FunctionDef",
      "name": "AddInput",
      "md_content": [
        "**AddInput**: The function of AddInput is to process a given task and perform specific actions based on the content of the task.\n\n**parameters**:\n- task: A string representing the task to be processed.\n\n**Code Description**:\nThe `AddInput` function takes in a task as input and performs the following actions:\n\n1. It initializes the global variable `RECENT_QA_TUPLES` as an empty list.\n\n2. It checks if the task ends with \"!\". If this condition is true, it enters a while loop.\n\n3. Inside the while loop, it calls the `query` function with the task as input and assigns the returned value to the variable `LM_output`.\n\n4. It calls the `parseOutput` function with `LM_output` as input and assigns the returned value to the variable `ret`.\n\n5. If `ret` is None, it performs the following actions:\n   - It converts `LM_output` to a Narsese goal by extracting specific arguments from it.\n   - It checks if the extracted arguments are properly grounded.\n   - If the arguments are properly grounded, it constructs a Narsese goal string and prints it.\n   - It calls the `NAR.AddInput` function with the constructed goal as input and returns the result.\n\n6. If `ret` is not None, it retrieves the NARS output from `ret` and stores it in the variable `NARS_output`.\n\n7. It prints the `LM_output` and `NARS_output` values.\n\n8. It appends a tuple containing the `LM_output` and `NARS_output` values to the `RECENT_QA_TUPLES` list.\n\n9. The while loop continues until the task no longer ends with \"!\".\n\n10. If the task does not end with \"!\", it calls the `NAR.AddInput` function with the task as input and returns the result.\n\n**Note**: \n- The function assumes that the `query` and `parseOutput` functions are defined and accessible within the scope of the `AddInput` function.\n- The function relies on the global variable `RECENT_QA_TUPLES` being defined and accessible.\n- The function does not handle any exceptions or errors that may occur during the execution.\n\n**Output Example**:\nIf the task is \"Translate the following sentence to French: 'Hello, how are you?'\", and the response from the API is \"Bonjour, comment ça va ?\", the output of the `AddInput` function would be:\n\"Bonjour, comment ça va ?\""
      ],
      "code_start_line": 42,
      "code_end_line": 66,
      "parent": null,
      "params": [
        "task"
      ],
      "have_return": true,
      "code_content": "def AddInput(task):\n    global RECENT_QA_TUPLES\n    RECENT_QA_TUPLES = []\n    if task.endswith(\"!\"):\n        while True:\n            LM_output = query(task).strip()\n            ret = parseOutput(LM_output)\n            if ret is None:\n                #translate LM_output into a Narsese goal, and enter it, returning ONA output\n                LM_output = LM_output.lower()\n                if LM_output.startswith(\"bring(\"):\n                    args = [x.strip() for x in LM_output.split(\"bring(\")[1].split(\")\")[0].split(\",\")]\n                    for x in args:\n                        if \" \" in x or \"=\" in x:\n                            print(\"//GOAL not properly grounded\")\n                            return None\n                    goal = f\"<({args[0]} * ({args[1]} * {args[2]})) --> bring>! :|:\"\n                    print(\"//GOAL:\", goal)\n                    return NAR.AddInput(goal, Print=False)\n                return None\n            NARS_output = ret[\"GPT_Answer\"]\n            print(LM_output, NARS_output, \"\\n\")\n            RECENT_QA_TUPLES.append((LM_output, NARS_output))\n    else:\n        return NAR.AddInput(task, Print=False)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "Demo2_BringCommands.py/Shell"
      ],
      "reference_who": [
        "Demo2_BringCommands.py/query",
        "Demo2_BringCommands.py/parseOutput",
        "NarsGPT.py/AddInput"
      ]
    },
    "Shell": {
      "type": "FunctionDef",
      "name": "Shell",
      "md_content": [
        "**Shell**: The function of Shell is to continuously accept user input and pass it to the AddInput function for further processing.\n\n**parameters**:\n- None\n\n**Code Description**:\nThe `Shell` function is a loop that continuously accepts user input and passes it to the `AddInput` function. It does not take any parameters.\n\n1. Inside the loop, it uses the `input()` function to prompt the user for input and assigns the input to the variable `task`.\n\n2. It then calls the `AddInput` function with the `task` as the argument.\n\n3. The `AddInput` function processes the task and performs specific actions based on its content.\n\n4. After the `AddInput` function returns, the loop continues to the next iteration and prompts the user for input again.\n\n5. The loop continues indefinitely until the program is terminated.\n\n**Note**: \n- The `AddInput` function is assumed to be defined and accessible within the scope of the `Shell` function.\n- The `Shell` function does not handle any exceptions or errors that may occur during the execution.\n\nNow, let's take a look at the `AddInput` function to understand the specific actions performed on the task input."
      ],
      "code_start_line": 68,
      "code_end_line": 71,
      "parent": null,
      "params": [],
      "have_return": false,
      "code_content": "def Shell():\n    while True:\n        task = input()\n        AddInput(task)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "Demo2_BringCommands.py/AddInput"
      ]
    }
  },
  "Memory.py": {
    "SetPrint": {
      "type": "FunctionDef",
      "name": "SetPrint",
      "md_content": [
        "**SetPrint**: The function of SetPrint is to set the value of the global variable \"Print\" based on the input flag.\n\n**parameters**:\n- Flag: A boolean value that determines the value of the global variable \"Print\". If Flag is True, the value of Print will be set to True. If Flag is False, the value of Print will be set to False.\n\n**Code Description**:\nThe SetPrint function is a simple function that sets the value of the global variable \"Print\" based on the input flag. The global keyword is used to indicate that the variable \"Print\" is a global variable and can be accessed and modified from anywhere in the code.\n\nThe function takes one parameter, Flag, which is a boolean value. If Flag is True, the value of Print is set to True. If Flag is False, the value of Print is set to False.\n\nBy setting the value of Print, this function controls whether certain print statements in the code will be executed or not. If Print is True, the print statements will be executed. If Print is False, the print statements will be skipped.\n\nThis function is typically called before executing other parts of the code that contain print statements. By setting the value of Print to True or False, developers can control the verbosity of the code and choose whether to display certain output or not.\n\n**Note**: \n- It is important to call this function before executing any code that contains print statements, as it determines whether the print statements will be executed or skipped.\n- The global variable \"Print\" is shared across the entire codebase, so changing its value in one part of the code will affect its value in other parts of the code as well."
      ],
      "code_start_line": 45,
      "code_end_line": 47,
      "parent": null,
      "params": [
        "Flag"
      ],
      "have_return": false,
      "code_content": "def SetPrint(Flag):\n    global Print\n    Print = Flag\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "NarsGPT.py/AddInput"
      ],
      "reference_who": []
    },
    "GetPrint": {
      "type": "FunctionDef",
      "name": "GetPrint",
      "md_content": [
        "**GetPrint**: The function of GetPrint is to return the Print object.\n\n**parameters**:\n- This function does not take any parameters.\n\n**Code Description**:\nThe GetPrint function is a simple function that returns the Print object. It does not perform any operations or calculations, but simply returns the Print object as it is.\n\n**Note**:\nThere are no specific points to note about the use of this code, as it is a straightforward function that returns an object.\n\n**Output Example**:\nThe return value of the GetPrint function would be the Print object."
      ],
      "code_start_line": 48,
      "code_end_line": 49,
      "parent": null,
      "params": [],
      "have_return": true,
      "code_content": "def GetPrint():\n    return Print\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "ReplaceEncode": {
      "type": "FunctionDef",
      "name": "ReplaceEncode",
      "md_content": [
        "**ReplaceEncode**: The function of ReplaceEncode is to remove the suffix \"encode\" from a word if it ends with \"encode\" and has a length greater than 6 characters.\n\n**parameters**:\n- word: A string representing the word to be processed.\n\n**Code Description**:\nThe ReplaceEncode function takes a word as input and checks if it ends with the suffix \"encode\" and has a length greater than 6 characters. If both conditions are met, it removes the last 6 characters from the word. The modified word is then returned as the output.\n\nThis function is used in the project within the \"Lemmatize\" and \"notIncluded\" objects. In the \"Lemmatize\" object, the ReplaceEncode function is called to preprocess the word before performing lemmatization. The word is converted to lowercase and any spaces or hyphens are replaced with underscores. If the word contains underscores and the part of speech tag is a noun, the last part of the word is lemmatized separately and then joined with the remaining parts. If the part of speech tag is a verb, certain verb forms are checked and replaced with the standard form \"isa\". Finally, the resulting word is returned.\n\nIn the \"notIncluded\" object, the ReplaceEncode function is called to preprocess the word before checking if it is included in a given input string. The underscores in the word are replaced with spaces, and the modified word is then compared with the input string. If the modified word is not found in the input string, the function returns True, indicating that the word is not included.\n\n**Note**: \n- The ReplaceEncode function is specifically designed to handle words that end with \"encode\" and have a length greater than 6 characters. It may not produce the desired result for words that do not meet these criteria.\n- The ReplaceEncode function does not modify the original word if it does not meet the specified conditions.\n\n**Output Example**:\n- Input: \"exampleencode\"\n- Output: \"example\""
      ],
      "code_start_line": 51,
      "code_end_line": 54,
      "parent": null,
      "params": [
        "word"
      ],
      "have_return": true,
      "code_content": "def ReplaceEncode(word):\n    if word.endswith(\"encode\") and len(word) > 6: #no idea why GPT adds Encode at the end for new words\n            word = word[:-6]\n    return word\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "Memory.py/Lemmatize",
        "Memory.py/notIncluded"
      ],
      "reference_who": []
    },
    "MergeInto": {
      "type": "FunctionDef",
      "name": "MergeInto",
      "md_content": [
        "**MergeInto**: The function of MergeInto is to merge the contents of the 'ret' dictionary into the 'RET_DICT' dictionary.\n\n**parameters**:\n- RET_DICT: A dictionary that stores the merged contents.\n- ret: A dictionary containing the contents to be merged into RET_DICT.\n\n**Code Description**:\nThe MergeInto function takes two dictionaries as input parameters: RET_DICT and ret. It iterates over the keys in the 'ret' dictionary and performs the following operations for each key:\n- If the key is present in both RET_DICT and ret, and the key is not equal to \"reason\", the values corresponding to the key in both dictionaries are added together and stored in RET_DICT.\n- If the key is not present in RET_DICT, the value corresponding to the key in ret is added to RET_DICT.\n\nThis function is used to merge the contents of the 'ret' dictionary into the 'RET_DICT' dictionary. It is called by two objects in the project: Memory.py/Allow_requery_if_not_in_ONA and Memory.py/ProcessInput.\n\nIn the Memory.py/Allow_requery_if_not_in_ONA object, the MergeInto function is called after checking if a previously queried item is not in ONA memory anymore. If the item is still present in memory, the NAR.AddInput function is called with a modified term. The resulting dictionary 'ret' is then merged into the 'RET_DICT' dictionary using the MergeInto function. If the 'ret' dictionary contains an \"answers\" key with a non-empty value, the first answer is checked for the absence of \"truth\" and a term value of \"None\". If these conditions are met, the item is removed from the 'retrieved' list.\n\nIn the Memory.py/ProcessInput object, the MergeInto function is called after adding an input to the NAR system using the NAR.AddInput function. The resulting dictionary 'ret' is then merged into the 'RET_DICT' dictionary using the MergeInto function. The function also performs additional operations on the 'ret' dictionary, such as extracting information about executed actions and tested causal hypotheses. It iterates over the 'ret' dictionary and checks for specific conditions to continue or skip certain operations. Finally, the function returns the merged dictionary 'ret' and the updated 'currentTime' value.\n\n**Note**: \n- The MergeInto function is designed to merge the contents of one dictionary into another dictionary.\n- The function assumes that the 'ret' dictionary contains keys that are compatible with the 'RET_DICT' dictionary.\n- The function does not handle cases where the values of the same key in both dictionaries are of different types.\n- The function does not handle cases where the values of the same key in both dictionaries are not compatible for addition.\n- The function does not handle cases where the 'ret' dictionary contains keys that should not be merged into the 'RET_DICT' dictionary.\n\n**Output Example**:\nIf the 'RET_DICT' dictionary initially contains {'key1': 10, 'key2': 20} and the 'ret' dictionary contains {'key2': 30, 'key3': 40}, the merged 'RET_DICT' dictionary will be {'key1': 10, 'key2': 50, 'key3': 40}."
      ],
      "code_start_line": 56,
      "code_end_line": 61,
      "parent": null,
      "params": [
        "RET_DICT",
        "ret"
      ],
      "have_return": true,
      "code_content": "def MergeInto(RET_DICT, ret):\n    for key in ret:\n        if key in RET_DICT and key != \"reason\": #list (only last reason is returned, consistent with NAR.py)\n            RET_DICT[key] = RET_DICT[key] + ret[key]\n        else:\n            RET_DICT[key] = ret[key]\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "Memory.py/Allow_requery_if_not_in_ONA",
        "Memory.py/ProcessInput"
      ],
      "reference_who": []
    },
    "get_embedding_robust": {
      "type": "FunctionDef",
      "name": "get_embedding_robust",
      "md_content": [
        "**get_embedding_robust**: The function of get_embedding_robust is to retrieve the embedding for a given input. It handles exceptions that may occur during the retrieval process and retries the API call after a delay.\n\n**parameters**:\n- inp: The input for which the embedding needs to be retrieved.\n\n**Code Description**:\nThe `get_embedding_robust` function is a robust implementation of the `get_embedding` function. It ensures that the embedding is retrieved successfully by handling any exceptions that may occur during the API call. The function uses a while loop to continuously attempt to retrieve the embedding until it succeeds.\n\nWithin the while loop, the function tries to call the `get_embedding` function with the given input. If an exception occurs, it prints a message indicating the failure and waits for 10 seconds before retrying the API call. This delay allows for potential issues with the API to be resolved before attempting the call again. Once the API call is successful, the function breaks out of the while loop and returns the retrieved embedding.\n\n**Note**: \n- It is important to ensure that the `get_embedding` function is implemented and available for this function to work correctly.\n- The function assumes that the `time` module is imported and available for use.\n\n**Output Example**:\nIf the API call is successful, the function returns the retrieved embedding."
      ],
      "code_start_line": 63,
      "code_end_line": 72,
      "parent": null,
      "params": [
        "inp"
      ],
      "have_return": true,
      "code_content": "def get_embedding_robust(inp):\n    while True:\n        try:\n            ret = get_embedding(inp)\n        except:\n            print(\"//Failed get embedding, will retry API call in 10s\")\n            time.sleep(10)\n            continue\n        break\n    return ret\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "Memory.py/Term_Embedded",
        "Memory.py/RetrieveQuestionRelatedBeliefs",
        "Memory.py/Atomize",
        "NarsGPT.py/ground",
        "NarsGPT.py/AddInput"
      ],
      "reference_who": []
    },
    "ProductPrettify": {
      "type": "FunctionDef",
      "name": "ProductPrettify",
      "md_content": [
        "**ProductPrettify**: The function of ProductPrettify is to prettify a given term by modifying its format and removing unnecessary characters.\n\n**parameters**:\n- term: A string representing the term to be prettified.\n\n**Code Description**:\nThe ProductPrettify function takes a term as input and prettifies it by performing the following steps:\n\n1. It checks if the term contains the string \" --> \" and the string \" * \" in the part before \" --> \". If both conditions are met, it splits the term into three parts: arg1, arg2, and relarg. The arg1 is obtained by splitting the term using \" * \" and taking the first part, which is then stripped of leading and trailing spaces. The arg2 is obtained by splitting the term using \" * \" and \" --> \" and taking the first part of the resulting split, which is then stripped of leading and trailing spaces. The relarg is obtained by splitting the term using \" --> \" and taking the second part, which is then stripped of leading and trailing spaces. Finally, the term is updated by concatenating arg1, relarg, and arg2 with spaces in between.\n\n2. The function then replaces any occurrence of \"(\" and \")\" in the term with an empty string.\n\n3. The function returns the modified term.\n\nThis function is used to prettify terms in the context of the project. It is called by the Term_AsSentence function, which processes terms and converts them into sentences. The Term_AsSentence function first checks if the term does not contain the string \"=/>\". If this condition is true, it calls the ProductPrettify function to prettify the term. Otherwise, it performs additional operations on the term before returning the final result.\n\n**Note**: \n- The ProductPrettify function assumes that the input term follows a specific format with \" --> \" and \" * \" as separators.\n- The function removes parentheses from the term, which may affect the meaning of the term if parentheses are used for grouping.\n- The function does not handle any other formatting or modification of the term.\n\n**Output Example**:\n- Input: \"arg1 * arg2 --> relarg\"\n- Output: \"arg1 relarg arg2\""
      ],
      "code_start_line": 74,
      "code_end_line": 80,
      "parent": null,
      "params": [
        "term"
      ],
      "have_return": true,
      "code_content": "def ProductPrettify(term):\n    if \" --> \" in term and \" * \" in term.split(\" --> \")[0]:\n        arg1 = term.split(\" * \")[0].strip()\n        arg2 = term.split(\" * \")[1].split(\" --> \")[0].strip()\n        relarg = term.split(\" --> \")[1].strip()\n        term = arg1 + \" \" + relarg + \" \" + arg2\n    return term.replace(\"(\",\"\").replace(\")\",\"\")\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "Memory.py/Term_AsSentence"
      ],
      "reference_who": []
    },
    "Term_AsSentence": {
      "type": "FunctionDef",
      "name": "Term_AsSentence",
      "md_content": [
        "**Term_AsSentence**: The function of Term_AsSentence is to convert a given term into a sentence by applying specific formatting rules and transformations.\n\n**parameters**:\n- T: A string representing the term to be converted into a sentence.\n\n**Code Description**:\nThe Term_AsSentence function takes a term as input and processes it to generate a sentence by following the steps outlined below:\n\n1. The function checks if the term contains the \"<\" character. If it does, it extracts the substring of the term starting from the second character and ending at the second-to-last character. Otherwise, it assigns the entire term to the variable \"term\".\n\n2. The function checks if the term does not contain the string \"=/>\". If this condition is true, it calls the ProductPrettify function to prettify the term. The ProductPrettify function modifies the format of the term by removing unnecessary characters and adjusting the order of its components.\n\n3. If the term contains the string \" =/> \", the function performs additional operations on the term. It splits the term into two parts using the \" =/> \" delimiter. The first part represents the preceding conditions, which are further split using the \" &/ \" delimiter. Each condition is then prettified using the ProductPrettify function. The resulting prettified conditions are concatenated using the \" and when then \" string. The second part represents the consequent, which is prettified using the ProductPrettify function. The final sentence is constructed by combining the prettified conditions, the prettified consequent, and the appropriate connecting words.\n\n4. The function replaces specific strings in the term to adjust the sentence structure. It replaces \" --> [\" with \" hasproperty \", \"]\" with an empty string, \"[\" with an empty string, \" --> \" with \" isa \", \" &/ \" with \" then \", and \" =/> \" with \" causes \". Additionally, it replaces \" + \" with a space.\n\n5. The modified term is returned as the output of the function.\n\nThis function is used in the context of the project to convert terms into sentences. It is called by other functions, such as Term_Embedded, Memory_generate_prompt, and ground, to process terms and generate meaningful representations.\n\n**Note**: \n- The Term_AsSentence function assumes that the input term follows specific formatting rules and contains certain delimiters.\n- The function relies on the ProductPrettify function to modify the format of the term.\n- The function performs specific string replacements to adjust the sentence structure.\n- The function does not handle any other formatting or modification of the term.\n\n**Output Example**:\n- Input: \"arg1 * arg2 --> relarg\"\n- Output: \"When 'arg1' then 'relarg' causes 'arg2'\""
      ],
      "code_start_line": 82,
      "code_end_line": 97,
      "parent": null,
      "params": [
        "T"
      ],
      "have_return": true,
      "code_content": "def Term_AsSentence(T):\n    term = T[1:-1] if \"<\" in T else T\n    if \"=/>\" not in term:\n        term = ProductPrettify(term)\n    else:\n        if \" =/> \" in term:\n            prec_op = [ProductPrettify(p) for p in term.split(\" =/> \")[0].split(\" &/ \")]\n            removeParentheses = lambda u: u.replace(\" --> [\",\" hasproperty \").replace(\" --> \",\" isa \").replace(\" - \", \" and not \").replace(\"(\",\"\"). \\\n                                            replace(\"<\",\"\").replace(\")\",\"\").replace(\">\",\"\").replace(\"  \",\" \").strip()\n            precs = removeParentheses(\" and when then \".join(prec_op[:-1]))\n            op = prec_op[-1]\n            if \" --> \" in op:\n                op = removeParentheses(prec_op[-1].split(\" --> \")[1] + \" \" + prec_op[-1].split(\" --> \")[0]).replace(\"{SELF} *\", \"\")\n            term = \"When '\" + precs + \"' then '\" + removeParentheses(op) + \"' causes '\" + removeParentheses(term.split(\" =/> \")[1]) + \"'\"\n    term = term.replace(\" --> [\", \" hasproperty \").replace(\"]\",\"\").replace(\"[\",\"\").replace(\" --> \", \" isa \").replace(\" &/ \", \" then \").replace(\" =/> \", \" causes \")\n    return term.replace(\" + \", \" \")\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "Memory.py/Term_Embedded",
        "Memory.py/Memory_generate_prompt",
        "NarsGPT.py/ground"
      ],
      "reference_who": [
        "Memory.py/ProductPrettify"
      ]
    },
    "Term_Embedded": {
      "type": "FunctionDef",
      "name": "Term_Embedded",
      "md_content": [
        "**Term_Embedded**: The function of Term_Embedded is to retrieve the embedding for a given input term by applying specific formatting rules and transformations.\n\n**parameters**:\n- T: A string representing the term for which the embedding needs to be retrieved.\n\n**Code Description**:\nThe `Term_Embedded` function takes a term as input and processes it to retrieve the embedding by following the steps outlined below:\n\n1. The function calls the `Term_AsSentence` function to convert the input term into a sentence by applying specific formatting rules and transformations.\n\n2. The resulting sentence is then processed further to replace certain characters and adjust the sentence structure. The function replaces \"-\" with a space and \"_\" with a space in the sentence.\n\n3. The modified sentence is passed as input to the `get_embedding_robust` function, which retrieves the embedding for the sentence. The `get_embedding_robust` function is a robust implementation of the `get_embedding` function, which ensures that the embedding is retrieved successfully by handling any exceptions that may occur during the API call.\n\n4. The retrieved embedding is returned as the output of the `Term_Embedded` function.\n\nThis function is used in the context of the project to retrieve embeddings for terms. It is called by other functions, such as ProcessInput, to process terms and generate meaningful representations.\n\n**Note**: \n- The `Term_Embedded` function assumes that the input term follows specific formatting rules and contains certain characters.\n- The function relies on the `Term_AsSentence` function to convert the term into a sentence.\n- The function uses the `get_embedding_robust` function to retrieve the embedding for the sentence.\n- It is important to ensure that the `get_embedding` function is implemented and available for this function to work correctly.\n\n**Output Example**:\n- Input: \"term_example\"\n- Output: [0.1, 0.2, 0.3, ...] (embedding vector)"
      ],
      "code_start_line": 99,
      "code_end_line": 100,
      "parent": null,
      "params": [
        "T"
      ],
      "have_return": true,
      "code_content": "def Term_Embedded(T):\n    return get_embedding_robust(Term_AsSentence(T).replace(\"-\",\" \").replace(\"_\",\" \"))\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "Memory.py/ProcessInput"
      ],
      "reference_who": [
        "Memory.py/get_embedding_robust",
        "Memory.py/Term_AsSentence"
      ]
    },
    "RetrieveQuestionRelatedBeliefs": {
      "type": "FunctionDef",
      "name": "RetrieveQuestionRelatedBeliefs",
      "md_content": [
        "**RetrieveQuestionRelatedBeliefs**: The function of RetrieveQuestionRelatedBeliefs is to retrieve a list of beliefs related to a given question from the memory. It uses a matching algorithm to find the beliefs that are most relevant to the question and returns them in descending order of match quality and truth expectation.\n\n**parameters**:\n- memory: A dictionary representing the memory, where each key is a belief ID and each value is a tuple containing belief information.\n- view: A list of beliefs that are currently in the view.\n- inp: The input question for which related beliefs need to be retrieved.\n- max_LTM_retrievals (optional): An integer representing the maximum number of beliefs to retrieve from long-term memory. Default value is 30.\n\n**Code Description**:\nThe `RetrieveQuestionRelatedBeliefs` function starts by initializing an empty dictionary called `primed`, which will store the beliefs related to the question. It then retrieves the embedding for the input question using the `get_embedding_robust` function. \n\nNext, the function iterates over each belief in the memory. If the belief is not already in the view, it calculates the match quality between the question embedding and the belief embedding using the `cosine_similarity` function. The belief and its match quality are added to the `primed` dictionary.\n\nAfter iterating over all beliefs in the memory, the `primed` dictionary is converted to a list of tuples using the `items` method. The list is then sorted based on two criteria: first by match quality in descending order, and then by truth expectation value using the `Truth_Expectation` function in descending order. The `primed` list is then truncated to contain a maximum of `max_LTM_retrievals` beliefs.\n\nFinally, the `primed` list is reversed and converted to a list of tuples containing belief IDs and belief information. This reversed list is returned as the output of the function.\n\n**Note**: \n- The `get_embedding_robust` function is called to retrieve the embedding for the input question. It is important to ensure that the `get_embedding` function is implemented and available for this function to work correctly.\n- The `Truth_Expectation` function is used to calculate the truth expectation value for each belief. It expects a tuple with two elements as input, otherwise it may result in an error.\n- The `cosine_similarity` function is used to calculate the match quality between the question embedding and the belief embedding. It is important to ensure that the `cosine_similarity` function is implemented and available for this function to work correctly.\n\n**Output Example**: \nIf the input question is \"What is the capital of France?\", the function may return a list of beliefs related to the question, such as:\n[(belief_id_1, belief_info_1), (belief_id_2, belief_info_2), ...]"
      ],
      "code_start_line": 102,
      "code_end_line": 115,
      "parent": null,
      "params": [
        "memory",
        "view",
        "inp",
        "max_LTM_retrievals"
      ],
      "have_return": true,
      "code_content": "def RetrieveQuestionRelatedBeliefs(memory, view, inp, max_LTM_retrievals=30):\n    primed = {}\n    qu_embed = get_embedding_robust(inp)\n    for m in list(memory.items()):\n        if m not in view:\n            matchQuality = cosine_similarity(qu_embed, m[1][4])\n            primed[m[0]] = (matchQuality, m[1])\n    primed = list(primed.items())\n    primed.sort(key=lambda x: (-x[1][0], -Truth_Expectation(x[1][1][2]))) #sort by query match first then by truth expectation\n    primed = primed[:max_LTM_retrievals]\n    #for m in primed:\n    #    print(\"//Retrieved from LTM:\", m[0], m[1][:-1])\n    primed = [(x[0],x[1][1]) for x in primed]\n    return list(reversed(primed))\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "Memory.py/Memory_view"
      ],
      "reference_who": [
        "Memory.py/get_embedding_robust",
        "Truth.py/Truth_Expectation"
      ]
    },
    "Memory_view": {
      "type": "FunctionDef",
      "name": "Memory_view",
      "md_content": [
        "**Memory_view**: The function of Memory_view is to generate a view of beliefs from the memory based on the specified parameters. It retrieves beliefs from the memory and sorts them based on their relevance to a given question and their recency. The function also has an optional input question parameter that can be used to further filter the beliefs based on their relevance to the question.\n\n**parameters**:\n- memory: A dictionary representing the memory, where each key is a belief ID and each value is a tuple containing belief information.\n- relevantViewSize: An integer representing the maximum number of beliefs to include in the view based on their relevance to the question.\n- recentViewSize: An integer representing the maximum number of beliefs to include in the view based on their recency.\n- inpQuestion (optional): A string representing the input question for which related beliefs need to be retrieved. Default value is None.\n\n**Code Description**:\nThe `Memory_view` function starts by initializing an empty list called `view` to store the beliefs in the view. It then creates a list called `recent_item_list` by converting the memory dictionary into a list of key-value pairs.\n\nNext, the function sorts the `recent_item_list` based on the first element of each value in descending order. This element represents the recency of the belief. The function then appends a slice of the sorted `recent_item_list` to the `view` list, starting from the first element and ending at the index specified by `recentViewSize`. This ensures that the most recent beliefs are included in the view.\n\nIf the `inpQuestion` parameter is not None, the function calls the `RetrieveQuestionRelatedBeliefs` function to retrieve beliefs related to the input question. The `RetrieveQuestionRelatedBeliefs` function takes the memory, the current view, the input question, and the `relevantViewSize` as parameters. The retrieved beliefs are then concatenated with the `view` list.\n\nFinally, the function returns the `view` list, which contains the beliefs in the view.\n\n**Note**: \n- The `RetrieveQuestionRelatedBeliefs` function is called to retrieve beliefs related to the input question. It is important to ensure that the `RetrieveQuestionRelatedBeliefs` function is implemented and available for this function to work correctly.\n\n**Output Example**: \nIf the input question is \"What is the capital of France?\", the function may return a list of beliefs related to the question, such as:\n[(belief_id_1, belief_info_1), (belief_id_2, belief_info_2), ...]"
      ],
      "code_start_line": 117,
      "code_end_line": 125,
      "parent": null,
      "params": [
        "memory",
        "relevantViewSize",
        "recentViewSize",
        "inpQuestion"
      ],
      "have_return": true,
      "code_content": "def Memory_view(memory, relevantViewSize, recentViewSize, inpQuestion = None):\n    view=[]\n    recent_item_list = list(memory.items())\n    #find recentViewSize items:\n    recent_item_list.sort(key=lambda x: -x[1][0])\n    view += reversed(recent_item_list[0:recentViewSize]) #newer comes later in prompt\n    if inpQuestion is not None:\n        view = RetrieveQuestionRelatedBeliefs(memory, view, inpQuestion, relevantViewSize) + view\n    return view\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "Memory.py/Memory_generate_prompt"
      ],
      "reference_who": [
        "Memory.py/RetrieveQuestionRelatedBeliefs"
      ]
    },
    "Memory_generate_prompt": {
      "type": "FunctionDef",
      "name": "Memory_generate_prompt",
      "md_content": [
        "**Memory_generate_prompt**: The function of Memory_generate_prompt is to generate a prompt memory string based on the current time, memory, prompt start and end, relevant view size, recent view size, and an optional input question. It retrieves beliefs from the memory, processes them, and constructs a prompt memory string that includes information about each belief, such as its term, time, and confidence level.\n\n**parameters**:\n- currentTime: A float representing the current time.\n- memory: A dictionary representing the memory, where each key is a belief ID and each value is a tuple containing belief information.\n- prompt_start: A string representing the starting part of the prompt memory string.\n- prompt_end: A string representing the ending part of the prompt memory string.\n- relevantViewSize: An integer representing the maximum number of beliefs to include in the view based on their relevance to the question.\n- recentViewSize: An integer representing the maximum number of beliefs to include in the view based on their recency.\n- inpQuestion (optional): A string representing the input question for which related beliefs need to be retrieved. Default value is None.\n\n**Code Description**:\nThe Memory_generate_prompt function starts by initializing an empty string called \"prompt_memory\" to store the prompt memory string. It then calls the Memory_view function to retrieve beliefs from the memory based on the specified parameters, such as relevantViewSize, recentViewSize, and inpQuestion. The retrieved beliefs are stored in the \"buf\" variable.\n\nNext, the function checks if the \"buf\" variable is empty. If it is, the prompt_memory string is set to \"EMPTY!\". Otherwise, the function iterates over each belief in the \"buf\" variable using the enumerate() function. For each belief, it extracts the time, frequency, and confidence level from the belief tuple. It then calls the Truth_Projection function to calculate the projected truth value of the belief at the current time based on its original truth value and the time difference between the original time and the current time.\n\nThe function also calls the Term_AsSentence function to convert the belief term into a sentence by applying specific formatting rules and transformations. If the confidence level of the belief is less than 0.5, the term is modified to include the phrase \"not\" before the main term.\n\nThe function constructs the prompt memory string by concatenating the belief index, the converted term, the time information, and the confidence level for each belief. The prompt_memory string is updated with each iteration.\n\nFinally, the function returns the \"buf\" variable, which contains the beliefs retrieved from the memory, and the constructed prompt memory string by concatenating the prompt_start, prompt_memory, and prompt_end strings.\n\n**Note**: \n- The Memory_generate_prompt function relies on the Memory_view and Truth_Projection functions to retrieve beliefs from the memory and calculate the projected truth value of beliefs.\n- The Term_AsSentence function is called to convert belief terms into sentences by applying specific formatting rules and transformations.\n- The prompt memory string includes information about each belief, such as its index, term, time, and confidence level.\n- If the memory is empty, the prompt memory string will be set to \"EMPTY!\".\n- The prompt memory string is constructed by concatenating the information of each belief in the memory.\n- The function provides the option to include an input question to retrieve beliefs related to the question.\n- The prompt memory string can be customized by specifying the prompt start and end strings.\n\n**Output Example**:\n- Input: Memory_generate_prompt(10.0, memory, \"Prompt Start:\", \"Prompt End.\", 5, 3, \"What is the capital of France?\")\n- Output: ([belief1, belief2, belief3], \"Prompt Start:i=0: 'belief1' time=10.0 confidence=0.8\\ni=1: 'belief2' time=9.5 confidence=0.6\\ni=2: 'belief3' time=9.0 confidence=0.7\\nPrompt End.\")"
      ],
      "code_start_line": 127,
      "code_end_line": 144,
      "parent": null,
      "params": [
        "currentTime",
        "memory",
        "prompt_start",
        "prompt_end",
        "relevantViewSize",
        "recentViewSize",
        "inpQuestion"
      ],
      "have_return": true,
      "code_content": "def Memory_generate_prompt(currentTime, memory, prompt_start, prompt_end, relevantViewSize, recentViewSize, inpQuestion = None):\n    prompt_memory = \"\"\n    buf = Memory_view(memory, relevantViewSize, recentViewSize, inpQuestion)\n    if len(buf) == 0:\n        prompt_memory = \"EMPTY!\"\n    for i,x in enumerate(buf):\n        time = x[0][1]\n        (f,c) = x[1][2]\n        timeterm = \"\"\n        if time != \"eternal\":\n            timeterm = \"time=\" + str(time) + \" \"\n            (f,c) = Truth_Projection((f,c), float(time), float(currentTime))\n        term = Term_AsSentence(x[0][0])\n        if f < 0.5:\n            words = term.split(\" \")\n            term = (words[0] + \" not \" + \" \".join(words[1:])).replace(\" not isa \", \" is not a \").replace(\" isa \", \" is a \")\n        prompt_memory += f\"i={i}: {term}. {timeterm}confidence={c}\\n\"\n    return buf, prompt_start + prompt_memory + prompt_end\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "NarsGPT.py/AddInput"
      ],
      "reference_who": [
        "Memory.py/Term_AsSentence",
        "Memory.py/Memory_view",
        "Truth.py/Truth_Projection"
      ]
    },
    "Lemmatize": {
      "type": "FunctionDef",
      "name": "Lemmatize",
      "md_content": [
        "**Lemmatize**: The function of Lemmatize is to perform lemmatization on a given word based on its part of speech tag.\n\n**parameters**:\n- word: A string representing the word to be lemmatized.\n- tag: A part of speech tag indicating the grammatical category of the word.\n\n**Code Description**:\nThe Lemmatize function takes a word and its corresponding part of speech tag as input. It first preprocesses the word by converting it to lowercase and replacing any spaces or hyphens with underscores. The ReplaceEncode function is then called to remove the suffix \"encode\" from the word if it ends with \"encode\" and has a length greater than 6 characters. \n\nNext, the function checks if the word contains underscores and the part of speech tag is a noun. If both conditions are met, the word is split into parts using underscores as separators. The last part of the word is lemmatized separately using the WordNetLemmatizer's lemmatize function, with the specified part of speech tag. The resulting lemmatized last part is then joined with the remaining parts using underscores. \n\nIf the part of speech tag is a verb, the function checks if the lemmatized word matches certain predefined verb forms. If a match is found, the function returns the standard form \"isa\" as the output.\n\nFinally, the function returns the lemmatized word after converting it to lowercase and replacing any spaces or hyphens with underscores.\n\n**Note**: \n- The Lemmatize function relies on the ReplaceEncode function to preprocess the word before lemmatization. It is important to note that the ReplaceEncode function is specifically designed to handle words that end with \"encode\" and have a length greater than 6 characters. It may not produce the desired result for words that do not meet these criteria.\n- The Lemmatize function uses the WordNetLemmatizer from the NLTK library for lemmatization. Make sure to import the necessary libraries and initialize the WordNetLemmatizer before using this function.\n- The Lemmatize function assumes that the part of speech tag provided is compatible with the WordNetLemmatizer's lemmatize function.\n\n**Output Example**:\n- Input: word = \"running\", tag = wordnet.VERB\n- Output: \"run\""
      ],
      "code_start_line": 147,
      "code_end_line": 159,
      "parent": null,
      "params": [
        "word",
        "tag"
      ],
      "have_return": true,
      "code_content": "def Lemmatize(word, tag):\n    global used_verbs\n    word = ReplaceEncode(word.lower().replace(\" \", \"_\").replace(\"-\",\"_\"))\n    if \"_\" in word and tag == wordnet.NOUN:\n        parts = word.split(\"_\")\n        lastpart = lemma.lemmatize(parts[-1], pos = tag).strip().lower().replace(\" \",\"_\").replace(\"-\",\"_\")\n        ret = \"_\".join(parts[:-1]) + \"_\" + lastpart\n    else:\n        ret = lemma.lemmatize(word.lower(), pos = tag).strip().lower().replace(\" \",\"_\").replace(\"-\",\"_\")\n        if tag == wordnet.VERB:\n            if ret == \"is\" or ret == \"isa\" or ret == \"is_a\" or ret == \"be\" or ret == \"are\" or ret == \"were\" or ret == \"arelike\" or ret == \"islike\":\n                return \"isa\"\n    return ret\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "Memory.py/Relation",
        "Memory.py/Property"
      ],
      "reference_who": [
        "Memory.py/ReplaceEncode"
      ]
    },
    "Atomize": {
      "type": "FunctionDef",
      "name": "Atomize",
      "md_content": [
        "**Atomize**: The function of Atomize is to retrieve or create an atom for a given input. It checks if the atom already exists in the atoms dictionary using a key generated from the input and position. If the atom exists, it retrieves the corresponding embedding from the atoms dictionary. If the atom does not exist, it calls the `get_embedding_robust` function to retrieve the embedding for the input. \n\n**parameters**:\n- atom: The input atom to be atomized.\n- atoms: A dictionary containing the existing atoms and their embeddings.\n- pos: The position of the atom in the sentence (e.g., \"NOUN\", \"VERB\").\n- atomCreationThreshold: The threshold value for creating a new atom.\n\n**Code Description**:\nThe `Atomize` function takes an input atom, a dictionary of existing atoms, the position of the atom, and a threshold value for creating a new atom. It first generates a key for the input atom and position by concatenating them with a separator (\";;\"). It then checks if the key exists in the atoms dictionary. If the key exists, it retrieves the corresponding embedding from the dictionary. If the key does not exist, it calls the `get_embedding_robust` function to retrieve the embedding for the input atom.\n\nThe function then iterates over all the keys in the atoms dictionary. For each key, it splits the atom and position using the separator and checks if the position matches the given position. If the positions match, it retrieves the embedding for that key and calculates the match quality between the input atom embedding and the retrieved embedding using the cosine similarity measure. The function keeps track of the closest atom and its match quality.\n\nAfter iterating through all the keys, the function checks if the closest match quality is below the atomCreationThreshold. If it is, it returns the input atom as the atomized result and adds the input atom and its embedding to the atoms dictionary using the generated key. If the closest match quality is above the threshold, it returns the closest atom as the atomized result.\n\n**Note**: \n- The function assumes that the `get_embedding_robust` function is implemented and available for use.\n- The function uses the `cosine_similarity` function to calculate the match quality between embeddings. The implementation of this function is not provided in the code snippet.\n\n**Output Example**:\nIf the closest match quality is below the atomCreationThreshold, the function returns the input atom as the atomized result. If the closest match quality is above the threshold, the function returns the closest atom as the atomized result."
      ],
      "code_start_line": 161,
      "code_end_line": 182,
      "parent": null,
      "params": [
        "atom",
        "atoms",
        "pos",
        "atomCreationThreshold"
      ],
      "have_return": true,
      "code_content": "def Atomize(atom, atoms, pos, atomCreationThreshold):\n    splitter = \";;\"\n    key = atom + splitter + str(pos)\n    atomembedding = atoms[key] if key in atoms else get_embedding_robust(atom)\n    closest_atom = None\n    closest_quality = None\n    for key2 in atoms:\n        atom2, pos2 = key2.split(splitter)\n        if pos2 == pos:\n            embedding = atoms[key2]\n            matchQuality = cosine_similarity(atomembedding, embedding)\n            #print(\"!!!\", atom2, atom, matchQuality)\n            if closest_atom is None or matchQuality > closest_quality:\n                closest_atom = atom2\n                closest_quality = matchQuality\n    if closest_quality is None or closest_quality < atomCreationThreshold:\n        ret = atom\n        atoms[key] = atomembedding\n    else:\n        #print(f\"REPLACED {atom} with {closest_atom} matchVal={matchQuality}\")\n        ret = closest_atom\n    return ret\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "Memory.py/Relation",
        "Memory.py/Property",
        "NarsGPT.py/AddInput"
      ],
      "reference_who": [
        "Memory.py/get_embedding_robust"
      ]
    },
    "Allow_requery_if_not_in_ONA": {
      "type": "FunctionDef",
      "name": "Allow_requery_if_not_in_ONA",
      "md_content": [
        "**Allow_requery_if_not_in_ONA**: The function of Allow_requery_if_not_in_ONA is to check if a previously queried item is still present in the ONA memory. If the item is no longer in memory, it sets it up for re-query by removing it from the 'retrieved' list.\n\n**parameters**:\n- RET_DICT: A dictionary that stores the merged contents.\n- term: The term of the item to be checked.\n- time: The time of the item to be checked.\n\n**Code Description**:\nThe Allow_requery_if_not_in_ONA function first checks if the (term, time) tuple is present in the 'retrieved' list. If it is, it proceeds to call the NAR.AddInput function with a modified term, which appends a question mark to the original term. The resulting dictionary 'ret' is then merged into the 'RET_DICT' dictionary using the MergeInto function. \n\nIf the 'ret' dictionary contains an \"answers\" key with a non-empty value, the function checks the first answer for the absence of a \"truth\" key and a term value of \"None\". If these conditions are met, it removes the (term, time) tuple from the 'retrieved' list.\n\n**Note**: \n- The Allow_requery_if_not_in_ONA function assumes that the 'retrieved' list and the 'retrieved' list are defined and accessible within the scope of the function.\n- The function does not handle cases where the 'retrieved' list is not initialized or is not of the expected type.\n- The function does not handle cases where the 'retrieved' list contains tuples that are not compatible with the (term, time) format.\n- The function does not handle cases where the 'retrieved' list contains tuples that should not be removed.\n\nThe Allow_requery_if_not_in_ONA function is called in the Memory.py/query object. In this object, the function is called after checking if the (term, time) tuple is not in the 'retrieved' list and is present in the 'memory' dictionary. If these conditions are met, the (term, time) tuple is added to the 'retrieved' list, and the NAR.AddInput function is called with a \"*stampimport\" command, passing the 'stamp' value from the 'memory' dictionary. If the 'time' value is \"eternal\", the ProcessInput function is called with modified parameters.\n\nThe Allow_requery_if_not_in_ONA function is also called in the Memory.py/query object when a simple query matching condition is met. In this case, the function iterates over the 'memory' dictionary and checks for terms that start with the first part of the 'term' and end with the second part of the 'term'. It selects the best matching term based on the truth expectation value and retrieves its corresponding (term, time) tuple from the 'retrieved' list. The NAR.AddInput function is then called with a \"*stampimport\" command, passing the 'stamp' value from the 'memory' dictionary. If the 'bestTime' value is \"eternal\", the ProcessInput function is called with modified parameters.\n\n**Note**: The specific implementation and usage of the Allow_requery_if_not_in_ONA function may vary depending on the context and requirements of the project. It is important to review and understand the code and its dependencies before using it in a different project or modifying it for specific use cases."
      ],
      "code_start_line": 185,
      "code_end_line": 194,
      "parent": null,
      "params": [
        "RET_DICT",
        "term",
        "time"
      ],
      "have_return": false,
      "code_content": "def Allow_requery_if_not_in_ONA(RET_DICT, term, time):\n    #check if previously queried item is not in ONA memory anymore else we need\n    #to set it up for re-query by removing it from retrieved\n    if (term, time) in retrieved:\n        ret = NAR.AddInput(term + \"?\", Print=Print)\n        MergeInto(RET_DICT, ret)\n        if \"answers\" in ret and ret[\"answers\"]:\n            answer = ret[\"answers\"][0]\n            if \"truth\" not in answer and answer[\"term\"] == \"None\":\n                retrieved.remove(term, time)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "Memory.py/query"
      ],
      "reference_who": [
        "Memory.py/MergeInto"
      ]
    },
    "query": {
      "type": "FunctionDef",
      "name": "query",
      "md_content": [
        "**query**: The function of query is to retrieve information from the memory based on a given term and time. It also handles simple query matching and updates the 'retrieved' list.\n\n**parameters**:\n- RET_DICT: A dictionary that stores the merged contents.\n- currentTime: An integer representing the current time.\n- memory: A dictionary that stores the memory items.\n- term: A string representing the term to be queried.\n- time: A string or integer representing the time of the item to be queried.\n\n**Code Description**:\nThe query function starts by checking if the 'time' parameter is not equal to \"eternal\". If it is not, the function returns the current time. This condition is used to handle cases where the time is not \"eternal\" and no further processing is required.\n\nNext, the function calls the Allow_requery_if_not_in_ONA function, passing the 'RET_DICT', 'term', and 'time' parameters. This function is responsible for checking if a previously queried item is still present in the ONA memory. If the item is no longer in memory, it sets it up for re-query by removing it from the 'retrieved' list.\n\nAfter that, the function checks if the (term, time) tuple is not in the 'retrieved' list and is present in the 'memory' dictionary. If these conditions are met, the (term, time) tuple is added to the 'retrieved' list, and the NAR.AddInput function is called with a \"*stampimport\" command, passing the 'stamp' value from the 'memory' dictionary. This step is performed to update the NAR system with the retrieved item.\n\nIf the 'time' value is \"eternal\", the function proceeds to call the ProcessInput function with modified parameters. The ProcessInput function is responsible for processing the retrieved item and updating the memory and current time accordingly.\n\nAdditionally, the function handles simple query matching when the term contains \"?1\". It splits the term into two parts and iterates over the 'memory' dictionary to find matching terms that start with the first part and end with the second part. It selects the best matching term based on the truth expectation value and retrieves its corresponding (term, time) tuple from the 'retrieved' list. The NAR.AddInput function is then called with a \"*stampimport\" command, passing the 'stamp' value from the 'memory' dictionary. If the 'bestTime' value is \"eternal\", the ProcessInput function is called with modified parameters.\n\nFinally, the function adds the (term, time) tuple to the 'retrieved' list and returns the current time.\n\n**Note**: \n- The specific implementation and usage of the query function may vary depending on the context and requirements of the project. It is important to review and understand the code and its dependencies before using it in a different project or modifying it for specific use cases.\n- The query function assumes that the 'retrieved' list, 'NAR' object, 'Print' variable, and other referenced functions and variables are defined and accessible within the scope of the function.\n- The function does not handle cases where the 'retrieved' list is not initialized or is not of the expected type.\n- The function does not handle cases where the 'memory' dictionary is not initialized or does not contain the expected keys and values.\n- The function does not handle cases where the 'term' and 'time' parameters are not of the expected types or formats.\n- The function does not handle cases where the 'NAR.AddInput' function does not exist or does not support the \"*stampimport\" command.\n- The function does not handle cases where the 'ProcessInput' function does not exist or does not support the expected parameters and return values.\n\n**Output Example**: If the 'time' parameter is not \"eternal\" and the conditions for re-querying are not met, the query function will return the current time."
      ],
      "code_start_line": 196,
      "code_end_line": 226,
      "parent": null,
      "params": [
        "RET_DICT",
        "currentTime",
        "memory",
        "term",
        "time"
      ],
      "have_return": true,
      "code_content": "def query(RET_DICT, currentTime, memory, term, time):\n    global retrieved\n    if time != \"eternal\":\n        return currentTime\n    Allow_requery_if_not_in_ONA(RET_DICT, term, time)\n    if (term, time) not in retrieved and (term, time) in memory:\n        retrieved.add((term, time))\n        (_, _, (f, c), stamp, _) = memory[(term, time)]\n        NAR.AddInput(\"*stampimport=\" + str(stamp), Print=Print)\n        if time == \"eternal\":\n            _, currentTime = ProcessInput(RET_DICT, currentTime, memory, f\"{term}. {{{f} {c}}}\")\n    if \"?1\" in term: #simple query matching\n        parts = term.split(\"?1\")\n        bestTerm, bestTruth, bestTime, bestStamp = (None, (0.0, 0.5), \"eternal\", [])\n        for (term2, time2) in memory:\n            (_, _, (f2, c2), stamp, _) = memory[(term2, time2)]\n            if time2 == \"eternal\" and term2.startswith(parts[0]) and term2.endswith(parts[1]):\n                if Truth_Expectation((f2, c2)) > Truth_Expectation((bestTruth[0], bestTruth[1])):\n                    bestTerm = term2\n                    bestTruth = (f2, c2)\n                    bestTime = time2\n                    bestStamp = stamp\n        if bestTerm is not None:\n            Allow_requery_if_not_in_ONA(bestTerm, time)\n        if bestTerm is not None and (bestTerm, bestTime) not in retrieved:\n            retrieved.add((bestTerm, bestTime))\n            NAR.AddInput(\"*stampimport=\" + str(bestStamp), Print=Print)\n            if bestTime == \"eternal\":\n                _, currentTime = ProcessInput(RET_DICT, currentTime, memory, f\"{bestTerm}. {{{bestTruth[0]} {bestTruth[1]}}}\")\n    retrieved.add((term, time))\n    return currentTime\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "Memory.py/ProcessInput",
        "Memory.py/Memory_QuestionPriming",
        "NarsGPT.py/AddInput"
      ],
      "reference_who": [
        "Memory.py/Allow_requery_if_not_in_ONA",
        "Memory.py/ProcessInput",
        "Truth.py/Truth_Expectation"
      ]
    },
    "ProcessInput": {
      "type": "FunctionDef",
      "name": "ProcessInput",
      "md_content": [
        "**ProcessInput**: The function of ProcessInput is to process the input for the NAR (Non-Axiomatic Reasoning) system. It takes various parameters and performs several operations on the input data.\n\n**parameters**:\n- RET_DICT: A dictionary that stores the merged contents.\n- currentTime: An integer representing the current time.\n- memory: A dictionary that stores the memory items.\n- inputforNAR: A string representing the input data for the NAR system.\n- backups (optional): A list of strings representing the backup types to be added to memory.\n\n**Code Description**:\nThe ProcessInput function starts by calling the NAR.AddInput function with the inputforNAR parameter and the Print parameter. This function adds the input to the NAR system and returns a dictionary containing the results.\n\nThe function then merges the contents of the 'ret' dictionary into the 'RET_DICT' dictionary using the MergeInto function. The MergeInto function is called with the RET_DICT and ret dictionaries as parameters. This step ensures that the contents of the 'ret' dictionary are added to the 'RET_DICT' dictionary.\n\nNext, the function iterates over the 'ret' dictionary and performs the following operations for each execution:\n- It extracts the reason and desire values from the 'ret' dictionary if they exist.\n- It appends the reason hypothesis to the TestedCausalHypotheses list.\n- It prints the execution, expectation, and reason values.\n\nAfter that, the function iterates over the backups list and performs the following operations for each backup type:\n- It retrieves the corresponding items from the 'ret' dictionary and adds them to the 'it' list.\n- If the backup type is \"input\", it appends the TestedCausalHypotheses list to the 'it' list.\n- It iterates over the 'it' list and performs the following operations for each derivation:\n  - It checks if the derivation meets certain conditions to continue or skip certain operations.\n  - It processes the term and extracts the time, stamp, frequency, and confidence values.\n  - It checks if the (term, time) tuple is already in memory and updates the memory if necessary.\n  - It creates a new entry in the memory if the (term, time) tuple is not already in memory.\n\nThe function then performs additional operations based on the inputforNAR value. If the inputforNAR contains certain characters or patterns, the currentTime value is updated accordingly.\n\nFinally, the function returns the merged dictionary 'ret' and the updated 'currentTime' value.\n\n**Note**:\n- The ProcessInput function is designed to process the input for the NAR system and update the memory accordingly.\n- The function assumes that the NAR.AddInput, MergeInto, and query functions are defined and accessible within the scope of the function.\n- The function does not handle cases where the 'ret' dictionary does not contain the expected keys and values.\n- The function does not handle cases where the 'backups' parameter is not of the expected type or format.\n- The function does not handle cases where the 'inputforNAR' parameter is not of the expected type or format.\n- The function does not handle cases where the 'Print' parameter is not of the expected type or format.\n\n**Output Example**:\nIf the 'ret' dictionary initially contains {'executions': [{'execution1': 'value1'}, {'execution2': 'value2'}], 'answers': [{'answer1': 'value1'}, {'answer2': 'value2'}]}, and the 'currentTime' value is 10, the function will return the merged dictionary {'executions': [{'execution1': 'value1'}, {'execution2': 'value2'}], 'answers': [{'answer1': 'value1'}, {'answer2': 'value2'}]}, and the updated 'currentTime' value will depend on the specific operations performed in the function."
      ],
      "code_start_line": 228,
      "code_end_line": 279,
      "parent": null,
      "params": [
        "RET_DICT",
        "currentTime",
        "memory",
        "inputforNAR",
        "backups"
      ],
      "have_return": true,
      "code_content": "def ProcessInput(RET_DICT, currentTime, memory, inputforNAR, backups = [\"input\", \"answers\", \"derivations\"]):\n    ret = NAR.AddInput(inputforNAR, Print=Print)\n    MergeInto(RET_DICT, ret)\n    TestedCausalHypotheses = []\n    for execution in ret[\"executions\"]:\n        reason = \"\"\n        desire = 0.0\n        if \"reason\" in ret and ret[\"reason\"] is not None:\n            reason = ret[\"reason\"][\"hypothesis\"]\n            desire = ret[\"reason\"][\"desire\"]\n            TestedCausalHypotheses.append(ret[\"reason\"][\"hypothesis\"])\n        print(execution, \"expectation=\"+str(desire), reason)\n    for backup in backups:\n        it = ret[backup] + TestedCausalHypotheses if backup == \"input\" else ret[backup] #append causal hypotheses to be added to memory!\n        for derivation in it:\n            if derivation[\"punctuation\"] == \".\" and derivation[\"term\"] != \"None\":\n                term = derivation[\"term\"]\n                Continue = False\n                for forbidden in [\" /1 \", \" \\\\1 \", \" /2 \", \" \\\\2 \", \" & \", \" | \", \" ~ \", \" - \", \" <=> \", \" && \", \" || \", \" ==> \", \" <-> \", \" =/> \", \" . \"]:\n                    if forbidden in term and derivation not in TestedCausalHypotheses:\n                        Continue = True\n                if Continue:\n                    continue\n                if term.startswith(\"dt=\"): #we don't need to store time deltas\n                    term = \" \".join(term.split(\" \")[1:])\n                if term.startswith(\"<[\") or (\" --> \" in term and \" * \" in term.split(\" --> \")[1]):\n                    continue\n                time = derivation[\"occurrenceTime\"]\n                stamp = derivation[\"Stamp\"]\n                if str(time).isdigit():\n                    time = int(time)\n                currentTime = query(RET_DICT, currentTime, memory, term, time)\n                f2 = float(derivation[\"truth\"][\"frequency\"])\n                c2 = float(derivation[\"truth\"][\"confidence\"])\n                usefulnessAddition = 1000000 if \"Priority\" not in derivation or derivation[\"Priority\"] == 1.0 else 1\n                if (term, time) in memory:\n                    (t, usefulness, (f, c), _, embedding) = memory[(term, time)]\n                    if c2 > c:\n                        memory[(term, time)] = (currentTime, usefulness + usefulnessAddition, (f2, c2), stamp, embedding)\n                else:\n                    #optimization: if there is already an eternalized version with the same term, use that embedding:\n                    if (term, \"eternal\") in memory:\n                        embedding = memory[(term, \"eternal\")][4]\n                    else:\n                        embedding = Term_Embedded(term)\n                    #now where we got the embedding too, make entry to memory:\n                    memory[(term, time)] = (currentTime, usefulnessAddition, (f2, c2), stamp, embedding)\n    if \">.\" in inputforNAR or \"! :|:\" in inputforNAR or \". :|:\" in inputforNAR:\n        currentTime += 1\n    if inputforNAR.isdigit():\n        currentTime += int(inputforNAR)\n    return ret, currentTime\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "Memory.py/query",
        "Memory.py/Relation",
        "Memory.py/Property",
        "NarsGPT.py/AddInput"
      ],
      "reference_who": [
        "Memory.py/MergeInto",
        "Memory.py/Term_Embedded",
        "Memory.py/query"
      ]
    },
    "notIncluded": {
      "type": "FunctionDef",
      "name": "notIncluded",
      "md_content": [
        "**notIncluded**: The function of notIncluded is to check if a modified word is included in a given input string.\n\n**parameters**:\n- word: A string representing the word to be processed.\n- inp: A string representing the input string to be checked against.\n\n**Code Description**:\nThe notIncluded function takes two input parameters: \"word\" and \"inp\". The \"word\" parameter represents the word to be processed, while the \"inp\" parameter represents the input string to be checked against. \n\nThe function first calls the ReplaceEncode function to modify the \"word\" parameter. The ReplaceEncode function removes the suffix \"encode\" from the word if it ends with \"encode\" and has a length greater than 6 characters. The modified word is then assigned back to the \"word\" parameter.\n\nNext, the function replaces all occurrences of the underscore character \"_\" in the modified word with a space character \" \". This is done using the replace() method of the string object. The resulting modified word is then compared with the input string \"inp\".\n\nThe function also performs additional replacements on the input string \"inp\" before the comparison. It replaces all occurrences of the substring \". \" (period followed by space) with a space character \" \". It also replaces all occurrences of the single quote character \"'\" with an empty string.\n\nFinally, the function checks if the modified word is not found in the modified input string. If the modified word is not included in the modified input string, the function returns True, indicating that the word is not included. Otherwise, it returns False.\n\n**Note**: \n- The ReplaceEncode function is specifically designed to handle words that end with \"encode\" and have a length greater than 6 characters. It may not produce the desired result for words that do not meet these criteria.\n- The notIncluded function modifies the original word by calling the ReplaceEncode function. If you need to preserve the original word, make a copy before calling the notIncluded function.\n- The function performs multiple replacements on the modified word and input string to ensure consistent comparison. Make sure to consider these replacements when using the function.\n\n**Output Example**:\n- Input: word = \"exampleencode\", inp = \"This is an example.\"\n- Output: True"
      ],
      "code_start_line": 281,
      "code_end_line": 283,
      "parent": null,
      "params": [
        "word",
        "inp"
      ],
      "have_return": true,
      "code_content": "def notIncluded(word, inp):\n    word = ReplaceEncode(word)\n    return word.replace(\"_\", \" \") not in inp.replace(\". \",\" \").replace(\"'\",\"\")\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "Memory.py/Relation",
        "Memory.py/Property"
      ],
      "reference_who": [
        "Memory.py/ReplaceEncode"
      ]
    },
    "Relation": {
      "type": "FunctionDef",
      "name": "Relation",
      "md_content": [
        "**Relation**: The function of Relation is to process a relation between subject, verb, and predicate in a given input sentence. It performs various operations on the input data and updates the memory accordingly.\n\n**parameters**:\n- RET_DICT: A dictionary that stores the merged contents.\n- inp: A string representing the input data.\n- currentTime: An integer representing the current time.\n- memory: A dictionary that stores the memory items.\n- atoms: A dictionary containing the existing atoms and their embeddings.\n- s: A string representing the subject of the relation.\n- v: A string representing the verb of the relation.\n- p: A string representing the predicate of the relation.\n- punctuation_tv: A string representing the punctuation and truth value of the relation.\n- ImportGPTKnowledge: A boolean indicating whether GPT knowledge should be imported.\n- atomCreationThreshold: The threshold value for creating a new atom.\n\n**Code Description**:\nThe Relation function takes various input parameters and performs several operations on the input data. It first checks if the ImportGPTKnowledge flag is False and if either the subject (s) or predicate (p) is not included in the input (inp). If these conditions are met, the function returns False, the current time, and an empty sentence.\n\nNext, the function performs lemmatization on the subject (s), predicate (p), and verb (v) using the Lemmatize function. The Lemmatize function converts the words to lowercase, replaces spaces and hyphens with underscores, and removes the suffix \"encode\" if applicable. The lemmatized words are then passed to the Atomize function to retrieve or create atoms for each word. The Atomize function checks if the atoms already exist in the atoms dictionary and retrieves the corresponding embeddings. If the atoms do not exist, it calls the get_embedding_robust function to retrieve the embeddings. The function also adds the verb (v) to the set of relations.\n\nAfter the lemmatization and atomization process, the function checks if any of the subject (s), verb (v), or predicate (p) is empty. If any of them is empty, the function returns False, the current time, and an empty sentence.\n\nThe function then checks if the verb (v) is \"isa\" or \"are\". If it is, the function compares the subject (s) and predicate (p). If they are the same, the function returns False, the current time, and an empty sentence. Otherwise, it constructs a sentence using angle brackets (\"< >\") to represent the relation and appends the punctuation_tv string. The constructed sentence is then passed to the ProcessInput function to update the memory.\n\nIf the verb (v) is not \"isa\" or \"are\", the function constructs a sentence using angle brackets (\"< >\") to represent the relation between the subject (s), predicate (p), and verb (v). The sentence is then passed to the ProcessInput function to update the memory.\n\nFinally, the function returns True, the current time, and the constructed sentence.\n\n**Note**: \n- The Relation function relies on the Lemmatize and Atomize functions to preprocess and atomize the subject, verb, and predicate before constructing the relation sentence. It is important to ensure that these functions are implemented and accessible within the scope of the Relation function.\n- The Relation function assumes that the Lemmatize and Atomize functions are compatible with the specified input parameters and return the expected results.\n- The Relation function uses the ProcessInput function to update the memory with the constructed relation sentence. Make sure to import the necessary libraries and initialize the required variables before using this function.\n- The Relation function assumes that the ProcessInput function is implemented and accessible within the scope of the Relation function.\n\n**Output Example**:\n- Input: RET_DICT = {}, inp = \"This is an example.\", currentTime = 0, memory = {}, atoms = {}, s = \"example\", v = \"is\", p = \"an\", punctuation_tv = \".\", ImportGPTKnowledge = False, atomCreationThreshold = 0.5\n- Output: True, 0, \"<example --> an>.\""
      ],
      "code_start_line": 286,
      "code_end_line": 306,
      "parent": null,
      "params": [
        "RET_DICT",
        "inp",
        "currentTime",
        "memory",
        "atoms",
        "s",
        "v",
        "p",
        "punctuation_tv",
        "ImportGPTKnowledge",
        "atomCreationThreshold"
      ],
      "have_return": true,
      "code_content": "def Relation(RET_DICT, inp, currentTime, memory, atoms, s, v, p, punctuation_tv, ImportGPTKnowledge, atomCreationThreshold):\n    global relations\n    sentence = \"\"\n    if not ImportGPTKnowledge and (notIncluded(s, inp) or notIncluded(p, inp)):\n        #print(\"//!!!! filtered out\", s, v, p)\n        return False, currentTime, sentence\n    s = Atomize(Lemmatize(s, wordnet.NOUN), atoms, \"NOUN\", atomCreationThreshold)\n    p = Atomize(Lemmatize(p, wordnet.NOUN), atoms, \"NOUN\", atomCreationThreshold)\n    v = Atomize(Lemmatize(v, wordnet.VERB), atoms, \"VERB\", atomCreationThreshold)\n    relations.add(v)\n    if s == \"\" or v == \"\" or p == \"\":\n        return False, currentTime, sentence\n    if v == \"isa\" or v == \"are\":\n        if s == p:\n            return False, currentTime, sentence\n        sentence = f\"<{s} --> {p}>\" + punctuation_tv\n        _, currentTime = ProcessInput(RET_DICT, currentTime, memory, sentence)\n    else:\n        sentence = f\"<({s} * {p}) --> {v}>\" + punctuation_tv\n        _, currentTime = ProcessInput(RET_DICT, currentTime, memory, sentence)\n    return True, currentTime, sentence\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "Memory.py/Memory_digest_sentence"
      ],
      "reference_who": [
        "Memory.py/Lemmatize",
        "Memory.py/Atomize",
        "Memory.py/ProcessInput",
        "Memory.py/notIncluded"
      ]
    },
    "Property": {
      "type": "FunctionDef",
      "name": "Property",
      "md_content": [
        "**Property**: The Property function is responsible for processing a given input and determining if it satisfies certain conditions for a property relation. It checks if the input should be filtered out based on the ImportGPTKnowledge flag and if the subject or property are not included in the input. It then performs lemmatization on the subject and property using the Lemmatize function and atomizes them using the Atomize function. If the subject or property are empty or equal, the function returns False. Otherwise, it constructs a sentence string representing the property relation and passes it to the ProcessInput function for further processing. Finally, the function returns True, the current time, and the constructed sentence.\n\n**parameters**:\n- RET_DICT: A dictionary that stores the merged contents.\n- inp: A string representing the input data.\n- currentTime: An integer representing the current time.\n- memory: A dictionary that stores the memory items.\n- atoms: A dictionary containing the existing atoms and their embeddings.\n- s: A string representing the subject of the property relation.\n- p: A string representing the property of the property relation.\n- punctuation_tv: A string representing the punctuation and truth value of the property relation.\n- ImportGPTKnowledge: A boolean flag indicating whether GPT knowledge should be imported.\n- atomCreationThreshold: The threshold value for creating a new atom.\n\n**Code Description**:\nThe Property function takes several input parameters and performs a series of operations to determine if a given input satisfies the conditions for a property relation. \n\nFirst, the function checks if the ImportGPTKnowledge flag is False and if either the subject (s) or property (p) are not included in the input (inp). If either of these conditions is true, the function returns False, the current time (currentTime), and an empty sentence string.\n\nNext, the function calls the Lemmatize function to perform lemmatization on the subject and property. The Lemmatize function takes a word and its corresponding part of speech tag as input and returns the lemmatized word. In this case, the Lemmatize function is called with the subject (s) and property (p) as inputs and the part of speech tags \"NOUN\" and \"ADJ\" respectively. The lemmatized subject and property are then assigned back to the s and p variables.\n\nThe function then checks if the subject (s) or property (p) are empty or if they are equal. If any of these conditions are true, the function returns False, the current time (currentTime), and an empty sentence string.\n\nIf none of the above conditions are met, the function constructs a sentence string representing the property relation using the subject (s), property (p), and punctuation_tv parameters. The sentence string is constructed by enclosing the subject in angle brackets (\"< >\"), followed by an arrow (\"-->\"), and then enclosing the property in square brackets (\"[ ]\"). The punctuation_tv parameter is then appended to the sentence string.\n\nAfter constructing the sentence string, the function calls the ProcessInput function with the RET_DICT, currentTime, memory, and sentence parameters. The ProcessInput function processes the input for the NAR system and updates the memory accordingly. The function then returns True, the updated current time (currentTime), and the constructed sentence string.\n\n**Note**: \n- The Property function relies on the Lemmatize and Atomize functions to process the subject and property before constructing the property relation sentence. It is important to ensure that these functions are implemented and accessible within the scope of the Property function.\n- The Property function assumes that the part of speech tags provided to the Lemmatize function are compatible with the WordNetLemmatizer's lemmatize function.\n- The Property function assumes that the ProcessInput function is defined and accessible within the scope of the Property function.\n- The Property function assumes that the RET_DICT dictionary is initialized and accessible within the scope of the Property function.\n- The Property function assumes that the memory and atoms dictionaries are initialized and accessible within the scope of the Property function.\n- The Property function assumes that the punctuation_tv parameter is a string representing the punctuation and truth value of the property relation.\n- The Property function assumes that the ImportGPTKnowledge flag is a boolean value indicating whether GPT knowledge should be imported.\n- The Property function assumes that the atomCreationThreshold parameter is a threshold value for creating a new atom.\n\n**Output Example**:\n- Input: RET_DICT = {}, inp = \"This is an example.\", currentTime = 10, memory = {}, atoms = {}, s = \"example\", p = \"property\", punctuation_tv = \". :|: {0.8 0.9}\", ImportGPTKnowledge = False, atomCreationThreshold = 0.5\n- Output: (True, 10, \"<example --> [property]> :|: {0.8 0.9}.\")"
      ],
      "code_start_line": 308,
      "code_end_line": 319,
      "parent": null,
      "params": [
        "RET_DICT",
        "inp",
        "currentTime",
        "memory",
        "atoms",
        "s",
        "p",
        "punctuation_tv",
        "ImportGPTKnowledge",
        "atomCreationThreshold"
      ],
      "have_return": true,
      "code_content": "def Property(RET_DICT, inp, currentTime, memory, atoms, s, p, punctuation_tv, ImportGPTKnowledge, atomCreationThreshold):\n    sentence = \"\"\n    if not ImportGPTKnowledge and (notIncluded(s, inp) or notIncluded(p, inp)):\n        #print(\"//!!!! filtered out\", s, \"hasproperty\", p)\n        return False, currentTime, sentence\n    s = Atomize(Lemmatize(s, wordnet.NOUN), atoms, \"NOUN\", atomCreationThreshold)\n    p = Atomize(Lemmatize(p, wordnet.ADJ), atoms, \"ADJ\", atomCreationThreshold)\n    if s == \"\" or p == \"\" or s == p:\n        return False, currentTime, sentence\n    sentence = f\"<{s} --> [{p}]>\" + punctuation_tv\n    _, currentTime = ProcessInput(RET_DICT, currentTime, memory, sentence)\n    return True, currentTime, sentence\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "Memory.py/Memory_digest_sentence"
      ],
      "reference_who": [
        "Memory.py/Lemmatize",
        "Memory.py/Atomize",
        "Memory.py/ProcessInput",
        "Memory.py/notIncluded"
      ]
    },
    "Memory_digest_sentence": {
      "type": "FunctionDef",
      "name": "Memory_digest_sentence",
      "md_content": [
        "**Memory_digest_sentence**: The function of Memory_digest_sentence is to process a given input sentence and update the memory based on the relations and properties extracted from the sentence. It performs various operations on the input data and calls other functions to handle specific cases.\n\n**parameters**:\n- RET_DICT: A dictionary that stores the merged contents.\n- inp: A string representing the input data.\n- currentTime: An integer representing the current time.\n- memory: A dictionary that stores the memory items.\n- atoms: A dictionary containing the existing atoms and their embeddings.\n- sentence: A string representing the input sentence to be processed.\n- truth: A tuple representing the truth value of the sentence.\n- userGoal: A boolean indicating whether the sentence is a user goal.\n- PrintMemoryUpdates: A boolean indicating whether to print memory updates.\n- TimeHandling: A boolean indicating whether to handle time-related information.\n- ImportGPTKnowledge: A boolean indicating whether GPT knowledge should be imported.\n- atomCreationThreshold: The threshold value for creating a new atom.\n\n**Code Description**:\nThe Memory_digest_sentence function takes various input parameters and performs several operations on the input sentence. It first checks if the current time (currentTime) is different from the last time (lastTime). If they are different, it initializes the set of hadRelation to an empty set. This set is used to keep track of the relations that have already been processed.\n\nNext, the function checks if the input sentence is already in the set of hadRelation. If it is, the function returns False, the current time, and an empty string. This is to avoid processing duplicate sentences.\n\nIf the input sentence is not in the set of hadRelation, the function updates the lastTime to the current time. It then splits the input sentence into pieces using commas as the delimiter. Each piece is stripped of leading and trailing spaces and any spaces within are replaced with underscores. This is done to standardize the format of the pieces.\n\nThe function then determines the punctuation to be used based on whether the sentence is a user goal or not. If TimeHandling is enabled, the punctuation is formatted to include the truth value of the sentence. Otherwise, the punctuation only includes the truth value.\n\nNext, the function checks the number of pieces in the sentence. If there are three pieces, it further checks if the second piece is \"hasproperty\". If it is, the function calls the Property function to process the relation. Otherwise, it calls the Relation function to process the relation. Both functions are called with the appropriate input parameters.\n\nIf the number of pieces is not three, it means that the relation cannot be formed. In this case, the function returns False, the current time, and an empty string.\n\n**Note**: \n- The Memory_digest_sentence function relies on the Property and Relation functions to process the relations in the input sentence. It is important to ensure that these functions are implemented and accessible within the scope of the Memory_digest_sentence function.\n- The Memory_digest_sentence function assumes that the lastTime and hadRelation variables are initialized and accessible within the scope of the function.\n- The Memory_digest_sentence function assumes that the Property and Relation functions are compatible with the specified input parameters and return the expected results.\n- The Memory_digest_sentence function assumes that the RET_DICT, memory, and atoms dictionaries are initialized and accessible within the scope of the function.\n- The Memory_digest_sentence function assumes that the PrintMemoryUpdates flag is a boolean value indicating whether to print memory updates.\n- The Memory_digest_sentence function assumes that the TimeHandling flag is a boolean value indicating whether to handle time-related information.\n- The Memory_digest_sentence function assumes that the ImportGPTKnowledge flag is a boolean value indicating whether GPT knowledge should be imported.\n- The Memory_digest_sentence function assumes that the atomCreationThreshold parameter is a threshold value for creating a new atom.\n\n**Output Example**:\n- Input: RET_DICT = {}, inp = \"This is an example.\", currentTime = 0, memory = {}, atoms = {}, sentence = \"example hasproperty property\", truth = (0.8, 0.9), userGoal = False, PrintMemoryUpdates = True, TimeHandling = True, ImportGPTKnowledge = False, atomCreationThreshold = 0.5\n- Output: (True, 0, \"<example --> [property]> :|: {0.8 0.9}.\")"
      ],
      "code_start_line": 323,
      "code_end_line": 341,
      "parent": null,
      "params": [
        "RET_DICT",
        "inp",
        "currentTime",
        "memory",
        "atoms",
        "sentence",
        "truth",
        "userGoal",
        "PrintMemoryUpdates",
        "TimeHandling",
        "ImportGPTKnowledge",
        "atomCreationThreshold"
      ],
      "have_return": true,
      "code_content": "def Memory_digest_sentence(RET_DICT, inp, currentTime, memory, atoms, sentence, truth, userGoal, PrintMemoryUpdates, TimeHandling, ImportGPTKnowledge, atomCreationThreshold):\n    global lastTime, hadRelation\n    #print(\">>>>\", sentence)\n    if currentTime != lastTime:\n        hadRelation = set([])\n    if sentence in hadRelation:\n        return False, currentTime, \"\"\n    lastTime = currentTime\n    pieces = [x.strip().replace(\" \",\"_\") for x in sentence.split(\",\")]\n    punctuation = \"!\" if userGoal else \".\"\n    punctuation_tv = f\"{punctuation} :|: {{{truth[0]} {truth[1]}}}\" if TimeHandling else f\"{punctuation} {{{truth[0]} {truth[1]}}}\"\n    if len(pieces) == 3:\n        if pieces[1] == \"hasproperty\":\n            return Property(RET_DICT, inp, currentTime, memory, atoms, pieces[0], pieces[2], punctuation_tv, ImportGPTKnowledge, atomCreationThreshold)\n        else:\n            return Relation(RET_DICT, inp, currentTime, memory, atoms, *pieces, punctuation_tv, ImportGPTKnowledge, atomCreationThreshold)\n    else:\n        #print(\"//!!!! Can't form relation:\", pieces)\n        return False, currentTime, \"\"\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "Memory.py/Memory_inject_commands"
      ],
      "reference_who": [
        "Memory.py/Relation",
        "Memory.py/Property"
      ]
    },
    "Memory_load": {
      "type": "FunctionDef",
      "name": "Memory_load",
      "md_content": [
        "**Memory_load**: The function of Memory_load is to load the contents of a memory file and return the loaded memory, atom embeddings, current time, and the maximum base ID.\n\n**parameters**:\n- filename: A string representing the name of the memory file to load.\n\n**Code Description**:\nThe Memory_load function begins by initializing the memory variable as an empty dictionary, which will store the NARS-style long-term memory. The atoms variable is also initialized as an empty dictionary, which will map atoms to their embeddings. The currentTime variable is set to 1 initially.\n\nThe function then checks if the specified filename exists. If it does, the function proceeds to load the memory content from the file. It opens the file using the open() function and reads its contents using the json.load() function. The loaded content is stored in the variables mt and currentTime. The memory dictionary is then updated by converting the keys from strings to their corresponding Python objects using the literal_eval() function. The values are copied from mt to memory.\n\nNext, the function constructs the atomfile name by replacing the \".json\" extension of the filename with \"_atoms.json\". It opens the atomfile and reads its contents using the json.load() function. The loaded content is stored in the atoms dictionary.\n\nThe function then iterates over the keys in the memory dictionary and updates the maxBaseId variable by finding the maximum value among the base IDs stored in memory[key][3].\n\nFinally, the function returns a tuple containing the memory dictionary, atoms dictionary, currentTime, and maxBaseId.\n\n**Note**: \n- The function assumes that the filename parameter refers to a valid memory file.\n- The function expects the memory file to be in JSON format.\n- The function expects the atomfile to have the same name as the memory file, but with \"_atoms.json\" as the extension.\n\n**Output Example**:\n```python\nmemory = {\n    'key1': [value1],\n    'key2': [value2],\n    ...\n}\natoms = {\n    'atom1': [embedding1],\n    'atom2': [embedding2],\n    ...\n}\ncurrentTime = 12345\nmaxBaseId = 100\nreturn (memory, atoms, currentTime, maxBaseId)\n```"
      ],
      "code_start_line": 343,
      "code_end_line": 359,
      "parent": null,
      "params": [
        "filename"
      ],
      "have_return": true,
      "code_content": "def Memory_load(filename):\n    memory = {} #the NARS-style long-term memory\n    atoms = dict({}) #atom to embedding mapping\n    currentTime = 1\n    if exists(filename):\n        with open(filename) as json_file:\n            print(\"//Loaded memory content from\", filename)\n            (mt, currentTime) = json.load(json_file)\n            memory = {literal_eval(k): v for k, v in mt.items()}\n        atomfile = filename.replace(\".json\", \"_atoms.json\")\n        with open(atomfile) as json_file:\n            print(\"//Loaded atoms with embeddings from\", filename)\n            atoms = json.load(json_file)\n    maxBaseId = 0\n    for key in memory:\n        maxBaseId = max([maxBaseId] + memory[key][3])\n    return (memory, atoms, currentTime, maxBaseId)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "NarsGPT.py"
      ],
      "reference_who": []
    },
    "Memory_store": {
      "type": "FunctionDef",
      "name": "Memory_store",
      "md_content": [
        "**Memory_store**: The function of Memory_store is to store the contents of the memory and atoms into a file in JSON format.\n\n**parameters**:\n- filename: A string representing the name of the file to store the memory.\n- memory: A dictionary containing the memory data to be stored.\n- atoms: A dictionary containing the atom data to be stored.\n- currentTime: An integer representing the current time.\n\n**Code Description**:\nThe Memory_store function first opens the specified file in write mode using the 'w' flag. It then uses the json.dump() function to write the memory and currentTime data into the file. The memory data is converted into a dictionary comprehension where the keys are converted to strings and the values are preserved. The currentTime is stored as a tuple along with the memory data.\n\nNext, the function creates a new file name by replacing the \".json\" extension of the original filename with \"_atoms.json\". It opens this new file in write mode and uses json.dump() to write the atoms data into the file.\n\n**Note**:\n- The Memory_store function assumes that the filename parameter is a valid file name and that the file can be opened in write mode.\n- The function uses the json module to serialize the memory and atoms data into JSON format.\n- It is important to ensure that the memory and atoms parameters are dictionaries before calling the Memory_store function."
      ],
      "code_start_line": 361,
      "code_end_line": 366,
      "parent": null,
      "params": [
        "filename",
        "memory",
        "atoms",
        "currentTime"
      ],
      "have_return": false,
      "code_content": "def Memory_store(filename, memory, atoms, currentTime):\n    with open(filename, 'w') as f:\n        json.dump(({str(k): v for k, v in memory.items()}, currentTime), f)\n    atomfile = filename.replace(\".json\", \"_atoms.json\")\n    with open(atomfile, 'w') as f:\n        json.dump(atoms, f)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "NarsGPT.py/AddInput"
      ],
      "reference_who": []
    },
    "Memory_QuestionPriming": {
      "type": "FunctionDef",
      "name": "Memory_QuestionPriming",
      "md_content": [
        "**Memory_QuestionPriming**: The function of Memory_QuestionPriming is to process a command and prime the ONA's memory with a question. It retrieves the indices from the command, checks if they are present in the buffer, and activates the corresponding concepts in the memory by querying them.\n\n**parameters**:\n- RET_DICT: A dictionary that stores the merged contents.\n- currentTime: An integer representing the current time.\n- cmd: A string representing the command to be processed.\n- memory: A dictionary that stores the memory items.\n- buf: A list that stores the buffer items.\n\n**Code Description**:\nThe Memory_QuestionPriming function starts by extracting the indices from the command using string manipulation. It replaces the \"i=\" substring with \"item \" and splits the command based on \"item \" to get the index references. It then iterates over the index references, extracting the digits and adding them to the indices list. This step is performed to identify the indices present in the command.\n\nNext, the function checks if the indices are within the range of the buffer. If an index is valid, it retrieves the corresponding item from the buffer and calls the query function. The query function is responsible for retrieving information from the memory based on a given term and time. It updates the 'retrieved' list and activates the concepts in the memory.\n\nFinally, the function adds the (term, time) tuple to the 'retrieved' list and returns the current time.\n\n**Note**: \n- The specific implementation and usage of the Memory_QuestionPriming function may vary depending on the context and requirements of the project. It is important to review and understand the code and its dependencies before using it in a different project or modifying it for specific use cases.\n- The Memory_QuestionPriming function assumes that the 'query' function, 'RET_DICT' dictionary, 'currentTime' variable, 'cmd' string, 'memory' dictionary, and 'buf' list are defined and accessible within the scope of the function.\n- The function does not handle cases where the 'query' function does not exist or does not support the expected parameters and return values.\n- The function does not handle cases where the 'indices' list is not initialized or does not contain valid indices.\n- The function does not handle cases where the 'buf' list is not initialized or does not contain the expected items.\n- The function does not handle cases where the 'memory' dictionary is not initialized or does not contain the expected keys and values.\n- The function does not handle cases where the 'retrieved' list is not initialized or is not of the expected type.\n- The function does not handle cases where the 'query' function does not retrieve the expected information from the memory.\n- The function does not handle cases where the 'query' function does not activate the expected concepts in the memory.\n- The function does not handle cases where the 'query' function does not update the 'retrieved' list.\n- The function does not handle cases where the 'query' function does not return the expected current time.\n\n**Output Example**: If the indices in the command are valid and the query function retrieves the expected information from the memory, the Memory_QuestionPriming function will update the 'retrieved' list and return the current time."
      ],
      "code_start_line": 368,
      "code_end_line": 389,
      "parent": null,
      "params": [
        "RET_DICT",
        "currentTime",
        "cmd",
        "memory",
        "buf"
      ],
      "have_return": false,
      "code_content": "def Memory_QuestionPriming(RET_DICT, currentTime, cmd, memory, buf):\n    #1. get all memory index references\n    indexrefs = [x+\" \" for x in cmd.replace(\"i=\", \"item \").split(\"item \")]\n    indices=[]\n    for valstr in indexrefs:\n        curdigits = \"\"\n        i = 0\n        while i<len(valstr):\n            if valstr[i].isdigit():\n                curdigits += valstr[i]\n            else:\n                if curdigits.isdigit():\n                    indices.append(int(curdigits))\n                    curdigits = \"\"\n                if valstr[i] != \",\" and valstr[i] != \"-\":\n                    break\n            i += 1\n    #2. check if they are in buf and prime ONA's memory with the question which will activate the concepts:\n    for index in indices:\n        if index >= 0 and index < len(buf):\n            item = buf[index]\n            query(RET_DICT, currentTime, memory, item[0][0], item[0][1])\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "Memory.py/Memory_inject_commands"
      ],
      "reference_who": [
        "Memory.py/query"
      ]
    },
    "Memory_Eternalize": {
      "type": "FunctionDef",
      "name": "Memory_Eternalize",
      "md_content": [
        "**Memory_Eternalize**: The function of Memory_Eternalize is to eternalize the memory by deleting outdated beliefs and adding new beliefs based on the current time and eternalization distance.\n\n**Parameters**:\n- currentTime: The current time in the system.\n- memory: The memory object containing beliefs.\n- eternalizationDistance: The time duration after which beliefs are considered outdated and need to be eternalized.\n\n**Code Description**:\nThe Memory_Eternalize function iterates through each belief in the memory object. If the belief is not already eternal and the time difference between the current time and the belief's timestamp is greater than the eternalization distance, the belief is considered outdated and needs to be eternalized.\n\nFor each outdated belief, the function checks if there is a corresponding belief in the memory with the \"eternal\" timestamp. If such a belief exists, the function retrieves the previous last used time and use count from the eternal belief. Otherwise, the previous last used time and use count are set to 0.\n\nThe outdated belief is then added to the list of beliefs to be deleted. The function also queries the ONA (Open NARS) system to get the belief truth for the outdated belief. If there are answers from the ONA system and the first answer contains the \"truth\" field, the function extracts the frequency and confidence values from the answer. The function also retrieves the timestamp of the answer.\n\nFinally, the function creates a new belief with the \"eternal\" timestamp and updates the last used time and use count based on the previous eternal belief and the outdated belief. The frequency, confidence, and timestamp values are set to the values obtained from the ONA system. This new belief is added to the list of beliefs to be added.\n\nAfter iterating through all beliefs, the function deletes the beliefs in the \"deletes\" list from the memory object. Then, it adds the beliefs in the \"additions\" list to the memory object.\n\n**Note**: \n- This function assumes that the memory object is a dictionary where the keys are tuples representing the belief and the timestamp, and the values are the belief information.\n- The function relies on the NAR.AddInput function from the NarsGPT.py module to query the ONA system and retrieve belief truth.\n- The function updates the memory object in-place by deleting outdated beliefs and adding new eternal beliefs."
      ],
      "code_start_line": 391,
      "code_end_line": 413,
      "parent": null,
      "params": [
        "currentTime",
        "memory",
        "eternalizationDistance"
      ],
      "have_return": false,
      "code_content": "def Memory_Eternalize(currentTime, memory, eternalizationDistance):\n    deletes = []\n    additions = []\n    for (m, t) in memory:\n        belief = memory[(m, t)]\n        if t != \"eternal\" and currentTime - t > eternalizationDistance:\n            previous_lastUsed = 0\n            previous_useCount = 0\n            if (m, \"eternal\") in memory:\n                belief_old = memory[(m, \"eternal\")]\n                previous_lastUsed = belief_old[0]\n                previous_useCount = belief_old[1]\n            deletes.append((m, t))\n            #Get belief truth from ONA\n            answers = NAR.AddInput(m + \"?\", Print=Print)[\"answers\"]\n            if answers and \"truth\" in answers[0]:\n                f,c = float(answers[0][\"truth\"][\"frequency\"]), float(answers[0][\"truth\"][\"confidence\"])\n                stamp = answers[0][\"Stamp\"]\n                additions.append(((m, \"eternal\"), (max(previous_lastUsed, belief[0]), previous_useCount + belief[1], (f,c), stamp, belief[4])))\n    for k in deletes:\n        del memory[k]\n    for (k, v) in additions:\n        memory[k] = v\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "NarsGPT.py/AddInput"
      ],
      "reference_who": []
    },
    "Memory_inject_commands": {
      "type": "FunctionDef",
      "name": "Memory_inject_commands",
      "md_content": [
        "**Memory_inject_commands**: The function of Memory_inject_commands is to process a list of commands and update the memory based on the information extracted from each command. It iterates over the commands, performs various checks and operations, and calls other functions to handle specific cases.\n\n**parameters**:\n- RET_DICT: A dictionary that stores the merged contents.\n- inp: A string representing the input data.\n- buf: A list that stores the buffer items.\n- currentTime: An integer representing the current time.\n- memory: A dictionary that stores the memory items.\n- atoms: A dictionary containing the existing atoms and their embeddings.\n- cmd: A list of strings representing the commands to be processed.\n- userQuestion: A boolean indicating whether the commands are user questions.\n- userGoal: A boolean indicating whether the commands are user goals.\n- PrintAnswer: A boolean indicating whether to print the answers.\n- PrintMemoryUpdates: A boolean indicating whether to print memory updates.\n- PrintTruthValues: A boolean indicating whether to print truth values.\n- QuestionPriming: A boolean indicating whether to prime the memory with questions.\n- TimeHandling: A boolean indicating whether to handle time-related information.\n- ImportGPTKnowledge: A boolean indicating whether GPT knowledge should be imported.\n- atomCreationThreshold: The threshold value for creating a new atom.\n\n**Code Description**:\nThe Memory_inject_commands function takes a list of commands and processes each command one by one. It starts by initializing a set called AlreadyExecuted to keep track of the commands that have already been executed.\n\nNext, it iterates over the commands using a for loop. For each command, it performs several checks and operations. If the length of the command is less than 3, it skips the current iteration. If the command starts with a dot (\".\") followed by a space, it removes the dot and space from the command. If the command contains a \"#\" character, it removes everything after the \"#\" character. If the command is already in the AlreadyExecuted set or contains certain keywords (\"hasproperty none\", \"isa none\", \"none hasproperty\", \"none isa\"), it skips the current iteration.\n\nIf the command passes all the checks, it adds the command to the AlreadyExecuted set. It then checks if the command is a system question or a user question based on its prefix. If PrintAnswer is enabled, it prints the command.\n\nThe function also checks if the command is a negated relation claim or negated property claim. If it is, it sets the isNegated flag to True, removes the prefix, and updates the truth value accordingly.\n\nNext, the function checks if the command is a relation claim or property claim. If it is, it removes the prefix.\n\nThe function then checks if the command is an input command (relation claim or property claim) and if it contains a closing parenthesis. If both conditions are met, it extracts the sentence from the command, removes any quotes or periods, and converts it to lowercase. It then calls the Memory_digest_sentence function to process the sentence and update the memory. The function also checks if the sentence was successfully processed and, if PrintAnswer is enabled, prints the processed sentence.\n\nAfter processing all the commands, the function checks if userQuestion is True and QuestionPriming is enabled. If both conditions are met, it calls the Memory_QuestionPriming function to prime the memory with the commands.\n\nFinally, the function returns the current time.\n\n**Note**: \n- The Memory_inject_commands function relies on the Memory_digest_sentence and Memory_QuestionPriming functions to process the commands and update the memory. It is important to ensure that these functions are implemented and accessible within the scope of the Memory_inject_commands function.\n- The Memory_inject_commands function assumes that the AlreadyExecuted set, RET_DICT, inp, buf, currentTime, memory, atoms, cmd, userQuestion, userGoal, PrintAnswer, PrintMemoryUpdates, PrintTruthValues, QuestionPriming, TimeHandling, ImportGPTKnowledge, and atomCreationThreshold parameters are defined and accessible within the scope of the function.\n- The Memory_inject_commands function assumes that the Memory_digest_sentence and Memory_QuestionPriming functions are compatible with the specified input parameters and return the expected results.\n- The Memory_inject_commands function assumes that the RET_DICT, memory, and atoms dictionaries are initialized and accessible within the scope of the function.\n- The Memory_inject_commands function assumes that the PrintAnswer, PrintMemoryUpdates, PrintTruthValues, QuestionPriming, TimeHandling, and ImportGPTKnowledge flags are boolean values indicating whether to perform the corresponding actions.\n- The Memory_inject_commands function assumes that the atomCreationThreshold parameter is a threshold value for creating a new atom.\n\n**Output Example**: If the commands are successfully processed and the PrintAnswer flag is enabled, the Memory_inject_commands function will print the processed sentences.\n"
      ],
      "code_start_line": 415,
      "code_end_line": 449,
      "parent": null,
      "params": [
        "RET_DICT",
        "inp",
        "buf",
        "currentTime",
        "memory",
        "atoms",
        "cmd",
        "userQuestion",
        "userGoal",
        "PrintAnswer",
        "PrintMemoryUpdates",
        "PrintTruthValues",
        "QuestionPriming",
        "TimeHandling",
        "ImportGPTKnowledge",
        "atomCreationThreshold"
      ],
      "have_return": true,
      "code_content": "def Memory_inject_commands(RET_DICT, inp, buf, currentTime, memory, atoms, cmd, userQuestion, userGoal, PrintAnswer, PrintMemoryUpdates, PrintTruthValues, QuestionPriming, TimeHandling, ImportGPTKnowledge, atomCreationThreshold):\n    AlreadyExecuted = set([])\n    for x in cmd:\n        if len(x) < 3:\n            continue\n        if x[1] == \".\" and x[2] == \" \": #1. Deduce( (it often outputs in a list like that)\n            x = \" \".join(x.split(\" \")[1:])\n        if \"#\" in x:\n            x = x.split(\"#\")[0].strip()\n        if x in AlreadyExecuted or \"hasproperty none\" in x.lower() or \"isa none\" in x.lower() \\\n                                or \"none hasproperty\" in x.lower() or \"none isa\" in x.lower(): #avoids some none calls\n            continue\n        AlreadyExecuted.add(x)\n        truth = (1.0, 0.9)\n        systemQuestion = x.startswith(\"Question(\")\n        if userQuestion or systemQuestion:\n            if PrintAnswer:\n                print(x)\n        isNegated = False\n        if x.startswith(\"NegatedRelationClaim\") or x.startswith(\"NegatedPropertyClaim\"):\n            isNegated = True\n            x = x[7:].replace(\"  \", \" \") #.replace('\"', \"\").replace(\"'\", \"\")\n            truth = (0.0, 0.9)\n        if x.startswith(\"RelationClaim\") or x.startswith(\"PropertyClaim\"):\n            x = x.replace(\"  \", \" \") #.replace('\"', \"\").replace(\"'\", \"\")\n        isInput = x.startswith(\"RelationClaim(\") or x.startswith(\"PropertyClaim(\")\n        if isInput and \")\" in x:\n            sentence = x.split(\"(\")[1].split(\")\")[0].replace('\"','').replace(\"'\",\"\").replace(\".\", \"\").lower()\n            digested, currentTime, retsentence = Memory_digest_sentence(RET_DICT, inp, currentTime, memory, atoms, sentence, truth, userGoal, PrintMemoryUpdates, TimeHandling, ImportGPTKnowledge, atomCreationThreshold) #currentTime updated\n            if digested and PrintAnswer:\n                printsentence = retsentence if isInput else x\n                print(printsentence)\n    if userQuestion and QuestionPriming:\n        Memory_QuestionPriming(RET_DICT, currentTime, \"\\n\".join(cmd), memory, buf)\n    return currentTime\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "NarsGPT.py/PromptProcess"
      ],
      "reference_who": [
        "Memory.py/Memory_digest_sentence",
        "Memory.py/Memory_QuestionPriming"
      ]
    }
  },
  "NarsGPT.py": {
    "I_You_Exchange": {
      "type": "FunctionDef",
      "name": "I_You_Exchange",
      "md_content": [
        "**I_You_Exchange**: The function of I_You_Exchange is to perform a simple exchange of pronouns between the user and the AI assistant in a given answer.\n\n**parameters**:\n- answer: A string representing the answer to be processed.\n\n**Code Description**:\nThe `I_You_Exchange` function takes an answer as input and performs a series of string replacements to exchange pronouns between the user and the AI assistant. The function first checks if the `IYouExchange` flag is set to True. If not, it simply returns the original answer without any modifications.\n\nNext, the function replaces any occurrences of double quotes (`\"`) with a space followed by a double quote and a space. This is done to ensure proper spacing around the quotes.\n\nThe function then checks if the answer contains any instances of the words \"you\", \"your\", \"You\", or \"Your\". If any of these words are found, the function replaces specific phrases such as \"you are\" or \"you\" with their corresponding pronouns \"I am\" or \"I\". This is done to change the perspective from the user to the AI assistant.\n\nIf none of the above conditions are met, the function assumes that the answer contains the user's perspective and performs the reverse replacement. It replaces phrases such as \"I am\" or \"I\" with \"you are\" or \"you\".\n\nFinally, the function removes any leading or trailing spaces and performs additional replacements to fix any spacing issues around quotes and question marks.\n\nThe modified answer is then returned as the output of the function.\n\n**Note**: It is important to note that the `I_You_Exchange` function relies on the presence of the `IYouExchange` flag to determine whether to perform the pronoun exchange. The value of this flag should be set appropriately before calling this function.\n\n**Output Example**: \n- Input: \"You are my friend.\"\n- Output: \"I am your friend.\"\n\n- Input: \"I love coding.\"\n- Output: \"You love coding.\""
      ],
      "code_start_line": 63,
      "code_end_line": 71,
      "parent": null,
      "params": [
        "answer"
      ],
      "have_return": true,
      "code_content": "def I_You_Exchange(answer):\n    if not IYouExchange:\n        return answer\n    answer = (\" \" + answer + \" \").replace(\"\\\"\", \" \\\" \").replace(\"?\", \" ?\")\n    if \" you \" in answer or \" your \" in answer or \" You \" in answer or \" Your \" in answer:\n        answer = answer.replace(\" you are \", \" I am \").replace(\" You are \", \" I am \").replace(\" you \", \" I \").replace(\" You \", \" I \").strip() #replace you/your with i/my\n    else:\n        answer = answer.replace(\" i am \", \" you are \").replace(\" I am \", \" you are \").replace(\" i \", \" you \").replace(\" I \", \" you \").strip() #replace i/my with you/your\n    return answer.replace(\"  \\\" \", \" \\\"\").replace(\" \\\"  \", \"\\\" \").replace(\" ?\", \"?\")\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "Demo1_LearnAboutUser.py/RaiseQuestion",
        "NarsGPT.py/PromptProcess"
      ],
      "reference_who": []
    },
    "PromptProcess": {
      "type": "FunctionDef",
      "name": "PromptProcess",
      "md_content": [
        "**PromptProcess**: The function of PromptProcess is to process a prompt, generate a response using the OpenAI ChatCompletion API, and update the RET_DICT dictionary with the generated response.\n\n**parameters**:\n- RET_DICT: A dictionary that stores the merged contents.\n- inp: A string representing the input data.\n- buf: A list that stores the buffer items.\n- send_prompt: A string representing the prompt to be sent to the OpenAI ChatCompletion API.\n- isQuestion: A boolean indicating whether the input is a question.\n- isGoal: A boolean indicating whether the input is a goal. (default: False)\n- PrintAnswer: A boolean indicating whether to print the generated answer. (default: False)\n\n**Code Description**:\nThe PromptProcess function starts by printing the start and end of the prompt if the PrintGPTPrompt flag is enabled. It then enters a while loop to handle potential API call failures. Inside the loop, it makes an API call to the OpenAI ChatCompletion API using the provided send_prompt and retrieves the response. The response is then split into individual commands using the newline character as the delimiter.\n\nIf an exception occurs during the API call, an error message is printed, and the function waits for 10 seconds before retrying the API call. Once a successful API call is made, the loop is exited.\n\nIf the isQuestion flag is True, the commands are processed using the I_You_Exchange function, which performs a simple exchange of pronouns between the user and the AI assistant. The processed commands are then split into individual lines.\n\nThe function then calls the Memory_inject_commands function to process the commands and update the memory. The current time is returned by the Memory_inject_commands function and stored in the curTime variable.\n\nThe generated commands are joined into a single string and stored in the RET_DICT dictionary with the key \"GPT_Answer\".\n\nFinally, the function returns the current time.\n\n**Note**: \n- The PromptProcess function relies on the I_You_Exchange and Memory_inject_commands functions to process the commands and update the memory. It is important to ensure that these functions are implemented and accessible within the scope of the PromptProcess function.\n- The PromptProcess function assumes that the RET_DICT, inp, buf, send_prompt, isQuestion, isGoal, and PrintAnswer parameters are defined and accessible within the scope of the function.\n- The PromptProcess function assumes that the PrintGPTPrompt flag is a boolean value indicating whether to print the start and end of the prompt.\n- The PromptProcess function assumes that the usedModel parameter is defined and contains the model to be used for the OpenAI ChatCompletion API call.\n- The PromptProcess function assumes that the openai.ChatCompletion.create function is compatible with the specified input parameters and returns the expected results.\n- The PromptProcess function assumes that the I_You_Exchange function is compatible with the specified input parameter and returns the processed commands.\n- The PromptProcess function assumes that the Memory_inject_commands function is compatible with the specified input parameters and returns the current time.\n- The PromptProcess function assumes that the RET_DICT dictionary is initialized and accessible within the scope of the function.\n\n**Output Example**: The generated commands are stored in the RET_DICT dictionary with the key \"GPT_Answer\"."
      ],
      "code_start_line": 73,
      "code_end_line": 88,
      "parent": null,
      "params": [
        "RET_DICT",
        "inp",
        "buf",
        "send_prompt",
        "isQuestion",
        "isGoal",
        "PrintAnswer"
      ],
      "have_return": true,
      "code_content": "def PromptProcess(RET_DICT, inp, buf, send_prompt, isQuestion, isGoal=False, PrintAnswer=False):\n    if PrintGPTPrompt: print(\"vvvvSTART PROMPT\", send_prompt, \"\\n^^^^END PROMPT\")\n    while True:\n        try:\n            response = openai.ChatCompletion.create(model=usedModel, messages=[ {\"role\": \"user\", \"content\": send_prompt}], max_tokens=200, temperature=0)\n            commands = response['choices'][0]['message']['content'].split(\"\\n\")\n        except Exception as e:\n            print(\"Error: API call failed, will try repeating it in 10 seconds!\", str(e))\n            time.sleep(10) #wait 10 seconds\n            continue\n        break\n    if isQuestion:\n        commands = I_You_Exchange(\"\\n\".join(commands)).split(\"\\n\")\n    curTime = Memory_inject_commands(RET_DICT, inp, buf, currentTime, memory, atoms, commands, isQuestion, isGoal, PrintAnswer, PrintMemoryUpdates, PrintTruthValues, QuestionPriming, TimeHandling, ImportGPTKnowledge, atomCreationThreshold)\n    RET_DICT[\"GPT_Answer\"] = \"\\n\".join(commands)\n    return curTime\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "NarsGPT.py/AddInput"
      ],
      "reference_who": [
        "Memory.py/Memory_inject_commands",
        "NarsGPT.py/I_You_Exchange"
      ]
    },
    "ground": {
      "type": "FunctionDef",
      "name": "ground",
      "md_content": [
        "**ground**: The function of ground is to process a Narsese statement and perform grounding operations on it.\n\n**parameters**:\n- narsese: A string representing the Narsese statement to be grounded.\n\n**Code Description**:\nThe `ground` function takes a Narsese statement as input and performs grounding operations on it. The function first checks if the statement ends with \". :|:\". If it does, it removes the \". :|:\" substring from the statement.\n\nNext, the function checks if the statement ends with \".\", \"!\", or \"?\". If it does, it removes the last character from the statement.\n\nThe function then converts the grounded Narsese statement into a sentence by calling the `Term_AsSentence` function with the grounded Narsese statement as the input. The resulting sentence is stored in the `sentence` variable.\n\nIf the `DebugGrounding` flag is set to True, the function prints the grounded Narsese statement and the corresponding sentence.\n\nThe function then retrieves the embedding for the sentence by calling the `get_embedding_robust` function. The embedding is stored in the `embedding` variable.\n\nFinally, the function appends a tuple containing the sentence and its embedding to the `groundings` list.\n\n**Note**: \n- The `Term_AsSentence` and `get_embedding_robust` functions are assumed to be implemented and available for this function to work correctly.\n- The `DebugGrounding` flag can be used to enable or disable the printing of debug information during the grounding process.\n\n**Output Example**:\nThe function does not return any value. Instead, it appends the grounded sentence and its embedding to the `groundings` list.\n\nRaw code:\n```python\ndef ground(narsese):\n    if narsese.endswith(\". :|:\"):\n        narsese.replace(\". :|:\", \"\")\n    if narsese.endswith(\".\") or narsese.endswith(\"!\") or narsese.endswith(\"?\"):\n        narsese = narsese[:-1]\n    sentence = Term_AsSentence(narsese)\n    if DebugGrounding:\n        print(\"//Grounded:\", narsese,\" <= \", sentence)\n    embedding = get_embedding_robust(sentence)\n    groundings.append((sentence, embedding))\n```\n\nThe `ground` function is called in the following situations:\n- In the `AddInput` function, when the input starts with \"*ground=\". The Narsese statement to be grounded is extracted from the input and passed as an argument to the `ground` function.\n- In the context of the project, the `ground` function can be called to perform grounding operations on Narsese statements and generate grounded sentences for further processing.\n\nPlease note that the `AddInput` function is responsible for processing user inputs and executing the appropriate actions based on the input. It is a central function in the project and serves as the entry point for user interactions."
      ],
      "code_start_line": 91,
      "code_end_line": 100,
      "parent": null,
      "params": [
        "narsese"
      ],
      "have_return": false,
      "code_content": "def ground(narsese):\n    if narsese.endswith(\". :|:\"):\n        narsese.replace(\". :|:\", \"\")\n    if narsese.endswith(\".\") or narsese.endswith(\"!\") or narsese.endswith(\"?\"):\n        narsese = narsese[:-1]\n    sentence = Term_AsSentence(narsese)\n    if DebugGrounding:\n        print(\"//Grounded:\", narsese,\" <= \", sentence)\n    embedding = get_embedding_robust(sentence)\n    groundings.append((sentence, embedding))\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "NarsGPT.py/AddInput"
      ],
      "reference_who": [
        "Memory.py/get_embedding_robust",
        "Memory.py/Term_AsSentence"
      ]
    },
    "AddInput": {
      "type": "FunctionDef",
      "name": "AddInput",
      "md_content": [
        "**AddInput**: The AddInput function is responsible for processing the user's input and performing various operations based on the content of the input.\n\n**parameters**:\n- inp: A string representing the input provided by the user.\n- PrintAnswer: A boolean flag indicating whether to print the answer.\n- Print: A boolean flag indicating whether to print the input sentence.\n- PrintInputSentenceOverride: A boolean flag indicating whether to override the default behavior of printing the input sentence.\n- PrintInputSentenceOverrideValue: A boolean value specifying the override value for printing the input sentence.\n\n**Code Description**:\nThe AddInput function is a central function in the project that processes the user's input and performs various operations based on the content of the input. \n\nThe function takes several parameters, including the user's input (inp) and several flags that control the printing behavior during the execution of the NAR.AddInput function.\n\nThe function first checks if the input string meets certain conditions. If the input string does not end with a question mark, does not start with an asterisk, and the UseLastQuestionInContext flag is set to True, the function appends the last question asked by the user to the input string.\n\nNext, the function calls the NAR.AddInput function with the input string and the specified parameters. The NAR.AddInput function processes the input and returns a dictionary containing the results.\n\nIf the input string ends with a question mark, the function prints the GPT_Answer from the return value of the NAR.AddInput function.\n\nThe function also handles various special cases based on the content of the input string. For example, if the input string starts with \"//\", it returns an empty dictionary. If the input string starts with \"*volume=\", it returns an empty dictionary. If the input string starts with \"*prompt\", it generates and prints a prompt based on the current time, memory, and relevant view size. If the input string starts with \"<\" or \"(\", or contains \" :|:\", it performs additional operations related to Narsese encoding. If the QuestionPriming flag is set to True and the input string ends with a question mark, it queries the NAR system with the input string. If the AutoGroundNarsese flag is set to True, it performs grounding on the input string. It then processes the input string using the ProcessInput function and updates the current time.\n\nIf none of the special cases are met, the input string is converted to lowercase. If the input string ends with a question mark, it generates a prompt based on the current time, memory, relevant view size, and the input string. It then calls the PromptProcess function with the generated prompt and input string, and updates the current time. If the input string does not end with a question mark, it calls the ProcessInput function with the input string and updates the current time.\n\nFinally, the function eternalizes the memory based on the current time and eternalization distance, and stores the memory and atoms in a file.\n\n**Note**: \n- The AddInput function is a key function in the project that processes the user's input and performs various operations based on the content of the input.\n- The function handles special cases such as printing the memory, performing grounding, resetting the system, and generating prompts.\n- The function calls the NAR.AddInput function to process the input string and obtain the result.\n- The function updates the current time and stores the memory and atoms in a file.\n\n**Output Example**: \n- If the input string ends with a question mark, the function will print the GPT_Answer from the return value of the NAR.AddInput function.\n- If the input string starts with \"//\" or \"*volume=\", the function will return an empty dictionary.\n- If the input string starts with \"*prompt\", the function will generate and print a prompt based on the current time, memory, and relevant view size.\n- If the input string starts with \"<\" or \"(\", or contains \" :|:\", the function will perform additional operations related to Narsese encoding.\n- If the input string ends with a question mark and the QuestionPriming flag is set to True, the function will query the NAR system with the input string.\n- If the AutoGroundNarsese flag is set to True, the function will perform grounding on the input string.\n- If none of the special cases are met, the function will process the input string using the ProcessInput function and update the current time.\n- The function will eternalize the memory based on the current time and eternalization distance, and store the memory and atoms in a file."
      ],
      "code_start_line": 103,
      "code_end_line": 224,
      "parent": null,
      "params": [
        "inp",
        "PrintAnswer",
        "Print",
        "PrintInputSentenceOverride",
        "PrintInputSentenceOverrideValue"
      ],
      "have_return": true,
      "code_content": "def AddInput(inp, PrintAnswer=True, Print=True, PrintInputSentenceOverride=True, PrintInputSentenceOverrideValue=False):\n    global currentTime, lastGoal, memory, atoms, PrintInputSentence, atomCreationThreshold\n    SetPrint(Print)\n    if PrintInputSentenceOverride:\n        PrintInputSentence = PrintInputSentenceOverrideValue\n    RET_DICT = {\"GPT_Answer\" : \"\"}\n    if inp == \"*step\" and lastGoal != \"\":\n        inp = lastGoal\n    if PrintInputSentence: print(\"Input:\", inp)\n    if inp.startswith(\"//\"):\n        return RET_DICT\n    if inp.startswith(\"*volume=\"): #TODO\n        return RET_DICT\n    if inp.startswith(\"*prompt\"):\n        if inp.endswith(\"?\"):\n            print(Memory_generate_prompt(currentTime, memory, \"\",\"\", relevantViewSize, recentViewSize, inp[:-1].split(\"*prompt=\")[1])[1])\n        else:\n            print(Memory_generate_prompt(currentTime, memory, \"\",\"\", relevantViewSize, recentViewSize)[1])\n        return RET_DICT\n    if NarseseByONA and (inp.startswith(\"<\") or inp.startswith(\"(\") or \" :|:\" in inp):\n        if (\" --> \" in inp or \" <-> \" in inp) and \" ==> \" not in inp and \" <=> \" not in inp and \" =/> \" not in inp and \" && \" not in inp:\n            S, P = inp.split(\" --> \") if \" --> \" in inp else inp.split(\" <-> \")\n            for word in [S, P]:\n                terms = [x for x in ''.join(i for i in word if i in string.ascii_letters+'0123456789 ').split(' ') if x != \"\"]\n                pos = \"NOUN\"\n                if word == P and \" * \" in S:\n                    pos = \"VERB\"\n                if word == P and \"[\" in P and \"]\" in P:\n                    pos == \"ADJ\"\n                for term in terms:\n                    Atomize(term, atoms, pos, 1.0) #1.0 = always create new atom (Narsese encoding is a reference!)\n        if QuestionPriming:\n            if inp.endswith(\"?\"): #query first\n                query(RET_DICT, currentTime, memory, inp[:-1].strip(), \"eternal\")\n        if AutoGroundNarsese:\n            ground(inp)\n        ret, currentTime = ProcessInput(RET_DICT, currentTime, memory, inp)\n        if \"answers\" in ret and ret[\"answers\"]:\n            answer = ret[\"answers\"][0]\n            if Print == False:\n                if \"truth\" not in answer:\n                    print(\"Answer: None.\")\n                else:\n                    occurrenceTimeInfo = \"\" if answer[\"occurrenceTime\"] == \"eternal\" else \" t=\"+answer[\"occurrenceTime\"]\n                    print(\"Answer: \" + answer[\"term\"] + answer[\"punctuation\"] + \" {\" + str(answer[\"truth\"][\"frequency\"]) + \" \" + str(answer[\"truth\"][\"confidence\"]) + \"}\" + occurrenceTimeInfo)\n        if not inp.endswith(\"?\"):\n            Memory_Eternalize(currentTime, memory, eternalizationDistance)\n            Memory_store(filename, memory, atoms, currentTime)\n        return RET_DICT\n    if inp.startswith(\"*memory\"):\n        for x in memory.items():\n            print(x[0], x[1][:-1])\n        return RET_DICT\n    if inp.startswith(\"*ground=\"):\n        narsese = inp.split(\"ground=\")[1]\n        ground(narsese)\n        return RET_DICT\n    if inp.startswith(\"*time\"):\n        print(currentTime)\n        return RET_DICT\n    if inp.startswith(\"*reset\"):\n        memory = {}\n        atoms = {}\n        currentTime = 1\n        maxBaseId = 1\n        NAR.AddInput(\"*reset\")\n        return RET_DICT\n    if inp.startswith(\"*buffer\"):\n        if inp.endswith(\"?\"):\n            memory_view = Memory_generate_prompt(currentTime, memory, \"\",\"\", relevantViewSize, recentViewSize, inp[:-1].split(\"*buffer=\")[1])[0]\n            for x in memory_view:\n                print(x[0], x[1][:-1])\n        else:\n            memory_view = Memory_generate_prompt(currentTime, memory, \"\",\"\", relevantViewSize, recentViewSize)[0]\n            for x in memory_view:\n                print(x[0], x[1][:-1])\n        return RET_DICT\n    if inp.startswith(\"*concurrent\"):\n        NAR.AddInput(inp)\n        currentTime -= 1\n        return RET_DICT\n    if inp.startswith(\"*\"):\n        NAR.AddInput(inp)\n        return RET_DICT\n    inp = inp.lower()\n    if inp.endswith(\"?\"):\n        buf, text = Memory_generate_prompt(currentTime, memory, Prompts_question_start, \"\\nThe question: \", relevantViewSize, recentViewSize, inp)\n        send_prompt = text + inp[:-1] + (Prompts_question_end_alternative if ConsiderGPTKnowledge else Prompts_question_end)\n        currentTime = PromptProcess(RET_DICT, inp, buf, send_prompt, True, PrintAnswer=PrintAnswer)\n    else:\n        if len(inp) > 0 and not inp.isdigit():\n            buf, text = Memory_generate_prompt(currentTime, memory, Prompts_belief_start, \"\\nThe sentence: \", relevantViewSize, recentViewSize)\n            isGoal = inp.endswith(\"!\")\n            if isGoal:\n                lastGoal = inp\n            else:\n                lastGoal = \"\"\n            restore_atomCreationThreshold = atomCreationThreshold\n            if (isGoal and GoalRequiresGrounding) or (not isGoal and BeliefRequiresGrounding):\n                inp_embedding = get_embedding_robust(inp)\n                bestQual = 0.0\n                bestsentence = \"\"\n                for (sentence, embedding) in groundings:\n                    matchQuality = cosine_similarity(inp_embedding, embedding)\n                    if matchQuality > bestQual:\n                        bestsentence = sentence\n                        bestQual = matchQuality\n                if bestsentence == \"\":\n                    print(\"//Sentence isn't grounded, rejected\")\n                    return RET_DICT\n                inp = bestsentence\n                if DebugGrounding:\n                    print(\"//Reinterpreted as grounded sentence:\", inp)\n            if isGoal:\n                atomCreationThreshold = -0.01 #for goals we do not allow creation of new atoms!\n            currentTime = PromptProcess(RET_DICT, inp, buf, text + inp + Prompts_belief_end, False, isGoal, PrintAnswer=PrintAnswer)\n            atomCreationThreshold = restore_atomCreationThreshold\n        else:\n            _, currentTime = ProcessInput(RET_DICT, currentTime, memory, \"1\" if len(inp) == 0 else inp)\n        Memory_Eternalize(currentTime, memory, eternalizationDistance)\n        Memory_store(filename, memory, atoms, currentTime)\n    return RET_DICT\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "Demo1_LearnAboutUser.py/AddInput",
        "Demo1_LearnAboutUser.py/RaiseQuestion",
        "Demo2_BringCommands.py/parseOutput",
        "Demo2_BringCommands.py/AddInput",
        "Evaluation_INT_inf\\1_GenerateTestOutput.py",
        "Evaluation_babI_qa16\\1_GenerateTestOutput.py",
        "NarsGPT.py/Shell",
        "Unified_ONA_Interface_Example.py"
      ],
      "reference_who": [
        "Memory.py/SetPrint",
        "Memory.py/get_embedding_robust",
        "Memory.py/Memory_generate_prompt",
        "Memory.py/Atomize",
        "Memory.py/query",
        "Memory.py/ProcessInput",
        "Memory.py/Memory_store",
        "Memory.py/Memory_Eternalize",
        "NarsGPT.py/PromptProcess",
        "NarsGPT.py/ground"
      ]
    },
    "getNAR": {
      "type": "FunctionDef",
      "name": "getNAR",
      "md_content": [
        "**getNAR**: The function of getNAR is to retrieve the NAR object.\n\n**parameters**:\n- This function does not take any parameters.\n\n**Code Description**:\nThe `getNAR` function is a simple wrapper function that calls the `getNAR` function of the `NAR` object and returns its result. The `NAR` object is assumed to be defined elsewhere in the codebase.\n\nThis function is used to obtain an instance of the `NAR` object, which is necessary for performing various operations related to the NAR system. By calling this function, the current instance of the `NAR` object is retrieved and returned.\n\nThe `getNAR` function is called by the `terminateNAR` function in the `NarsGPT.py` module. In the `terminateNAR` function, if the `proc` parameter is not provided, the `getNAR` function is called to obtain the current instance of the `NAR` object. This instance is then passed to the `terminateNAR` function of the `NAR` object to terminate the NAR system.\n\n**Note**:\n- It is assumed that the `NAR` object is defined and accessible in the codebase.\n- The `getNAR` function does not take any parameters.\n- The `getNAR` function is a simple wrapper function that calls the `getNAR` function of the `NAR` object and returns its result.\n\n**Output Example**:\n```\n<NAR object at 0x12345678>\n```"
      ],
      "code_start_line": 226,
      "code_end_line": 227,
      "parent": null,
      "params": [],
      "have_return": true,
      "code_content": "def getNAR():\n    return NAR.getNAR()\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "NarsGPT.py/terminateNAR"
      ],
      "reference_who": []
    },
    "setNAR": {
      "type": "FunctionDef",
      "name": "setNAR",
      "md_content": [
        "**setNAR**: The function of setNAR is to set the NAR (Non-Axiomatic Reasoning) process for the NarsGPT model.\n\n**parameters**:\n- proc: The NAR process to be set for the NarsGPT model.\n\n**Code Description**: The setNAR function is a wrapper function that sets the NAR process for the NarsGPT model. It calls the setNAR function from the NAR module, passing the proc parameter as an argument.\n\nThe NAR module is responsible for implementing the Non-Axiomatic Reasoning process, which is a cognitive architecture used for reasoning and learning. By setting the NAR process, the NarsGPT model can utilize the NAR capabilities to enhance its reasoning and learning abilities.\n\n**Note**: Before calling the setNAR function, make sure that the NAR module is properly imported and available in the current environment. Additionally, ensure that the proc parameter is a valid NAR process object that can be used by the NarsGPT model."
      ],
      "code_start_line": 229,
      "code_end_line": 230,
      "parent": null,
      "params": [
        "proc"
      ],
      "have_return": false,
      "code_content": "def setNAR(proc):\n    NAR.setNAR(proc)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "terminateNAR": {
      "type": "FunctionDef",
      "name": "terminateNAR",
      "md_content": [
        "**terminateNAR**: The function of terminateNAR is to terminate the NAR system.\n\n**parameters**:\n- proc: An optional parameter that represents the NAR process. If not provided, the function will retrieve the current instance of the NAR object using the getNAR function.\n\n**Code Description**:\nThe `terminateNAR` function is responsible for terminating the NAR system. It first checks if the `proc` parameter is provided. If not, it calls the `getNAR` function to retrieve the current instance of the NAR object. This instance is then passed to the `terminateNAR` function of the NAR object to terminate the NAR system.\n\nThe `getNAR` function is a simple wrapper function that calls the `getNAR` function of the NAR object and returns its result. It is assumed that the NAR object is defined and accessible in the codebase. The `getNAR` function does not take any parameters.\n\nBy calling the `terminateNAR` function, the NAR system is gracefully terminated, ensuring that all processes and resources associated with it are properly cleaned up.\n\n**Note**:\n- If the `proc` parameter is provided, it should be an instance of the NAR object.\n- If the `proc` parameter is not provided, the `getNAR` function is called to obtain the current instance of the NAR object.\n- The `getNAR` function is a simple wrapper function that calls the `getNAR` function of the NAR object and returns its result.\n- It is assumed that the NAR object is defined and accessible in the codebase.\n- The `terminateNAR` function is called to gracefully terminate the NAR system, ensuring proper cleanup of processes and resources."
      ],
      "code_start_line": 232,
      "code_end_line": 235,
      "parent": null,
      "params": [
        "proc"
      ],
      "have_return": false,
      "code_content": "def terminateNAR(proc=None):\n    if proc is None:\n        proc = getNAR()\n    NAR.terminateNAR(proc)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "NarsGPT.py/getNAR"
      ]
    },
    "spawnNAR": {
      "type": "FunctionDef",
      "name": "spawnNAR",
      "md_content": [
        "**spawnNAR**: The function of spawnNAR is to spawn a new instance of the NAR object.\n\n**parameters**:\n- This function does not take any parameters.\n\n**Code Description**:\nThe `spawnNAR` function is a wrapper function that calls the `spawnNAR` function of the `NAR` object. It is responsible for creating a new instance of the `NAR` object.\n\nThe `spawnNAR` function is likely defined in another module or class called `NAR`. By calling this function, a new instance of the `NAR` object is created, which can be used to perform various operations and access its properties and methods.\n\nIt is important to note that without the implementation details of the `NAR` object and its `spawnNAR` function, it is not possible to provide further analysis or description of the code.\n\n**Note**:\n- Make sure that the `NAR` object and its `spawnNAR` function are properly implemented and accessible before calling the `spawnNAR` function."
      ],
      "code_start_line": 237,
      "code_end_line": 238,
      "parent": null,
      "params": [],
      "have_return": false,
      "code_content": "def spawnNAR():\n    NAR.spawnNAR()\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "Shell": {
      "type": "FunctionDef",
      "name": "Shell",
      "md_content": [
        "**Shell**: The Shell function is responsible for creating a command-line interface that allows users to interact with the NarsGPT system. It continuously prompts the user for input, processes the input, and performs various operations based on the content of the input.\n\n**parameters**:\n- None\n\n**Code Description**:\nThe Shell function creates an interactive command-line interface for the NarsGPT system. It uses a while loop to continuously prompt the user for input. The input is obtained using the input() function and is then processed.\n\nThe function first tries to read the user's input using the input() function. It removes any trailing newline characters and leading or trailing whitespace from the input string. If an exception occurs during the input reading process, the function exits.\n\nThe processed input string is then passed as a parameter to the AddInput function. The AddInput function is responsible for processing the user's input and performing various operations based on the content of the input. The Shell function calls the AddInput function with the processed input string and several other parameters: PrintAnswer, Print, PrintInputSentenceOverride, and PrintInputSentenceOverrideValue.\n\nAfter calling the AddInput function, the Shell function checks if the processed input string ends with a question mark. If it does, the function prints the GPT_Answer from the return value of the AddInput function.\n\nThe Shell function handles any exceptions that occur during the input reading process and exits the program if an exception occurs. This ensures that the program can be terminated gracefully.\n\n**Note**:\n- The Shell function creates an interactive command-line interface for the NarsGPT system.\n- It continuously prompts the user for input and processes the input using the AddInput function.\n- The function handles exceptions that occur during the input reading process and exits the program if an exception occurs.\n\n**Output Example**:\n- If the processed input string ends with a question mark, the function will print the GPT_Answer from the return value of the AddInput function."
      ],
      "code_start_line": 239,
      "code_end_line": 245,
      "parent": null,
      "params": [],
      "have_return": false,
      "code_content": "def Shell():\n    while True:\n        try:\n            inp = input().rstrip(\"\\n\").strip()\n        except:\n            exit(0)\n        AddInput(inp, PrintAnswer=True, Print=False, PrintInputSentenceOverride=True, PrintInputSentenceOverrideValue=PrintInputSentence)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "NarsGPT.py/AddInput"
      ]
    }
  },
  "Prompts.py": {},
  "Truth.py": {
    "Truth_Expectation": {
      "type": "FunctionDef",
      "name": "Truth_Expectation",
      "md_content": [
        "**Truth_Expectation**: The function of Truth_Expectation is to calculate the truth expectation value based on a given input.\n\n**parameters**:\n- v: A tuple representing the input values for the calculation. It should contain two elements, where the first element is a float representing a value, and the second element is a float representing a coefficient.\n\n**Code Description**:\nThe Truth_Expectation function takes a tuple as input and performs a mathematical calculation to determine the truth expectation value. The calculation is done by multiplying the second element of the input tuple (v[1]) with the difference between the first element of the input tuple (v[0]) and 0.5, and then adding 0.5 to the result. The final result is returned as the output of the function.\n\nThis function is called in the code of two objects in the project: \"Memory.py/RetrieveQuestionRelatedBeliefs\" and \"Memory.py/query\".\n\nIn the \"Memory.py/RetrieveQuestionRelatedBeliefs\" object, the Truth_Expectation function is used as part of a sorting mechanism. The code sorts a list of items based on two criteria: the match quality of a query and the truth expectation value calculated using the Truth_Expectation function. The items are represented as tuples, where the second element of each tuple is passed as an argument to the Truth_Expectation function. The sorting is done in descending order, with the highest match quality and truth expectation values appearing first.\n\nIn the \"Memory.py/query\" object, the Truth_Expectation function is used to compare truth expectation values of different terms. The code splits a given term into two parts and searches for matching terms in the memory. For each matching term, the truth expectation value is calculated using the Truth_Expectation function. The code then selects the term with the highest truth expectation value as the best term. This comparison is done to determine the most relevant term based on its truth expectation value.\n\n**Note**: \n- The Truth_Expectation function expects the input tuple to have two elements, otherwise it may result in an error.\n- The output of the Truth_Expectation function is a float value representing the calculated truth expectation.\n\n**Output Example**: \nIf the input tuple is (0.6, 0.8), the Truth_Expectation function will return the value 0.68."
      ],
      "code_start_line": 27,
      "code_end_line": 28,
      "parent": null,
      "params": [
        "v"
      ],
      "have_return": true,
      "code_content": "def Truth_Expectation(v):\n    return (v[1] * (v[0] - 0.5) + 0.5)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "Memory.py/RetrieveQuestionRelatedBeliefs",
        "Memory.py/query"
      ],
      "reference_who": []
    },
    "Truth_Projection": {
      "type": "FunctionDef",
      "name": "Truth_Projection",
      "md_content": [
        "**Truth_Projection**: The function of Truth_Projection is to calculate the truth value of a proposition at a target time based on its original truth value and the time difference between the original time and the target time.\n\n**parameters**:\n- v: A tuple representing the original truth value of the proposition, where v[0] is the truth value and v[1] is the confidence level.\n- originalTime: The original time at which the truth value is measured.\n- targetTime: The target time at which the truth value needs to be projected.\n\n**Code Description**:\nThe Truth_Projection function takes in three parameters: v, originalTime, and targetTime. It calculates the projected truth value of a proposition at the target time based on its original truth value and the time difference between the original time and the target time.\n\nThe function first extracts the truth value and confidence level from the input tuple v. It then calculates the time difference between the original time and the target time using the abs() function. The formula used to calculate the projected truth value is v[1] * (0.8 ** abs(targetTime - originalTime)), where v[1] represents the confidence level.\n\nThe function returns a tuple with two elements: the original truth value v[0] and the projected truth value v[1] * (0.8 ** abs(targetTime - originalTime)).\n\nThis function is called within the Memory_generate_prompt function in the Memory.py file. In the Memory_generate_prompt function, the Truth_Projection function is used to calculate the projected truth value of a proposition based on the current time, memory, prompt start and end, relevant view size, recent view size, and input question. The calculated truth value is then used to construct a prompt memory string.\n\n**Note**: \n- The Truth_Projection function assumes that the input tuple v has a length of 2, where v[0] represents the truth value and v[1] represents the confidence level.\n- The time difference between the original time and the target time is calculated using the abs() function to ensure a positive value.\n- The formula used to calculate the projected truth value uses a decay factor of 0.8 raised to the power of the absolute time difference. This decay factor decreases the confidence level of the truth value as the time difference increases.\n- The Memory_generate_prompt function utilizes the Truth_Projection function to calculate the projected truth value of propositions in the memory and construct a prompt memory string.\n- The prompt memory string includes information about the proposition, such as its term, time, and confidence level, as well as the index of the proposition in the memory.\n- If the confidence level of the truth value is less than 0.5, the term is modified to include the phrase \"not\" before the main term.\n- The prompt memory string is constructed by concatenating the information of each proposition in the memory.\n- If the memory is empty, the prompt memory string will be set to \"EMPTY!\".\n\n**Output Example**:\nIf the input tuple v is (0.6, 0.9), the originalTime is 10, and the targetTime is 15, the function will return (0.6, 0.59049)."
      ],
      "code_start_line": 30,
      "code_end_line": 31,
      "parent": null,
      "params": [
        "v",
        "originalTime",
        "targetTime"
      ],
      "have_return": true,
      "code_content": "def Truth_Projection(v, originalTime, targetTime):\n    return (v[0], v[1] * (0.8**abs(targetTime - originalTime)))\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "Memory.py/Memory_generate_prompt"
      ],
      "reference_who": []
    }
  },
  "Unified_ONA_Interface_Example.py": {},
  "Evaluation_babI_qa16\\1_GenerateTestOutput.py": {
    "question_and_expected_output": {
      "type": "FunctionDef",
      "name": "question_and_expected_output",
      "md_content": [
        "**question_and_expected_output**: The function of question_and_expected_output is to split a given string into two parts based on the tab character (\"\\t\") and return them as a list.\n\n**parameters**:\n- questionline: A string representing a line of question and expected output, separated by a tab character (\"\\t\").\n\n**Code Description**:\nThe `question_and_expected_output` function takes a string `questionline` as input. It splits the string into two parts using the `split` method with the tab character (\"\\t\") as the delimiter. The resulting parts are then stored in a list and returned.\n\n**Note**:\n- The input string `questionline` should contain a tab character (\"\\t\") to ensure proper splitting.\n- If the input string does not contain a tab character, the function may raise an IndexError.\n\n**Output Example**:\nIf the input string is \"What is the capital of France?\\tParis\", the function will return the list [\"What is the capital of France?\", \"Paris\"]."
      ],
      "code_start_line": 30,
      "code_end_line": 32,
      "parent": null,
      "params": [
        "questionline"
      ],
      "have_return": true,
      "code_content": "def question_and_expected_output(questionline):\n    splitted = questionline.split(\"\\t\")\n    return [splitted[0], splitted[1]]\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    }
  },
  "Evaluation_babI_qa16\\2_EvaluateTestOutput.py": {},
  "Evaluation_babI_qa16\\test1.py": {},
  "Evaluation_INT_inf\\1_GenerateTestOutput.py": {},
  "Evaluation_INT_inf\\2_EvaluateTestOutput.py": {},
  "Evaluation_INT_inf\\3_CheckDifferencesToLastRun.py": {},
  "OpenNARS-for-Applications\\analysis.py": {},
  "OpenNARS-for-Applications\\colorize.py": {},
  "OpenNARS-for-Applications\\concepts_to_graph.py": {
    "hasImage": {
      "type": "FunctionDef",
      "name": "hasImage",
      "md_content": [
        "**hasImage**: The function of hasImage is to determine whether a given string contains certain image indicators.\n\n**parameters**:\n- line: A string that represents a line of text.\n\n**Code Description**:\nThe hasImage function takes a string as input and checks if it contains any of the following image indicators: \"/1\", \"/2\", \"\\\\1\", or \"\\\\2\". It returns True if any of these indicators are found in the string, and False otherwise.\n\nThis function is used to identify whether a line of text contains image indicators. It is called within the parse_concept function in the OpenNARS-for-Applications\\concepts_to_graph.py module. In the parse_concept function, the hasImage function is used to determine if a line of text contains any image indicators before further processing is performed.\n\n**Note**:\n- The hasImage function only checks for the presence of specific image indicators and does not perform any image-related operations.\n- The function is case-sensitive, so it will only detect the image indicators in the exact specified format.\n\n**Output Example**:\n- Input: \"This is a test /1\"\n  Output: True\n- Input: \"No image indicators here\"\n  Output: False"
      ],
      "code_start_line": 45,
      "code_end_line": 46,
      "parent": null,
      "params": [
        "line"
      ],
      "have_return": true,
      "code_content": "def hasImage(line):\n    return \"/1\" in line or \"/2\" in line or \"\\\\1\" in line or \"\\\\2\" in line \n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\concepts_to_graph.py/parse_concept"
      ],
      "reference_who": []
    },
    "parse_concept": {
      "type": "FunctionDef",
      "name": "parse_concept",
      "md_content": [
        "**parse_concept**: The function of parse_concept is to extract a concept and its corresponding dictionary from a given line of text.\n\n**parameters**:\n- line: A string that represents a line of text.\n\n**Code Description**:\nThe parse_concept function takes a line of text as input and checks if it starts with the string \"//{i=\" and does not have any image indicators (if the NoImages flag is False or if the line does not contain any image indicators). If these conditions are met, the function extracts the concept and its corresponding dictionary from the line of text and returns them as a tuple.\n\nTo extract the concept, the function splits the line of text by spaces, discards the first element (which is \"//{i=\"), and then splits the remaining elements by \":\". The first element of the resulting list is considered as the concept.\n\nTo extract the dictionary, the function uses the ast.literal_eval function to evaluate the string representation of the dictionary. The dictionary is extracted from the line of text by splitting it at the first occurrence of \": {\" and then adding a \"{\" at the beginning of the resulting string.\n\nIf the line of text does not meet the conditions mentioned above, the function returns (None, None) to indicate that no concept and dictionary were found.\n\nThe parse_concept function is called within the OpenNARS-for-Applications\\concepts_to_graph.py module. It is used to parse lines of text and extract concepts and dictionaries for further processing.\n\n**Note**:\n- The parse_concept function assumes that the line of text follows a specific format, starting with \"//{i=\" and containing a concept and its corresponding dictionary.\n- The function relies on the hasImage function to check for the presence of image indicators in the line of text.\n- The function uses the ast.literal_eval function to safely evaluate the string representation of the dictionary.\n- The function returns (None, None) if the line of text does not meet the specified conditions or if no concept and dictionary were found.\n\n**Output Example**:\n- Input: \"//{i=concept_name: {dictionary_key: dictionary_value}}\"\n  Output: (\"concept_name\", {\"dictionary_key\": \"dictionary_value\"})\n- Input: \"//{i=invalid_line}\"\n  Output: (None, None)"
      ],
      "code_start_line": 49,
      "code_end_line": 54,
      "parent": null,
      "params": [
        "line"
      ],
      "have_return": true,
      "code_content": "def parse_concept(line):\n    if line.startswith(\"//{i=\") and (not NoImages or not hasImage(line)):\n        concept = \" \".join(line.split(\" \")[1:]).split(\":\")[0]\n        dictionary = ast.literal_eval(\"{\" + line.split(\": {\")[1])\n        return (concept, dictionary)\n    return (None, None)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "OpenNARS-for-Applications\\concepts_to_graph.py/hasImage"
      ]
    },
    "parse_truth": {
      "type": "FunctionDef",
      "name": "parse_truth",
      "md_content": [
        "**parse_truth**: The function of parse_truth is to extract the truth value from a given line of text.\n\n**parameters**:\n- line: A string representing a line of text containing a truth value in the format \"TV = {x y}\", where x and y are floating-point numbers.\n\n**Code Description**:\nThe parse_truth function takes a line of text as input and extracts the truth value from it. The truth value is expected to be in the format \"TV = {x y}\", where x and y are floating-point numbers representing the belief and disbelief values, respectively.\n\nThe function first splits the line using the \". {\" delimiter to extract the truth value portion. The resulting list will contain two elements: the belief value and the disbelief value, separated by a space. The belief value is located at index 0, and the disbelief value is located at index 1.\n\nThe function then converts the belief and disbelief values from strings to floats using the float() function.\n\nFinally, the function returns a tuple containing the belief and disbelief values.\n\n**Note**:\n- This function assumes that the input line is in the correct format. If the line does not contain a truth value in the expected format, the function may raise an IndexError or produce unexpected results.\n- It is recommended to validate the input line before calling this function to ensure it contains a valid truth value.\n\n**Output Example**:\nIf the input line is \"TV = {0.8 0.2}\", the function will return the tuple (0.8, 0.2)."
      ],
      "code_start_line": 56,
      "code_end_line": 58,
      "parent": null,
      "params": [
        "line"
      ],
      "have_return": true,
      "code_content": "def parse_truth(line):\n    TV = line.split(\". {\")[1].split(\"}\")[0].split(\" \")\n    return (float(TV[0]), float(TV[1]))\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "truth_expectation": {
      "type": "FunctionDef",
      "name": "truth_expectation",
      "md_content": [
        "**truth_expectation**: The function of truth_expectation is to calculate the truth expectation value based on the given truth value.\n\n**parameters**:\n- truth: A tuple representing the truth value, where the first element (f) represents the frequency and the second element (c) represents the confidence.\n\n**Code Description**:\nThe `truth_expectation` function takes a truth value as input and calculates the truth expectation value using the following formula:\n```\n(f,c) = truth\nreturn c * (f - 0.5) + 0.5\n```\nThe function first unpacks the frequency (f) and confidence (c) from the input tuple. It then applies the formula to calculate the truth expectation value. The formula multiplies the confidence by the difference between the frequency and 0.5, and then adds 0.5 to the result.\n\nThis function is called by two other objects in the project: `truth_to_color` and `addImplicationEdge`. \n\nIn the `truth_to_color` function, the `truth_expectation` function is used to calculate the truth expectation value and convert it to a color value. The resulting color value is used to represent the truth value visually.\n\nIn the `addImplicationEdge` function, the `truth_expectation` function is used to compare the truth expectation values of two truth values. If the truth expectation value of the input truth value is greater than the existing truth expectation value, the input truth value overrides the existing one. This comparison is used to determine the strength of implication edges in a graph.\n\n**Note**: \n- The input truth value should be a tuple with two elements representing the frequency and confidence.\n- The output of this function is a single value representing the truth expectation.\n\n**Output Example**:\nIf the input truth value is (0.8, 0.6), the function will return 0.68."
      ],
      "code_start_line": 60,
      "code_end_line": 62,
      "parent": null,
      "params": [
        "truth"
      ],
      "have_return": true,
      "code_content": "def truth_expectation(truth):\n    (f,c) = truth\n    return c * (f - 0.5) + 0.5\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\concepts_to_graph.py/truth_to_color",
        "OpenNARS-for-Applications\\concepts_to_graph.py/addImplicationEdge"
      ],
      "reference_who": []
    },
    "truth_to_color": {
      "type": "FunctionDef",
      "name": "truth_to_color",
      "md_content": [
        "**truth_to_color**: The function of truth_to_color is to convert a truth value into a color representation.\n\n**parameters**:\n- truth: A tuple representing the truth value, where the first element (f) represents the frequency and the second element (c) represents the confidence.\n\n**Code Description**:\nThe `truth_to_color` function takes a truth value as input and converts it into a color representation. It first calls the `truth_expectation` function to calculate the truth expectation value based on the given truth value. The truth expectation value is then used to determine the color value.\n\nThe color value is calculated by multiplying the truth expectation value by 255 and converting it to an integer. This value represents the intensity of the red channel in the RGB color model. The green channel is set to 0, and the blue channel is calculated by subtracting the red channel value from 255. The resulting color value is formatted as a hexadecimal string in the format '#RRGGBB'.\n\nThis function is used in the OpenNARS-for-Applications project to visually represent the truth value in a graph.\n\n**Note**: \n- The input truth value should be a tuple with two elements representing the frequency and confidence.\n- The output of this function is a hexadecimal color string.\n\n**Output Example**:\nIf the input truth value is (0.8, 0.6), the function will return the color '#cc00ff'."
      ],
      "code_start_line": 64,
      "code_end_line": 66,
      "parent": null,
      "params": [
        "truth"
      ],
      "have_return": true,
      "code_content": "def truth_to_color(truth):\n    truthcol = int(255*truth_expectation(truth))\n    return '#%02x%02x%02x' % (truthcol,0, 255 - truthcol)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\concepts_to_graph.py/addImplicationEdges"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\concepts_to_graph.py/truth_expectation"
      ]
    },
    "addImplicationEdge": {
      "type": "FunctionDef",
      "name": "addImplicationEdge",
      "md_content": [
        "**addImplicationEdge**: The function of addImplicationEdge is to add or update an implication edge in a graph based on the given parameters.\n\n**parameters**:\n- a: The first concept in the implication edge.\n- b: The second concept in the implication edge.\n- operator: The operator associated with the implication edge.\n- truth: The truth value associated with the implication edge. It is a list containing two elements: the frequency (f) and the confidence (c).\n\n**Code Description**:\nThe `addImplicationEdge` function takes four parameters: `a`, `b`, `operator`, and `truth`. It first checks if the implication edge already exists in the graph by checking if the tuple `(a, b, UseOp)` is present in the `implicationEdges` dictionary. The variable `UseOp` is set to `True` if the `operator` parameter is not an empty string, indicating that an operator is associated with the implication edge.\n\nIf the implication edge already exists, the function retrieves the existing operator and truth value from the `implicationEdges` dictionary. It then compares the truth expectation value of the input `truth` value with the truth expectation value of the existing truth value using the `truth_expectation` function. If the input truth value has a higher truth expectation value, the `override` variable is set to `True`, indicating that the input truth value should override the existing one.\n\nIf the implication edge does not exist or if the input truth value should override the existing one, the `override` variable is set to `True`. In either case, the function updates the `implicationEdges` dictionary with the input parameters `(a, b, UseOp)` as the key and a tuple containing the `operator` and `truth` values as the value.\n\nThe `addImplicationEdge` function is called within the `concepts_to_graph.py` module of the OpenNARS-for-Applications project. It is responsible for managing the implication edges in the graph representation of concepts.\n\n**Note**:\n- The `operator` parameter can be an empty string if no operator is associated with the implication edge.\n- The `truth` parameter should be a list containing two elements: the frequency (f) and the confidence (c).\n- The `truth_expectation` function is used to compare the truth expectation values of two truth values.\n- The `implicationEdges` dictionary is used to store the implication edges in the graph.\n- The `override` variable is used to determine if the input truth value should override the existing one.\n- The function modifies the `implicationEdges` dictionary to add or update the implication edge."
      ],
      "code_start_line": 69,
      "code_end_line": 79,
      "parent": null,
      "params": [
        "a",
        "b",
        "operator",
        "truth"
      ],
      "have_return": false,
      "code_content": "def addImplicationEdge(a, b, operator, truth=[0, 0]):\n    override = False\n    UseOp = False if operator == \"\" else True\n    if (a,b,UseOp) in implicationEdges:\n        (operator2, truth2) = implicationEdges[(a,b,UseOp)]\n        if truth_expectation(truth) > truth_expectation(truth2):\n            override = True\n    else:\n        override = True\n    if override:\n        implicationEdges[(a,b,UseOp)] = (operator, truth)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "OpenNARS-for-Applications\\concepts_to_graph.py/truth_expectation"
      ]
    },
    "truthstring": {
      "type": "FunctionDef",
      "name": "truthstring",
      "md_content": [
        "**truthstring**: The function of truthstring is to format a given truth value into a string representation.\n\n**parameters**:\n- truth: A tuple representing the truth value, where the first element is the belief value and the second element is the disbelief value.\n\n**Code Description**:\nThe `truthstring` function takes a truth value as input and formats it into a string representation. It uses the `Format` variable, which is set to '{:0,.2f}', to format the belief and disbelief values of the truth value. The belief value is accessed using `truth[0]` and the disbelief value is accessed using `truth[1]`. The formatted string is then returned with the belief and disbelief values enclosed in curly braces and separated by a space.\n\nThe function is called within the `addImplicationEdges` function in the `concepts_to_graph.py` file. In this context, the `truthstring` function is used to format the belief and disbelief values of the truth values for different implication edges. The formatted strings are used to create labels for the edges in a graph representation.\n\n**Note**:\n- The `truth` parameter should be a tuple with two elements representing the belief and disbelief values.\n- The function assumes that the `truth` parameter will always be a valid truth value.\n\n**Output Example**:\nIf the `truth` parameter is (0.75, 0.25), the function will return the string \"{0.75 0.25}\"."
      ],
      "code_start_line": 81,
      "code_end_line": 83,
      "parent": null,
      "params": [
        "truth"
      ],
      "have_return": true,
      "code_content": "def truthstring(truth):\n    Format = '{:0,.2f}'\n    return \"{\" + Format.format(truth[0]) + \" \" + Format.format(truth[1]) + \"}\"\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\concepts_to_graph.py/addImplicationEdges"
      ],
      "reference_who": []
    },
    "addImplicationEdges": {
      "type": "FunctionDef",
      "name": "addImplicationEdges",
      "md_content": [
        "**addImplicationEdges**: The function of addImplicationEdges is to add implication edges to a graph based on certain conditions and parameters.\n\n**parameters**:\n- NoProceduralLinks: A boolean value indicating whether to exclude procedural links.\n- NoTemporalLinks: A boolean value indicating whether to exclude temporal links.\n- Simplified: A boolean value indicating whether to simplify the graph representation.\n- NoLinkLabels: A boolean value indicating whether to exclude link labels.\n\n**Code Description**:\nThe `addImplicationEdges` function iterates over the `implicationEdges` list and adds edges to the graph based on certain conditions and parameters. \n\nThe function first checks if `NoProceduralLinks` is True and `UseOp` is True, or if `NoTemporalLinks` is True and `UseOp` is False. If either of these conditions is met, the function skips the current iteration.\n\nNext, the function checks if `Simplified` is True and `UseOp` is False, and if the edge `(a,b,True)` exists in `implicationEdges`. If both conditions are met, the function skips the current iteration.\n\nIf `UseOp` is True, the function retrieves the operator and truth value from `implicationEdges` for the edge `(a,b,True)`. It also retrieves the truth value for the edge `(a,b,False)` if it exists. The function then calls the `truth_to_color` function to convert the truth value into a color representation.\n\nIf `UseOp` is False, the function retrieves the truth value for the edge `(a,b,False)`. It also retrieves the operator and truth value for the edge `(a,b,True)` if it exists. The function then calls the `truth_to_color` function to convert the truth value into a color representation.\n\nThe function checks if both the truth values for `UseOp` and `not UseOp` have a confidence value greater than 0, and if `NoProceduralLinks` and `NoTemporalLinks` are both False. If these conditions are met, the variable `HaveBoth` is set to True.\n\nThe function constructs the label for the edge based on the conditions and values obtained. If `NoLinkLabels` is True, the label is set to an empty string.\n\nFinally, the function adds the edge to the graph with the appropriate attributes, including the color, weight, label, and arrowsize.\n\nThe `addImplicationEdges` function is used in the OpenNARS-for-Applications project to add implication edges to a graph representation. It takes into account various conditions and parameters to determine the attributes of the edges.\n\n**Note**:\n- The `implicationEdges` variable is assumed to be a dictionary with tuples `(a,b,UseOp)` as keys and values representing the operator and truth values.\n- The `truth_to_color` function is called to convert the truth values into color representations.\n- The `truthstring` function is not directly called in this code, but it is mentioned in the comments as a reference for formatting truth values into strings."
      ],
      "code_start_line": 85,
      "code_end_line": 106,
      "parent": null,
      "params": [],
      "have_return": false,
      "code_content": "def addImplicationEdges():\n    for (a,b,UseOp) in implicationEdges:\n        if NoProceduralLinks and UseOp or NoTemporalLinks and not UseOp:\n            continue\n        if Simplified and not UseOp and (a,b,True) in implicationEdges:\n            continue\n        if UseOp: #complication: since networkx can only draw 1 link label for (a,b), we merge and make sure the op/non op label is the same with truth info of both\n            (operator, optruth) = implicationEdges[(a,b,True)]\n            (_, noptruth) = (\"\", (0.5, 0)) if (a,b,False) not in implicationEdges else implicationEdges[(a,b,False)][:2]\n            color = truth_to_color(optruth)\n        if not UseOp:\n            (_, noptruth) = implicationEdges[(a,b,False)]\n            (operator, optruth) = (\"\", (0.5, 0)) if (a,b,True) not in implicationEdges else implicationEdges[(a,b,True)][:2]\n            color = truth_to_color(noptruth)\n        HaveBoth = optruth[1] > 0 and noptruth[1] > 0 and not NoProceduralLinks and not NoTemporalLinks\n        Top = \"\" if NoProceduralLinks or optruth[1] == 0 else \"with op\" + (\" (inner)\" if HaveBoth and not Simplified else \"\") + \": \" + truthstring(optruth) + \"\\n\"\n        Tnop = \"\" if NoTemporalLinks or noptruth[1] == 0 else \"w/o op\" + (\" (outer)\" if HaveBoth and not Simplified else \"\") + \": \" + truthstring(noptruth)\n        label = (\"best op: \" + operator + \"\\n\" if operator != \"\" else \"\") + Top + (Tnop if (a,b,True) not in implicationEdges else \"\")\n        if NoLinkLabels:\n            label = \"\"\n        max_rad = 0.0\n        G.add_edge(a, b, rad=(0.1 if UseOp or Simplified else 0.2), color=color, weight=4, label=label, arrowsize=20)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "OpenNARS-for-Applications\\concepts_to_graph.py/truth_to_color",
        "OpenNARS-for-Applications\\concepts_to_graph.py/truthstring"
      ]
    },
    "AddTermlink": {
      "type": "FunctionDef",
      "name": "AddTermlink",
      "md_content": [
        "**AddTermlink**: The function of AddTermlink is to add a directed edge between two nodes in a graph.\n\n**parameters**:\n- source: The source node of the edge.\n- target: The target node of the edge.\n\n**Code Description**:\nThe AddTermlink function takes two parameters, source and target, representing the nodes between which the directed edge will be added. The function first checks if both the source and target nodes exist in the graph G and if they are not empty strings. If these conditions are met, the function adds an edge from the source node to the target node with the following properties:\n- color: The color of the edge is set to 'green'.\n- weight: The weight of the edge is set to 1.\n- label: The label of the edge is set to an empty string.\n- arrowsize: The size of the arrow representing the edge is set to 1.\n\nAdditionally, the function adds a corresponding edge from the target node to the source node with the same properties.\n\n**Note**: \n- It is important to ensure that the source and target nodes exist in the graph G before calling the AddTermlink function.\n- The source and target nodes should not be empty strings."
      ],
      "code_start_line": 140,
      "code_end_line": 143,
      "parent": null,
      "params": [
        "source",
        "target"
      ],
      "have_return": false,
      "code_content": "def AddTermlink(source, target):\n    if source in G and target in G and source != \"\" and target != \"\":\n        G.add_edge(source, target, color='green', weight=1, label=\"\", arrowsize=1)\n        G.add_edge(target, source, color='green', weight=1, label=\"\", arrowsize=1)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    }
  },
  "OpenNARS-for-Applications\\concept_net_narsese.py": {
    "toNarsese": {
      "type": "FunctionDef",
      "name": "toNarsese",
      "md_content": [
        "**toNarsese**: The function of toNarsese is to convert a given subject-relation-predicate tuple into a Narsese statement.\n\n**parameters**:\n- subject_relation_predicate: A tuple containing the subject, relation, and predicate.\n\n**Code Description**:\nThe `toNarsese` function takes a subject-relation-predicate tuple as input and converts it into a Narsese statement. It first unpacks the tuple into separate variables for subject, relation, and predicate. \n\nThe function then checks the value of the `relation` parameter. If the relation is \"IsA\", it further checks if the first character of the subject is uppercase. If it is uppercase, it returns a Narsese statement in the form \"<{subject} --> predicate>.\". Otherwise, it returns \"<subject --> predicate>.\".\n\nIf the relation is \"InstanceOf\", it checks if the first character of the subject is lowercase. If it is lowercase, it returns a Narsese statement in the form \"<subject --> predicate>.\". Otherwise, it returns \"<{subject} --> predicate>.\".\n\nIf the relation is \"HasProperty\", it returns a Narsese statement in the form \"<subject --> [predicate]>.\".\n\nIf the relation is \"DistinctFrom\", it returns a Narsese statement in the form \"(--,<subject <-> predicate>).\".\n\nIf the relation is \"SimilarTo\", it returns a Narsese statement in the form \"<subject <-> predicate>.\".\n\nIf the relation is \"Causes\", it returns a Narsese statement in the form \"<subject =/> predicate>.\".\n\nIf none of the above conditions are met, it returns a Narsese statement in the form \"<(subject * predicate) --> relation.replace(\"PartOf\", \"part_of\").replace(\"HasA\", \"have\").replace(\"MadeOf\", \"make_of\").replace(\"Desires\", \"want\").lower()>.\".\n\n**Note**: \n- The function assumes that the subject, relation, and predicate are strings.\n- The function does not perform any input validation or error handling.\n\n**Output Example**:\n- Input: (\"Cat\", \"IsA\", \"Animal\")\n- Output: \"<Cat --> Animal>.\""
      ],
      "code_start_line": 43,
      "code_end_line": 63,
      "parent": null,
      "params": [
        "subject_relation_predicate"
      ],
      "have_return": true,
      "code_content": "def toNarsese(subject_relation_predicate):\n    (subject, relation, predicate) = subject_relation_predicate\n    if relation == \"IsA\":\n        if subject[0].isupper():\n            return \"<{\" + subject + \"} --> \" + predicate + \">.\"\n        else:\n            return \"<\" + subject + \" --> \" + predicate + \">.\"\n    if relation == \"InstanceOf\":\n        if subject[0].islower():\n            return \"<\" + subject + \" --> \" + predicate + \">.\"\n        else:\n            return \"<{\" + subject + \"} --> \" + predicate + \">.\"\n    if relation == \"HasProperty\":\n        return \"<\" + subject + \" --> [\" + predicate + \"]>.\"\n    if relation == \"DistinctFrom\":\n        return \"(--,<\" + subject + \" <-> \" + predicate + \">).\"\n    if relation == \"SimilarTo\":\n        return \"<\" + subject + \" <-> \" + predicate + \">.\"\n    if relation == \"Causes\":\n        return \"<\" + subject + \" =/> \" + predicate + \">.\"\n    return \"<(\" + subject + \" * \" + predicate + \") --> \" + relation.replace(\"PartOf\", \"part_of\").replace(\"HasA\", \"have\").replace(\"MadeOf\", \"make_of\").replace(\"Desires\", \"want\").lower() + \">.\"\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\concept_net_narsese.py/queryConceptNet"
      ],
      "reference_who": []
    },
    "unwrap": {
      "type": "FunctionDef",
      "name": "unwrap",
      "md_content": [
        "**unwrap**: The function of unwrap is to extract specific parts from a given string.\n\n**parameters**:\n- rel: A string representing a relationship.\n\n**Code Description**:\nThe `unwrap` function takes a relationship string as input and extracts specific parts from it. The relationship string is expected to be in a specific format, where the parts are enclosed in square brackets and separated by commas. The function first uses the `split` method to remove the square brackets from the string. Then, it uses the `replace` method to remove specific substrings (\"/c/en/\", \"/n/\", \"/r/\", and \"/\") from the string. Finally, it uses the `split` method again to split the string into individual parts based on the comma separator.\n\nThe function returns a tuple containing the extracted parts in a specific order: the second part, the first part, and the third part.\n\nThis function is called by the `queryConceptNet` function in the `concept_net_narsese.py` module. In the `queryConceptNet` function, the `unwrap` function is used to extract the parts of the relationship string returned by the ConceptNet API. These parts are then used to check if the relationship involves the specified term and to determine the count of the term in the relationship. The extracted parts are also converted to Narsese format using the `toNarsese` function.\n\n**Note**:\n- The `unwrap` function assumes that the relationship string is in the expected format. If the format is different, the function may raise an exception or return unexpected results.\n- The function does not perform any validation or error handling for the extracted parts. It is assumed that the parts will always be present and in the expected order.\n- The function does not handle any special characters or encoding in the relationship string.\n\n**Output Example**:\nIf the input relationship string is \"[/c/en/dog]/r/IsA[/c/en/animal]\", the function will return (\"IsA\", \"dog\", \"animal\")."
      ],
      "code_start_line": 65,
      "code_end_line": 67,
      "parent": null,
      "params": [
        "rel"
      ],
      "have_return": true,
      "code_content": "def unwrap(rel):\n    parts = rel.split(\"[\")[1].split(\"]\")[0].replace(\"/c/en/\", \"\").replace(\"/n/\", \"\").replace(\"/r/\", \"\").replace(\"/\", \"\").split(\",\");\n    return (parts[1], parts[0], parts[2])\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\concept_net_narsese.py/queryConceptNet"
      ],
      "reference_who": []
    },
    "queryConceptNet": {
      "type": "FunctionDef",
      "name": "queryConceptNet",
      "md_content": [
        "**queryConceptNet**: The function of queryConceptNet is to query the ConceptNet API for relationships between a given term and other concepts based on a specified relation.\n\n**parameters**:\n- maxAmount: An integer representing the maximum number of results to retrieve from the ConceptNet API.\n- term: A string representing the term to query.\n- side: A string representing the side of the relationship to query. It can be either \"end\" or \"start\".\n- relation: A string representing the relation to query.\n\n**Code Description**:\nThe `queryConceptNet` function queries the ConceptNet API to retrieve relationships between a given term and other concepts based on a specified relation. It first constructs the API request URL by concatenating the `side`, `/c/en/` + `term`, `/r/` + `relation`, and `limit` parameters. The `limit` parameter is set to the value of `maxAmount`.\n\nThe function then sends a GET request to the constructed URL using the `requests.get` method from the `requests` library. It retrieves the response in JSON format and extracts the `edges` from the response.\n\nNext, the function iterates over each `edge` in the `edges` list. For each `edge`, it calls the `unwrap` function to extract the subject, value, and predicate from the `@id` field of the `edge`. It checks if either the subject or the predicate is equal to the given `term` and if neither the subject nor the predicate contain an underscore character. If these conditions are met, it retrieves the count of the predicate from the `wordcounts` dictionary based on whether the subject is equal to the given `term`. It then appends a tuple containing the Narsese representation of the subject, value, and predicate (obtained by calling the `toNarsese` function) and the count to the `ret` list.\n\nFinally, the function returns the `ret` list, which contains the Narsese representations of the relationships between the given term and other concepts based on the specified relation.\n\n**Note**:\n- The function assumes that the `term`, `side`, and `relation` parameters are strings, and the `maxAmount` parameter is an integer.\n- The function relies on the `requests` library to send HTTP requests and retrieve responses from the ConceptNet API.\n- The function depends on the `unwrap` and `toNarsese` functions to extract specific parts from the API response and convert relationships to Narsese format, respectively.\n- The function does not perform any input validation or error handling.\n\n**Output Example**:\n- Input: `queryConceptNet(5, \"Cat\", \"end\", \"IsA\")`\n- Output: `[(\"<Cat --> Animal>.\", 10), (\"<Cat --> Mammal>.\", 5), (\"<Cat --> Pet>.\", 3), (\"<Cat --> Feline>.\", 2), (\"<Cat --> DomesticAnimal>.\", 1)]`"
      ],
      "code_start_line": 69,
      "code_end_line": 78,
      "parent": null,
      "params": [
        "maxAmount",
        "term",
        "side",
        "relation"
      ],
      "have_return": true,
      "code_content": "def queryConceptNet(maxAmount, term, side, relation):\n    ret = []\n    req = requests.get(\"http://api.conceptnet.io/query?\" + side + \"=/c/en/\" + term + \"&rel=/r/\" + relation + \"&limit=\" + str(maxAmount))\n    edges = req.json()[\"edges\"]\n    for edge in edges:\n        (s,v,p) = unwrap(edge[\"@id\"])\n        if (s == term or p == term) and \"_\" not in s and \"_\" not in p:\n            count = wordcounts[p] if s == term else wordcounts[s]\n            ret.append((toNarsese((s,v,p)),count))\n    return ret\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\concept_net_narsese.py/queryMeaning"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\concept_net_narsese.py/toNarsese",
        "OpenNARS-for-Applications\\concept_net_narsese.py/unwrap"
      ]
    },
    "queryMeaning": {
      "type": "FunctionDef",
      "name": "queryMeaning",
      "md_content": [
        "**queryMeaning**: The function of queryMeaning is to query the ConceptNet API for the meaning of a given term based on a specified set of criteria.\n\n**parameters**:\n- term: A string representing the term to query.\n- maxAmount: An integer representing the maximum number of results to retrieve from the ConceptNet API.\n- selectAmount: An integer representing the number of results to select from the retrieved results.\n- isEvent: A boolean value indicating whether the term represents an event.\n- querySpecificQuestion: A boolean value indicating whether the query is specific to a question.\n- question: A string representing the question to query.\n\n**Code Description**:\nThe `queryMeaning` function is responsible for querying the ConceptNet API to retrieve the meaning of a given term based on a set of specified criteria. It first initializes an empty list called `ret` to store the results. \n\nThe function then defines a list called `Relations` which contains a set of predefined relations. These relations represent different types of relationships that can exist between concepts in ConceptNet. \n\nNext, the function checks the value of the `querySpecificQuestion` parameter. If it is `True`, the function further checks the `question` parameter to determine the specific relation to query. If certain patterns are found in the `question` parameter, the `Relations` list is updated accordingly.\n\nAfter determining the relations to query, the function iterates over each relation in the `Relations` list. For each relation, it further iterates over each side in the `[\"end\", \"start\"]` list. This allows the function to query both the extension and intension of the given term. \n\nInside the nested loops, the function calls the `queryConceptNet` function (defined in a separate object) to retrieve the relationships between the given term and other concepts based on the current relation and side. The results are then appended to the `ret` list.\n\nOnce all the queries have been performed, the `ret` list is sorted in descending order based on the second element of each tuple. This ensures that the results with higher counts are placed at the beginning of the list.\n\nIf the `querySpecificQuestion` parameter is `False`, the function selects the first `selectAmount` results from the `ret` list. Otherwise, it includes all the results in the `ret` list.\n\nThe function then initializes variables `selected` and `returnlist` to keep track of the selected results and the final list of results, respectively. It iterates over each tuple in the `ret` list and checks if the Narsese representation of the tuple matches the specified question. If the question is not specific or the Narsese representation matches the question, the tuple is added to the `returnlist` along with a delimiter indicating whether the term represents an event.\n\nFinally, the function returns the `returnlist`, which contains the Narsese representations of the relationships between the given term and other concepts based on the specified criteria.\n\n**Note**:\n- The function assumes that the `term` and `question` parameters are strings, the `maxAmount` and `selectAmount` parameters are integers, and the `isEvent` and `querySpecificQuestion` parameters are boolean values.\n- The function relies on the `queryConceptNet` function to retrieve the relationships between the given term and other concepts.\n- The function does not perform any input validation or error handling.\n\n**Output Example**:\n- Input: `queryMeaning(\"Cat\", 5, 3, False, False, \"\")`\n- Output: `[\"<Cat --> Animal>.\", \"<Cat --> Mammal>.\", \"<Cat --> Pet>.\"]`"
      ],
      "code_start_line": 80,
      "code_end_line": 123,
      "parent": null,
      "params": [
        "term",
        "maxAmount",
        "selectAmount",
        "isEvent",
        "querySpecificQuestion",
        "question"
      ],
      "have_return": true,
      "code_content": "def queryMeaning(term, maxAmount, selectAmount, isEvent, querySpecificQuestion, question):\n    ret = []\n    Relations = [\"IsA\", \"InstanceOf\", \"HasProperty\", \"SimilarTo\"] + [\"DistinctFrom\", \"PartOf\", \"HasA\", \"MadeOf\", \"Causes\", \"Desires\"]\n    if querySpecificQuestion:\n        if \"} --> [\" in question:\n            Relations = [\"HasProperty\"]\n        elif \" --> [\" in question:\n            Relations = [\"HasProperty\"]\n        elif \"} --> \" in question:\n            Relations = [\"InstanceOf\"]\n        elif \" <-> \" in question:\n            Relations = [\"SimilarTo\"]\n        elif \"!\" in question and \" --> \" in question:\n            Relations = [\"DistinctFrom\"]\n        elif \" --> part_of\" in question:\n            Relations = [\"PartOf\"]\n        elif \" --> have\" in question:\n            Relations = [\"HasA\"]\n        elif \" --> make_of\" in question:\n            Relations = [\"MadeOf\"]\n        elif \" --> want\" in question:\n            Relations = [\"Desires\"]\n        elif \" =/> \"  in question:\n            Relations = [\"causes\"]\n        elif \" --> \" in question:\n            Relations = [\"IsA\"]\n    for rel in Relations:\n        for side in [\"end\", \"start\"]: #extension and intenstion query\n            ret.extend(queryConceptNet(maxAmount, term, side, rel))\n    ret.sort(key = lambda T: -T[1])\n    if not querySpecificQuestion:\n        ret = ret[:selectAmount]\n    selected = 0\n    returnlist = []\n    for T in ret:\n        queryPart = re.escape(question.replace(\" \",\"\")).replace(\"\\?1\",\"([a-zA-Z0-9]|_)*\")\n        pattern = T[0].replace(\" \", \"\")\n        #print(\"//MATCH ATTEMPT \" + queryPart + \" \" + pattern + str(bool(re.search(queryPart, pattern))))\n        if not querySpecificQuestion or re.search(queryPart, pattern):\n            returnlist += [T[0] + (\" :|:\" if isEvent else \"\")]\n            selected +=1\n            if selected >= selectAmount:\n                break\n    return returnlist\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "OpenNARS-for-Applications\\concept_net_narsese.py/queryConceptNet"
      ]
    },
    "extractAtomicTerms": {
      "type": "FunctionDef",
      "name": "extractAtomicTerms",
      "md_content": [
        "**extractAtomicTerms**: The function of extractAtomicTerms is to extract atomic terms from a given input string.\n\n**parameters**:\n- inp: The input string from which atomic terms need to be extracted.\n\n**Code Description**:\nThe extractAtomicTerms function takes an input string and iterates through each character of the string. It checks if the character is a letter (either uppercase or lowercase) or a digit. If the character satisfies this condition, it is appended to the atomicTerm string. This process continues until a non-alphanumeric character is encountered. At that point, if the atomicTerm string is not empty, it is added to the list L, and the atomicTerm string is reset to an empty string. Finally, the function returns the list L containing all the extracted atomic terms.\n\n**Note**:\n- The function considers both uppercase and lowercase letters as valid characters for atomic terms.\n- The function treats digits as valid characters for atomic terms.\n- The function does not consider any special characters or whitespace as part of an atomic term.\n- The function does not modify the original input string.\n\n**Output Example**:\nIf the input string is \"Hello123 World\", the function will return the list ['Hello123', 'World']."
      ],
      "code_start_line": 125,
      "code_end_line": 135,
      "parent": null,
      "params": [
        "inp"
      ],
      "have_return": true,
      "code_content": "def extractAtomicTerms(inp):\n    L = []\n    atomicTerm = \"\"\n    for x in inp:\n        if x >= \"a\" and x <= \"z\" or x >= \"A\" and x <= \"Z\" or x >= \"0\" and x <= \"9\":\n            atomicTerm += x\n        else:\n            if len(atomicTerm) > 0:\n                L += [atomicTerm]\n                atomicTerm = \"\"\n    return L\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    }
  },
  "OpenNARS-for-Applications\\concept_usefulness_filter.py": {},
  "OpenNARS-for-Applications\\create_doc.py": {
    "AddOutput": {
      "type": "FunctionDef",
      "name": "AddOutput",
      "md_content": [
        "**AddOutput**: The function of AddOutput is to append a line to the existing lines.\n\n**parameters**:\n- line: A string representing the line to be appended.\n\n**Code Description**:\nThe AddOutput function is a simple utility function that appends a line to the existing lines. It takes a single parameter, \"line\", which is a string representing the line to be appended. The function appends the line to the \"lines\" list.\n\nThis function is called by the \"Module\" function in the \"create_doc.py\" file. The \"Module\" function is responsible for creating a new module and adding it to the \"modules\" list. After adding the module, the \"Module\" function calls the AddOutput function to append a line to the \"lines\" list. The line that is appended contains HTML tags for a horizontal rule (\"<hr/>\") and a heading (\"<h1>\") with the module name.\n\n**Note**:\n- The AddOutput function assumes that the \"lines\" list is already defined and accessible within the scope of the function."
      ],
      "code_start_line": 5,
      "code_end_line": 6,
      "parent": null,
      "params": [
        "line"
      ],
      "have_return": false,
      "code_content": "def AddOutput(line):\n    lines.append(line)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\create_doc.py/Module"
      ],
      "reference_who": []
    },
    "Module": {
      "type": "FunctionDef",
      "name": "Module",
      "md_content": [
        "**Module**: The function of Module is to create a new module and add it to the \"modules\" list. It also appends a line to the existing lines.\n\n**parameters**:\n- name: A string representing the name of the module.\n\n**Code Description**:\nThe Module function is responsible for creating a new module and adding it to the \"modules\" list. It takes a single parameter, \"name\", which is a string representing the name of the module. \n\nWithin the function, the \"name\" parameter is appended to the \"modules\" list using the \"append\" method. This ensures that the newly created module is added to the list of existing modules.\n\nAfter adding the module to the \"modules\" list, the function calls the AddOutput function. This function is defined in the \"create_doc.py\" file and is responsible for appending a line to the existing lines. The line that is appended contains HTML tags for a horizontal rule (\"<hr/>\") and a heading (\"<h1>\") with the module name. This helps in visually separating and identifying the newly created module in the output.\n\n**Note**:\n- The \"modules\" list is assumed to be defined and accessible within the scope of the function.\n- The AddOutput function is assumed to be defined and accessible within the scope of the function.\n- The AddOutput function assumes that the \"lines\" list is already defined and accessible within the scope of the function."
      ],
      "code_start_line": 13,
      "code_end_line": 16,
      "parent": null,
      "params": [
        "name"
      ],
      "have_return": false,
      "code_content": "def Module(name):\n    global modules\n    modules.append(name)\n    AddOutput(\"<hr/><h1><b>Module: \" + name + \"</b></h1><br/>\")\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "OpenNARS-for-Applications\\create_doc.py/AddOutput"
      ]
    }
  },
  "OpenNARS-for-Applications\\derivation_priority_filter.py": {},
  "OpenNARS-for-Applications\\DockerInteractor.py": {
    "DockerInteractor": {
      "type": "ClassDef",
      "name": "DockerInteractor",
      "md_content": [
        "**DockerInteractor**: The function of DockerInteractor is to interact with a Docker container by executing commands and receiving output from the container.\n\n**attributes**:\n- process: A subprocess object representing the Docker container process.\n- stdout_queue: A queue to store the standard output from the container.\n- stderr_queue: A queue to store the standard error from the container.\n\n**Code Description**: The DockerInteractor class provides methods to send commands to a Docker container and receive the output from it. \n\nThe class constructor initializes the process attribute by creating a subprocess using the provided command. The subprocess is configured to redirect the standard input, standard output, and standard error to pipes. The bufsize parameter is set to 1 to enable line buffering, and universal_newlines is set to True to ensure that the input and output are treated as text.\n\nTwo reader threads are started to read the output from the container. The reader method is a static method that reads lines from a given stream and puts them into the specified queue.\n\nThe send method writes a message to the standard input of the container and flushes the input stream.\n\nThe recv method retrieves the next line of output from the container's standard output queue. It can optionally accept a timeout parameter to wait for a specified amount of time for the output to become available.\n\nThe recv_err method retrieves the next line of output from the container's standard error queue. It also accepts an optional timeout parameter.\n\nThe execute_command method sends a command to the container and receives the output until a specified delimiter is seen. It uses the send method to send the command and then reads lines from the container's standard output queue until either the delimiter is found or there is no more output. The output is accumulated in a string and returned after removing the delimiter.\n\nThe shutdown method closes the standard input stream of the container, terminates the container process, and waits for the process to terminate.\n\n**Note**: \n- The DockerInteractor class requires the subprocess and queue modules to be imported.\n- The send, recv, and recv_err methods are non-blocking, meaning they will return immediately even if there is no output available. It is the responsibility of the caller to handle the case where no output is received.\n- The execute_command method is blocking and will not return until the specified delimiter is seen or there is no more output from the container.\n\n**Output Example**:\n```python\ninteractor = DockerInteractor(\"docker exec -it my_container\")\ninteractor.send(\"ls\")\noutput = interactor.recv()\nprint(output)\n```\nOutput:\n```\nfile1.txt\nfile2.txt\n```"
      ],
      "code_start_line": 5,
      "code_end_line": 69,
      "parent": null,
      "params": [],
      "have_return": true,
      "code_content": "class DockerInteractor:\n    def __init__(self, command):\n        self.process = subprocess.Popen(\n            command,\n            stdin=subprocess.PIPE,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            bufsize=1,\n            universal_newlines=True\n        )\n\n        self.stdout_queue = queue.Queue()\n        self.stderr_queue = queue.Queue()\n\n        # Start reader threads\n        threading.Thread(target=self.reader, args=(self.process.stdout, self.stdout_queue)).start()\n        threading.Thread(target=self.reader, args=(self.process.stderr, self.stderr_queue)).start()\n\n    @staticmethod\n    def reader(stream, queue):\n        for line in iter(stream.readline, ''):\n            queue.put(line)\n        stream.close()\n\n    def send(self, message):\n        self.process.stdin.write(message + '\\n')\n        self.process.stdin.flush()\n\n    def recv(self, timeout=None):\n        try:\n            return self.stdout_queue.get(timeout=timeout)\n        except queue.Empty:\n            return None\n\n    def recv_err(self, timeout=None):\n        try:\n            return self.stderr_queue.get(timeout=timeout)\n        except queue.Empty:\n            return None\n\n    def execute_command(self, command, delimiter):\n        \"\"\"Send a command and receive the output until a delimiter is seen.\"\"\"\n        self.send(command)\n        \n        output = \"\"\n        while True:\n            line = self.recv(1)\n            if line is not None:\n                output += line\n\n            if line is None or delimiter in line:\n                break\n\n        return output.replace(delimiter, \"\")\n\n    def shutdown(self):\n        # Close the stdin stream\n        if self.process.stdin:\n            self.process.stdin.close()\n\n        # Terminate the process\n        self.process.terminate()\n\n        # Wait for the process to terminate, to free system resources\n        self.process.wait()\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "__init__": {
      "type": "FunctionDef",
      "name": "__init__",
      "md_content": [
        "**__init__**: The function of __init__ is to initialize an instance of the DockerInteractor class.\n\n**parameters**:\n- command: The command to be executed as a subprocess.\n\n**Code Description**:\nThe `__init__` function is the constructor of the DockerInteractor class. It takes a command as a parameter and initializes the instance by creating a subprocess using the `subprocess.Popen` function. The subprocess is executed with the specified command.\n\nThe `subprocess.Popen` function creates a new process and returns a Popen object that represents the process. The Popen object has attributes and methods that allow interaction with the process. In this case, the Popen object is assigned to the `self.process` attribute of the DockerInteractor instance.\n\nThe `subprocess.Popen` function takes several arguments:\n- `command`: The command to be executed as a subprocess. This can be a string or a sequence of strings.\n- `stdin`: The input stream for the subprocess. In this case, it is set to `subprocess.PIPE`, which means that the subprocess will receive input from the parent process through a pipe.\n- `stdout`: The output stream for the subprocess. It is set to `subprocess.PIPE`, which means that the subprocess output will be captured and made available for reading.\n- `stderr`: The error stream for the subprocess. It is set to `subprocess.PIPE`, which means that the subprocess error output will be captured and made available for reading.\n- `bufsize`: The buffer size for the input and output streams. It is set to 1, which means that the streams will be line-buffered.\n- `universal_newlines`: This parameter is set to True, which means that the input and output streams will be opened in text mode and use universal newlines.\n\nAfter creating the subprocess, the `__init__` function initializes two queue objects, `stdout_queue` and `stderr_queue`, using the `queue.Queue` class. These queues will be used to store the lines read from the stdout and stderr streams of the subprocess.\n\nThe function then starts two reader threads using the `threading.Thread` class. The `reader` function is used as the target function for both threads. The first thread reads lines from the stdout stream of the subprocess and puts them into the `stdout_queue`, while the second thread reads lines from the stderr stream of the subprocess and puts them into the `stderr_queue`. The `reader` function is called with the respective streams and queues as arguments.\n\nThe `reader` function is responsible for reading lines from a stream and putting them into a queue. It uses a `for` loop with the `iter` function to iterate over the lines of the stream until an empty line is encountered. This ensures that the function continues reading lines until the stream is closed or no more lines are available. After all the lines have been read, the stream is closed using the `close` method.\n\nIn the context of the project, the `__init__` function is called when an instance of the DockerInteractor class is created. It sets up the subprocess and the reader threads for capturing the output and error streams of the subprocess. This allows the DockerInteractor instance to interact with the subprocess and retrieve its output and error messages.\n\n**Note**: It is important to ensure that the command passed to the `__init__` function is a valid command that can be executed as a subprocess. Additionally, the queues (`stdout_queue` and `stderr_queue`) should be thread-safe if used in a multi-threaded environment to avoid potential race conditions."
      ],
      "code_start_line": 6,
      "code_end_line": 21,
      "parent": "DockerInteractor",
      "params": [
        "self",
        "command"
      ],
      "have_return": false,
      "code_content": "    def __init__(self, command):\n        self.process = subprocess.Popen(\n            command,\n            stdin=subprocess.PIPE,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            bufsize=1,\n            universal_newlines=True\n        )\n\n        self.stdout_queue = queue.Queue()\n        self.stderr_queue = queue.Queue()\n\n        # Start reader threads\n        threading.Thread(target=self.reader, args=(self.process.stdout, self.stdout_queue)).start()\n        threading.Thread(target=self.reader, args=(self.process.stderr, self.stderr_queue)).start()\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "OpenNARS-for-Applications\\DockerInteractor.py/DockerInteractor/reader"
      ]
    },
    "reader": {
      "type": "FunctionDef",
      "name": "reader",
      "md_content": [
        "**reader**: The function of reader is to read lines from a stream and put them into a queue.\n**parameters**:\n- stream: The input stream from which the lines will be read.\n- queue: The queue where the lines will be put.\n\n**Code Description**: \nThe `reader` function takes in a stream and a queue as parameters. It reads lines from the stream using the `readline` method and puts them into the queue using the `put` method. The function uses a `for` loop with the `iter` function to iterate over the lines of the stream until an empty line is encountered. This ensures that the function continues reading lines until the stream is closed or no more lines are available. After all the lines have been read, the stream is closed using the `close` method.\n\nThis function is typically used in a multi-threaded or multi-process environment where one thread or process is responsible for reading lines from a stream and another thread or process is responsible for processing those lines. By using a queue, the lines can be efficiently passed from the reader to the processor without the need for explicit synchronization between the threads or processes.\n\nIn the context of the project, the `reader` function is called by the `__init__` method of the `DockerInteractor` class. The `__init__` method creates a subprocess using the `subprocess.Popen` function and initializes two queues (`stdout_queue` and `stderr_queue`) for capturing the output and error streams of the subprocess. It then starts two reader threads, one for reading lines from the stdout stream of the subprocess and putting them into the `stdout_queue`, and another for reading lines from the stderr stream of the subprocess and putting them into the `stderr_queue`. The `reader` function is used as the target function for both reader threads, with the respective streams and queues passed as arguments.\n\n**Note**: It is important to ensure that the stream passed to the `reader` function is properly opened and accessible. Additionally, the queue passed to the function should be thread-safe if used in a multi-threaded environment to avoid potential race conditions."
      ],
      "code_start_line": 24,
      "code_end_line": 27,
      "parent": "DockerInteractor",
      "params": [
        "stream",
        "queue"
      ],
      "have_return": false,
      "code_content": "    def reader(stream, queue):\n        for line in iter(stream.readline, ''):\n            queue.put(line)\n        stream.close()\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\DockerInteractor.py/DockerInteractor/__init__"
      ],
      "reference_who": []
    },
    "send": {
      "type": "FunctionDef",
      "name": "send",
      "md_content": [
        "**send**: The function of send is to send a message to the process.\n\n**parameters**:\n- message: The message to be sent to the process.\n\n**Code Description**:\nThe `send` function is responsible for sending a message to the process. It takes a single parameter, `message`, which represents the message to be sent.\n\nInside the function, the `write` method of the `stdin` attribute of the `self.process` object is called to write the message to the input stream of the process. The message is appended with a newline character ('\\n') to ensure proper formatting. The `flush` method is then called to ensure that the message is immediately sent to the process.\n\n**Note**:\n- It is important to note that the `self.process` object must be initialized and running before calling the `send` function.\n- The `send` function does not return any value."
      ],
      "code_start_line": 29,
      "code_end_line": 31,
      "parent": "DockerInteractor",
      "params": [
        "self",
        "message"
      ],
      "have_return": false,
      "code_content": "    def send(self, message):\n        self.process.stdin.write(message + '\\n')\n        self.process.stdin.flush()\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\DockerInteractor.py/DockerInteractor/execute_command"
      ],
      "reference_who": []
    },
    "recv": {
      "type": "FunctionDef",
      "name": "recv",
      "md_content": [
        "**recv**: The function of recv is to receive data from the stdout_queue.\n\n**parameters**:\n- timeout (optional): The maximum time to wait for data to be received from the stdout_queue. If no data is received within the specified timeout, None is returned.\n\n**Code Description**:\nThe recv function is used to retrieve data from the stdout_queue. It first attempts to get data from the queue using the get method with the specified timeout. If data is available within the timeout period, it is returned. If the queue is empty or no data is received within the specified timeout, None is returned.\n\nThis function is called by the execute_command method in the DockerInteractor class. The execute_command method sends a command and then waits for the output until a delimiter is seen. It calls the recv function repeatedly with a timeout of 1 second to receive the output line by line. Each received line is appended to the output string. The loop continues until either no more data is received or the delimiter is found in the received line. Finally, the output string is returned after replacing the delimiter with an empty string.\n\n**Note**:\n- The recv function relies on the stdout_queue attribute, which should be populated with data before calling this function.\n- The timeout parameter can be used to control the maximum waiting time for data to be received. If not specified, the function will wait indefinitely until data is available.\n\n**Output Example**:\nIf data is available in the stdout_queue, the recv function will return the received data as a string. For example, if the stdout_queue contains the string \"Hello, World!\", calling recv() will return \"Hello, World!\".\n\nIf the stdout_queue is empty or no data is received within the specified timeout, the recv function will return None."
      ],
      "code_start_line": 33,
      "code_end_line": 37,
      "parent": "DockerInteractor",
      "params": [
        "self",
        "timeout"
      ],
      "have_return": true,
      "code_content": "    def recv(self, timeout=None):\n        try:\n            return self.stdout_queue.get(timeout=timeout)\n        except queue.Empty:\n            return None\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\DockerInteractor.py/DockerInteractor/execute_command"
      ],
      "reference_who": []
    },
    "recv_err": {
      "type": "FunctionDef",
      "name": "recv_err",
      "md_content": [
        "**recv_err**: The function of recv_err is to receive an error message from the stderr_queue.\n\n**parameters**:\n- timeout: An optional parameter that specifies the maximum time to wait for an error message. If not provided, the function will wait indefinitely until an error message is received.\n\n**Code Description**:\nThe recv_err function is used to retrieve an error message from the stderr_queue. The function first attempts to get an error message from the queue using the get() method with the specified timeout value. If an error message is available within the specified timeout, it is returned. If the timeout expires before an error message is received, the function returns None.\n\n**Note**:\n- This function assumes that the stderr_queue is a valid queue object that has been properly initialized.\n- If the timeout parameter is not provided, the function will wait indefinitely until an error message is received. It is important to handle this case appropriately to avoid potential blocking issues.\n\n**Output Example**:\nIf an error message is available in the stderr_queue, the function will return the error message as a string. For example, if the stderr_queue contains the error message \"File not found\", the function will return the string \"File not found\". If the stderr_queue is empty or the timeout expires before an error message is received, the function will return None."
      ],
      "code_start_line": 39,
      "code_end_line": 43,
      "parent": "DockerInteractor",
      "params": [
        "self",
        "timeout"
      ],
      "have_return": true,
      "code_content": "    def recv_err(self, timeout=None):\n        try:\n            return self.stderr_queue.get(timeout=timeout)\n        except queue.Empty:\n            return None\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "execute_command": {
      "type": "FunctionDef",
      "name": "execute_command",
      "md_content": [
        "**execute_command**: The function of execute_command is to send a command to a process and receive the output until a specified delimiter is seen.\n\n**parameters**:\n- command: The command to be sent to the process.\n- delimiter: The delimiter used to determine when to stop receiving the output.\n\n**Code Description**:\nThe `execute_command` function is responsible for sending a command to a process and receiving the output until a specified delimiter is seen. It takes two parameters: `command`, which represents the command to be sent, and `delimiter`, which is the string used to determine when to stop receiving the output.\n\nInside the function, the `send` method of the `self` object is called to send the command to the process. This method is implemented in the `send` function of the `DockerInteractor` class. The `send` function writes the command to the input stream of the process.\n\nAfter sending the command, the function enters a loop to receive the output from the process. The `recv` method of the `self` object is called repeatedly with a timeout of 1 second to receive the output line by line. This method is implemented in the `recv` function of the `DockerInteractor` class. The received line is appended to the `output` string.\n\nThe loop continues until either no more data is received or the delimiter is found in the received line. If no data is received within the timeout period, the `recv` method returns `None`. If the delimiter is found in the received line, the loop is terminated.\n\nFinally, the function returns the `output` string after replacing the delimiter with an empty string.\n\n**Note**:\n- It is important to note that the `self` object must be an instance of the `DockerInteractor` class and the `self.process` object must be initialized and running before calling the `execute_command` function.\n- The `execute_command` function assumes that the `send` and `recv` methods of the `self` object are implemented correctly and that the `recv` method returns `None` when no data is received within the specified timeout.\n- The `execute_command` function does not handle any exceptions that may occur during the execution of the `send` and `recv` methods. It is recommended to handle exceptions appropriately when using this function.\n\n**Output Example**:\nIf the output received from the process is \"Hello, World!\\n\", and the delimiter is set to \"\\n\", calling `execute_command(\"echo Hello, World!\", \"\\n\")` will return \"Hello, World!\"."
      ],
      "code_start_line": 45,
      "code_end_line": 58,
      "parent": "DockerInteractor",
      "params": [
        "self",
        "command",
        "delimiter"
      ],
      "have_return": true,
      "code_content": "    def execute_command(self, command, delimiter):\n        \"\"\"Send a command and receive the output until a delimiter is seen.\"\"\"\n        self.send(command)\n        \n        output = \"\"\n        while True:\n            line = self.recv(1)\n            if line is not None:\n                output += line\n\n            if line is None or delimiter in line:\n                break\n\n        return output.replace(delimiter, \"\")\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "OpenNARS-for-Applications\\DockerInteractor.py/DockerInteractor/send",
        "OpenNARS-for-Applications\\DockerInteractor.py/DockerInteractor/recv"
      ]
    },
    "shutdown": {
      "type": "FunctionDef",
      "name": "shutdown",
      "md_content": [
        "**shutdown**: The function of shutdown is to close the stdin stream, terminate the process, and wait for the process to terminate in order to free system resources.\n\n**parameters**:\n- None\n\n**Code Description**:\nThe `shutdown` function is responsible for shutting down the Docker interactor. It performs the following steps:\n\n1. Close the stdin stream: The function first checks if the `stdin` stream of the process is open. If it is, it closes the stream using the `close()` method. This ensures that no further input can be sent to the process.\n\n2. Terminate the process: Next, the function calls the `terminate()` method on the process object. This sends a termination signal to the process, indicating that it should be stopped. The process may not immediately terminate after this signal is sent.\n\n3. Wait for the process to terminate: After terminating the process, the function calls the `wait()` method on the process object. This blocks the execution of the program until the process has completely terminated. This step is important to ensure that all system resources associated with the process are freed.\n\n**Note**:\n- It is important to call the `shutdown` function when you are finished using the Docker interactor, in order to properly close the process and free system resources.\n- If the `stdin` stream is not closed before terminating the process, it may result in unexpected behavior or resource leaks.\n- The `wait()` method is necessary to ensure that the process has completely terminated before continuing with other operations."
      ],
      "code_start_line": 60,
      "code_end_line": 69,
      "parent": "DockerInteractor",
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def shutdown(self):\n        # Close the stdin stream\n        if self.process.stdin:\n            self.process.stdin.close()\n\n        # Terminate the process\n        self.process.terminate()\n\n        # Wait for the process to terminate, to free system resources\n        self.process.wait()\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    }
  },
  "OpenNARS-for-Applications\\english_to_narsese.py": {
    "wordnet_tag": {
      "type": "FunctionDef",
      "name": "wordnet_tag",
      "md_content": [
        "**wordnet_tag**: The function of wordnet_tag is to map a given tag to its corresponding WordNet tag.\n\n**parameters**:\n- tag: A string representing the tag to be mapped.\n\n**Code Description**:\nThe `wordnet_tag` function takes a tag as input and returns the corresponding WordNet tag. It uses a series of if-else statements to check the value of the input tag and returns the appropriate WordNet tag based on the following conditions:\n- If the tag is \"ADJ\", it returns `wordnet.ADJ`.\n- If the tag is \"VERB\", it returns `wordnet.VERB`.\n- If the tag is \"NOUN\", it returns `wordnet.NOUN`.\n- If the tag is \"ADV\", it returns `wordnet.ADV`.\n- If none of the above conditions are met, it returns `wordnet.NOUN` as the default tag.\n\nThe `wordnet_tag` function is called by the `sentence_and_types` function in the `english_to_narsese.py` module of the OpenNARS-for-Applications project. The `sentence_and_types` function is responsible for processing a given text and generating a list of tokens along with their corresponding WordNet tags. It uses the `wordnet_tag` function to map the universal POS tags obtained from the `nltk.pos_tag` function to their corresponding WordNet tags. The WordNet tags are then used to lemmatize the tokens using the `WordNetLemmatizer` class.\n\n**Note**:\n- The `wordnet_tag` function assumes that the input tag is one of the following: \"ADJ\", \"VERB\", \"NOUN\", or \"ADV\". If the input tag is not one of these, it defaults to \"NOUN\".\n- The `wordnet_tag` function requires the `wordnet` module to be imported.\n- The `wordnet_tag` function does not handle any exceptions or errors related to the input tag.\n\n**Output Example**:\n- Example 1:\n  - Input: \"ADJ\"\n  - Output: `wordnet.ADJ`\n- Example 2:\n  - Input: \"VERB\"\n  - Output: `wordnet.VERB`\n- Example 3:\n  - Input: \"NOUN\"\n  - Output: `wordnet.NOUN`\n- Example 4:\n  - Input: \"ADV\"\n  - Output: `wordnet.ADV`\n- Example 5:\n  - Input: \"OTHER\"\n  - Output: `wordnet.NOUN`"
      ],
      "code_start_line": 86,
      "code_end_line": 96,
      "parent": null,
      "params": [
        "tag"
      ],
      "have_return": true,
      "code_content": "def wordnet_tag(tag):\n    if tag == \"ADJ\":\n        return wordnet.ADJ\n    elif tag == \"VERB\":\n        return wordnet.VERB\n    elif tag == \"NOUN\":\n        return wordnet.NOUN\n    elif tag == 'ADV':\n        return wordnet.ADV\n    else:          \n        return wordnet.NOUN #default\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\english_to_narsese.py/sentence_and_types"
      ],
      "reference_who": []
    },
    "sentence_and_types": {
      "type": "FunctionDef",
      "name": "sentence_and_types",
      "md_content": [
        "**sentence_and_types**: The function of sentence_and_types is to process a given text and generate a list of tokens along with their corresponding WordNet tags.\n\n**parameters**:\n- text: A string representing the input text to be processed.\n\n**Code Description**:\nThe `sentence_and_types` function takes a text as input and performs the following steps to generate the desired output:\n1. It tokenizes the input text using the `word_tokenize` function from the `nltk` library, and stores the tokens in a list called `tokens`.\n2. It uses the `nltk.pos_tag` function to obtain the universal POS tags for each token in the `tokens` list. The resulting list of tuples, containing the tokens and their corresponding tags, is stored in the `wordtypes_ordered` variable.\n3. It converts the `wordtypes_ordered` list of tuples into a dictionary called `wordtypes`, where the tokens are the keys and the tags are the values.\n4. It initializes a `WordNetLemmatizer` object called `lemma` for lemmatizing the tokens.\n5. It defines a lambda function called `handleInstance` that takes a word as input and returns the word enclosed in curly braces if the first character of the word is uppercase, otherwise it returns the word itself.\n6. It iterates over the `tokens` list and performs the following operations for each token:\n   - It lemmatizes the token using the `lemma.lemmatize` method, passing the token and the WordNet tag obtained from the `wordnet_tag` function as arguments.\n   - It applies the `handleInstance` lambda function to the lemmatized token.\n   - It replaces the token in the `tokens` list with the modified token.\n7. It updates the `wordtypes` dictionary by creating a new dictionary comprehension that maps the modified tokens to their corresponding tags.\n8. It further updates the `wordtypes` dictionary by replacing the values with more descriptive tags based on the following conditions:\n   - If the token is \"be\", it is replaced with \"BE\".\n   - If the token is \"if\", it is replaced with \"IF\".\n   - If the tag is \"PRON\" or \"NUM\", the value is replaced with \"NOUN\".\n   - If the tag is \"PRT\", the value is replaced with \"ADP\".\n   - Otherwise, the value remains unchanged.\n9. It initializes an empty list called `indexed_wordtypes` to store the final output.\n10. It iterates over the `tokens` list and performs the following operations for each token:\n    - If the previous token is None or the tag of the previous token is \"NOUN\" or \"ADP\" or \"IF\", it increments the index `i` by 1.\n    - It appends the concatenation of the tag and the index to the `indexed_wordtypes` list.\n    - It updates the value of the `lasttoken` variable to the current token.\n11. If the \"verbose\" command line argument is present, it prints the word types dictionary.\n12. It returns two strings:\n    - The first string is the concatenation of the tokens in the `tokens` list, separated by spaces.\n    - The second string is the concatenation of the tags in the `indexed_wordtypes` list, separated by spaces.\n\n**Note**:\n- The `sentence_and_types` function assumes that the `nltk` library and the `WordNetLemmatizer` class from the `nltk.stem` module have been imported.\n- The `sentence_and_types` function calls the `word_tokenize` and `pos_tag` functions from the `nltk.tokenize` and `nltk.tag` modules, respectively.\n- The `sentence_and_types` function calls the `wordnet_tag` function, which is defined in the same module.\n- The `sentence_and_types` function uses the `sys.argv` list to check if the \"verbose\" command line argument is present. This implies that the function is intended to be used in a command line environment.\n- The `sentence_and_types` function does not handle any exceptions or errors related to the input text or the execution of the code.\n\n**Output Example**:\n- Example 1:\n  - Input: \"The quick brown fox jumps over the lazy dog.\"\n  - Output: \" the quick brown fox jump over the lazy dog \", \" DET_1 ADJ_1 ADJ_1 NOUN_1 VERB_1 ADP_1 DET_2 ADJ_2 NOUN_2 ._2 \"\n- Example 2:\n  - Input: \"I am happy.\"\n  - Output: \" i be happy \", \" PRON_1 VERB_1 ADJ_1 ._1 \""
      ],
      "code_start_line": 99,
      "code_end_line": 118,
      "parent": null,
      "params": [
        "text"
      ],
      "have_return": true,
      "code_content": "def sentence_and_types(text):\n    tokens = [word for word in word_tokenize(text)]\n    wordtypes_ordered = nltk.pos_tag(tokens, tagset='universal')\n    wordtypes = dict(wordtypes_ordered)\n    lemma = WordNetLemmatizer()\n    #NamedEntities = {key:value for (key,value) in [(x.lower(),x) for x in tokens]}\n    handleInstance = lambda word: \"{\"+word+\"}\" if word[0].isupper() else word\n    tokens = [handleInstance(lemma.lemmatize(word, pos = wordnet_tag(wordtypes[word]))) for word in tokens]\n    wordtypes = dict([(tokens[i], wordtypes_ordered[i][1]) for i in range(len(tokens))])\n    wordtypes = {key : (\"BE\" if key == \"be\" else (\"IF\" if key == \"if\" else (\"NOUN\" if value==\"PRON\" or value==\"NUM\" else (\"ADP\" if value==\"PRT\" else value)))) for (key,value) in wordtypes.items()}\n    indexed_wordtypes = []\n    i = 0\n    lasttoken = None\n    for token in tokens:\n        if lasttoken == None or wordtypes[lasttoken] == \"NOUN\" or wordtypes[token] == \"ADP\" or wordtypes[token] == \"IF\": #adjectives don't cross these\n            i += 1 #each noun or new article ends previous ADJ_NOUN index\n        indexed_wordtypes.append(wordtypes[token] + \"_\" + str(i))\n        lasttoken = token\n    if \"verbose\" in sys.argv: print(\"//Word types: \" + str(wordtypes))\n    return \" \" + \" \".join(tokens) + \" \", \" \" + \" \".join(indexed_wordtypes) + \" \"\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\english_to_narsese.py/GrammarLearning"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\english_to_narsese.py/wordnet_tag"
      ]
    },
    "Truth_Deduction": {
      "type": "FunctionDef",
      "name": "Truth_Deduction",
      "md_content": [
        "**Truth_Deduction**: The function of Truth_Deduction is to perform a truth deduction operation on two truth values.\n\n**parameters**:\n- Ta: A list representing the truth value of the first proposition. It contains two elements: the belief value and the plausibility value.\n- Tb: A list representing the truth value of the second proposition. It also contains two elements: the belief value and the plausibility value.\n\n**Code Description**:\nThe Truth_Deduction function takes two truth values, Ta and Tb, as input and performs a truth deduction operation on them. The truth deduction operation is defined as follows:\n\n1. The belief value of the resulting truth value is calculated by multiplying the belief values of Ta and Tb.\n2. The plausibility value of the resulting truth value is calculated by multiplying the belief values of Ta, the belief values of Tb, the plausibility values of Ta, and the plausibility values of Tb.\n\nThe function returns a list containing the resulting truth value, which consists of the calculated belief value and plausibility value.\n\nThis function is called by two objects in the project:\n\n1. getWordTerm:\nThe getWordTerm function uses the Truth_Deduction function to update the current truth value (curTruth) by performing a truth deduction operation with the truth value (Truth) obtained from the TermRepresentRelations list. The resulting truth value is then used in further calculations and transformations.\n\n2. reduceTypetext:\nThe reduceTypetext function uses the Truth_Deduction function to update the current truth value (curTruth) by performing a truth deduction operation with the truth value (Truth) obtained from the AcquiredGrammar and StatementRepresentRelations lists. The resulting truth value is used to determine the transformation of the typetext.\n\n**Note**:\n- The input truth values (Ta and Tb) should be lists containing two elements: the belief value and the plausibility value.\n- The output of the function is a list containing the resulting truth value.\n- The function assumes that the input truth values are valid and in the correct format.\n\n**Output Example**:\nIf Ta = [0.8, 0.7] and Tb = [0.6, 0.5], the function will return [0.48, 0.21]."
      ],
      "code_start_line": 121,
      "code_end_line": 122,
      "parent": null,
      "params": [
        "Ta",
        "Tb"
      ],
      "have_return": true,
      "code_content": "def Truth_Deduction(Ta, Tb):\n    return [Ta[0]*Tb[0], Ta[0]*Tb[0]*Ta[1]*Tb[1]]\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\english_to_narsese.py/getWordTerm",
        "OpenNARS-for-Applications\\english_to_narsese.py/reduceTypetext"
      ],
      "reference_who": []
    },
    "Truth_w2c": {
      "type": "FunctionDef",
      "name": "Truth_w2c",
      "md_content": [
        "**Truth_w2c**: The function of Truth_w2c is to calculate the confidence value of a given belief based on its weight.\n\n**parameters**:\n- w: A numeric value representing the weight of the belief.\n\n**Code Description**:\nThe `Truth_w2c` function takes a weight value `w` as input and calculates the confidence value of a belief using the formula `w / (w + 1.0)`. The weight represents the strength or importance of the belief, and the confidence value represents the degree of certainty associated with the belief.\n\nIn the formula, the weight `w` is divided by the sum of `w` and 1.0. This division operation normalizes the weight value to a range between 0 and 1, where 0 indicates complete uncertainty and 1 indicates complete certainty.\n\nThe `Truth_w2c` function is called by the `Truth_Revision` function in the `english_to_narsese.py` module of the OpenNARS-for-Applications project. The `Truth_Revision` function calculates the revised truth value and confidence of two beliefs based on their weights and previous confidence values. The `Truth_w2c` function is used to calculate the confidence value of the revised belief.\n\n**Note**:\n- The input weight `w` should be a numeric value.\n- The output confidence value will be in the range between 0 and 1.\n\n**Output Example**:\nIf the input weight `w` is 2.0, the function will return 0.6666666666666666."
      ],
      "code_start_line": 124,
      "code_end_line": 125,
      "parent": null,
      "params": [
        "w"
      ],
      "have_return": true,
      "code_content": "def Truth_w2c(w):\n    return w / (w + 1.0)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\english_to_narsese.py/Truth_Revision"
      ],
      "reference_who": []
    },
    "Truth_c2w": {
      "type": "FunctionDef",
      "name": "Truth_c2w",
      "md_content": [
        "**Truth_c2w**: The function of Truth_c2w is to calculate the corresponding NARSese truth value given a confidence value.\n\n**parameters**:\n- c: A float value representing the confidence value.\n\n**Code Description**:\nThe function takes a confidence value as input and calculates the corresponding NARSese truth value using the formula c / (1.0 - c). It returns the calculated truth value.\n\nThis function is called by the \"Truth_Revision\" function in the \"english_to_narsese.py\" module. In the \"Truth_Revision\" function, the \"Truth_c2w\" function is used to convert the confidence values of two input variables (v1 and v2) into their corresponding NARSese truth values (w1 and w2) using the \"Truth_c2w\" function. These truth values are then used to calculate a weighted average truth value (w) and a revised confidence value.\n\n**Note**:\n- The input confidence value should be a float between 0 and 1 (excluding 1) to avoid division by zero.\n- The output truth value will also be a float between 0 and 1.\n\n**Output Example**:\nIf the input confidence value is 0.8, the function will return the corresponding NARSese truth value of 4.0."
      ],
      "code_start_line": 127,
      "code_end_line": 128,
      "parent": null,
      "params": [
        "c"
      ],
      "have_return": true,
      "code_content": "def Truth_c2w(c):\n    return c / (1.0 - c)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\english_to_narsese.py/Truth_Revision"
      ],
      "reference_who": []
    },
    "Truth_Expectation": {
      "type": "FunctionDef",
      "name": "Truth_Expectation",
      "md_content": [
        "**Truth_Expectation**: The function of Truth_Expectation is to calculate the truth expectation value based on a given input.\n\n**parameters**:\n- v: A list containing two elements. The first element represents the truth value, and the second element represents the confidence value.\n\n**Code Description**:\nThe `Truth_Expectation` function takes a list `v` as input and calculates the truth expectation value using the formula `(v[1] * (v[0] - 0.5) + 0.5)`. \n\nThe formula calculates the truth expectation by multiplying the confidence value (`v[1]`) with the difference between the truth value (`v[0]`) and 0.5, and then adding 0.5 to the result.\n\n**Note**:\n- The input list `v` should contain two elements, where the first element represents the truth value and the second element represents the confidence value.\n- The truth value should be a float between 0 and 1, and the confidence value should also be a float between 0 and 1.\n\n**Output Example**:\n- Input: `[0.8, 0.6]`\n- Output: `0.68`"
      ],
      "code_start_line": 130,
      "code_end_line": 131,
      "parent": null,
      "params": [
        "v"
      ],
      "have_return": true,
      "code_content": "def Truth_Expectation(v):\n    return (v[1] * (v[0] - 0.5) + 0.5)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\english_to_narsese.py/GrammarLearning"
      ],
      "reference_who": []
    },
    "Truth_Revision": {
      "type": "FunctionDef",
      "name": "Truth_Revision",
      "md_content": [
        "**Truth_Revision**: The function of Truth_Revision is to calculate the revised truth value and confidence of two beliefs based on their weights and previous confidence values.\n\n**parameters**:\n- v1: A tuple representing the first belief, where the first element is the truth value (f1) and the second element is the confidence value (c1).\n- v2: A tuple representing the second belief, where the first element is the truth value (f2) and the second element is the confidence value (c2).\n\n**Code Description**:\nThe `Truth_Revision` function takes two beliefs as input, each represented by a tuple containing a truth value and a confidence value. It then performs the following steps:\n\n1. Unpacks the truth value (f1) and confidence value (c1) from the first belief (v1).\n2. Unpacks the truth value (f2) and confidence value (c2) from the second belief (v2).\n3. Calls the `Truth_c2w` function to convert the confidence values (c1 and c2) into their corresponding NARSese truth values (w1 and w2).\n4. Calculates the weighted sum of the NARSese truth values (w1 and w2) and assigns it to the variable `w`.\n5. Calculates the revised truth value using the formula `(w1 * f1 + w2 * f2) / w`, where `w1 * f1` represents the weighted contribution of the first belief and `w2 * f2` represents the weighted contribution of the second belief.\n6. Limits the revised truth value to a maximum of 1.0 using the `min` function.\n7. Calls the `Truth_w2c` function to convert the NARSese truth value (w) back into a confidence value.\n8. Calculates the revised confidence value using the formula `max(max(Truth_w2c(w), c1), c2)`, where `Truth_w2c(w)` represents the confidence value calculated from the NARSese truth value (w).\n9. Limits the revised confidence value to a maximum of 0.99 using the `min` function.\n\nThe `Truth_Revision` function returns a tuple containing the revised truth value and confidence value.\n\n**Note**:\n- The input beliefs should be represented as tuples, where the first element is the truth value and the second element is the confidence value.\n- The output truth value will be in the range between 0 and 1, and the output confidence value will be in the range between 0 and 0.99.\n\n**Output Example**:\nIf the input beliefs are `v1 = (0.8, 0.6)` and `v2 = (0.6, 0.7)`, the function will return the revised belief `(0.7333333333333333, 0.7)`."
      ],
      "code_start_line": 133,
      "code_end_line": 140,
      "parent": null,
      "params": [
        "v1",
        "v2"
      ],
      "have_return": true,
      "code_content": "def Truth_Revision(v1, v2):\n    (f1, c1) = v1\n    (f2, c2) = v2\n    w1 = Truth_c2w(c1)\n    w2 = Truth_c2w(c2)\n    w = w1 + w2\n    return (min(1.0, (w1 * f1 + w2 * f2) / w), \n            min(0.99, max(max(Truth_w2c(w), c1), c2)))\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\english_to_narsese.py/GrammarLearning"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\english_to_narsese.py/Truth_w2c",
        "OpenNARS-for-Applications\\english_to_narsese.py/Truth_c2w"
      ]
    },
    "getWordTerm": {
      "type": "FunctionDef",
      "name": "getWordTerm",
      "md_content": [
        "**getWordTerm**: The function of getWordTerm is to retrieve the corresponding word term for a given input term based on the TermRepresentRelations and wordType dictionaries.\n\n**parameters**:\n- term: A string representing the input term for which the word term needs to be retrieved.\n- curTruth: A list representing the current truth value. It contains two elements: the belief value and the plausibility value.\n- suppressOutput (optional): A boolean value indicating whether to suppress the output or not. It is set to True by default.\n\n**Code Description**:\nThe getWordTerm function iterates over the TermRepresentRelations list, which contains tuples of (schema, compound, Truth). It uses regular expressions to match the input term with the schema. If a match is found, the function updates the current truth value (curTruth) by performing a truth deduction operation using the Truth value from the matched tuple.\n\nThe function then constructs the modifier and atomic terms by splitting the input term using the \"_\" delimiter and appending the matched group from the regular expression match. It checks if the modifier term exists in the wordType dictionary. If it does, it replaces the term with the compound term, which is a formatted string using the wordType values of the modifier and atomic terms. Otherwise, it sets the term to the atomic term.\n\nFinally, the function returns the corresponding word term from the wordType dictionary for the updated term. If the term is not found in the dictionary, it returns the original term.\n\n**Note**:\n- The function assumes that the TermRepresentRelations and wordType dictionaries are properly defined.\n- The suppressOutput parameter can be used to control the verbosity of the function's output.\n- The function modifies the curTruth list in-place.\n\n**Output Example**:\nIf the input term is \"example_term\" and the wordType dictionary contains the mapping {\"example_modifier\": \"modified\", \"example_atomic\": \"atom\"}, the function will return \"modified_atom\"."
      ],
      "code_start_line": 144,
      "code_end_line": 157,
      "parent": null,
      "params": [
        "term",
        "curTruth",
        "suppressOutput"
      ],
      "have_return": true,
      "code_content": "def getWordTerm(term, curTruth, suppressOutput = True):\n    for (schema, compound, Truth) in TermRepresentRelations:\n        m = re.match(schema, term)\n        if not m:\n            continue\n        curTruth[:] = Truth_Deduction(curTruth, Truth)\n        modifier = term.split(\"_\")[0] + \"_\" + m.group(1)\n        atomic =  term.split(\"_\")[1] + \"_\" + m.group(1)\n        if modifier in wordType:\n            if \"verbose\" in sys.argv and not suppressOutput: print(\"// Using \" + str((schema, compound, Truth))) \n            term = compound % (wordType[modifier], wordType[atomic]) \n        else:\n            term = atomic\n    return wordType.get(term, term)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\english_to_narsese.py/reduceTypetext"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\english_to_narsese.py/Truth_Deduction"
      ]
    },
    "reduceTypetext": {
      "type": "FunctionDef",
      "name": "reduceTypetext",
      "md_content": [
        "**reduceTypetext**: The function of reduceTypetext is to transform a given typetext by applying syntactical transformations and statement/term represent relations. It also allows for the suppression of output and returns the transformed typetext along with the current truth value.\n\n**parameters**:\n- typetext: A string representing the input typetext that needs to be transformed.\n- applyStatementRepresentRelations (optional): A boolean value indicating whether to apply statement represent relations. It is set to False by default.\n- applyTermRepresentRelations (optional): A boolean value indicating whether to apply term represent relations. It is set to False by default.\n- suppressOutput (optional): A boolean value indicating whether to suppress the output. It is set to True by default.\n\n**Code Description**:\nThe reduceTypetext function takes a typetext as input and applies syntactical transformations to it using regular expressions. It iterates over the SyntacticalTransformations list and replaces the matching patterns with their corresponding replacements.\n\nIf the applyStatementRepresentRelations parameter is set to True, the function further applies statement represent relations. It iterates over the AcquiredGrammar and StatementRepresentRelations lists and replaces the matching patterns with their corresponding replacements. It also updates the current truth value (curTruth) by performing a truth deduction operation using the Truth value from the matched tuple.\n\nIf the applyTermRepresentRelations parameter is set to True, the function applies term represent relations. It splits the typetext into individual words and checks if each word contains a \"+\" symbol. If it does, it retrieves the corresponding word terms using the getWordTerm function and combines them with \"_\". Otherwise, it retrieves the word term for the individual word. The resulting word terms are then joined back into a single string.\n\nThe function returns the transformed typetext and the current truth value.\n\n**Note**:\n- The function assumes that the SyntacticalTransformations, AcquiredGrammar, and StatementRepresentRelations lists are properly defined.\n- The suppressOutput parameter can be used to control the verbosity of the function's output.\n- The function modifies the curTruth list in-place.\n\n**Output Example**:\nIf the input typetext is \"A + B\" and the applyStatementRepresentRelations and applyTermRepresentRelations parameters are set to True, the function may return \"modified_atom\" and [0.48, 0.21] as the transformed typetext and current truth value, respectively."
      ],
      "code_start_line": 160,
      "code_end_line": 174,
      "parent": null,
      "params": [
        "typetext",
        "applyStatementRepresentRelations",
        "applyTermRepresentRelations",
        "suppressOutput"
      ],
      "have_return": true,
      "code_content": "def reduceTypetext(typetext, applyStatementRepresentRelations = False, applyTermRepresentRelations = False, suppressOutput = True):\n    curTruth = [1.0, 0.9]\n    for i in range(len(SyntacticalTransformations)):\n        for (a, b) in SyntacticalTransformations:\n            typetext = re.sub(a, b, typetext)\n    if applyStatementRepresentRelations:\n        for (a, b, Truth, _) in AcquiredGrammar + StatementRepresentRelations:\n            typetext_new = re.sub(a, b, typetext)\n            if typetext_new != typetext:\n                if \"verbose\" in sys.argv and not suppressOutput: print(\"// Using \" + str((a, b, Truth)))\n                typetext = typetext_new\n                curTruth = Truth_Deduction(curTruth, Truth)\n        if applyTermRepresentRelations:\n            typetext = \" \".join([getWordTerm(x, curTruth, suppressOutput=suppressOutput) if \"+\" not in x else getWordTerm(x.split(\"+\")[0], curTruth, suppressOutput=suppressOutput)+\"_\"+getWordTerm(x.split(\"+\")[1], curTruth, suppressOutput=suppressOutput) for x in typetext.split(\" \")])\n    return typetext, curTruth\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\english_to_narsese.py/GrammarLearning"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\english_to_narsese.py/Truth_Deduction",
        "OpenNARS-for-Applications\\english_to_narsese.py/getWordTerm"
      ]
    },
    "GrammarLearning": {
      "type": "FunctionDef",
      "name": "GrammarLearning",
      "md_content": [
        "**GrammarLearning**: The function of GrammarLearning is to learn a grammar relation based on a given input and update the acquired grammar.\n\n**parameters**:\n- y (optional): A string representing the input Narsese sentence. It is set to an empty string by default.\n- forced (optional): A boolean value indicating whether to force the learning process, even if the input sentence is already encoded in Narsese format. It is set to False by default.\n\n**Code Description**:\nThe `GrammarLearning` function is responsible for learning a grammar relation based on a given input sentence. It first checks if the input sentence is already fully encoded in Narsese format. If not, it prompts the user to provide simple sentences that can be used as examples for learning the grammar relation.\n\nThe function takes the user's input sentences and processes them using the `sentence_and_types` function, which generates a list of tokens along with their corresponding WordNet tags. It then maps the tokens to their corresponding types using the `typeWord` dictionary.\n\nIf the mapped types are not empty, the function proceeds to induce the grammar relation by reducing the type text and checking if it matches any existing grammar relation in the `AcquiredGrammar` list. If a match is found, the function performs a truth revision operation on the existing grammar relation using the `Truth_Revision` function.\n\nThe induced grammar relation, along with its mapped types and the current time, is then added to the `AcquiredGrammar` list. The list is sorted based on the truth expectation and time values in descending order.\n\nThe function returns True if the grammar learning process is successful, and False otherwise.\n\n**Note**:\n- The `GrammarLearning` function assumes that the `AcquiredGrammar`, `currentTime`, `sentence_and_types`, `reduceTypetext`, `typeWord`, `Truth_Revision`, and `Truth_Expectation` objects have been properly defined and imported.\n- The function relies on user input for providing simple sentences as examples for learning the grammar relation.\n- The function does not handle any exceptions or errors related to the user input or the execution of the code.\n\n**Output Example**:\n- Example 1:\n  - Input: GrammarLearning(y=\"<apple> =/> fruit.\")\n  - Output: True\n- Example 2:\n  - Input: GrammarLearning()\n  - Output: False"
      ],
      "code_start_line": 178,
      "code_end_line": 207,
      "parent": null,
      "params": [
        "y",
        "forced"
      ],
      "have_return": true,
      "code_content": "def GrammarLearning(y = \"\", forced = False):\n    global AcquiredGrammar, currentTime\n    if forced or (not y.startswith(\"<\") or not y.endswith(\">\") or (y.count(\"<\") > 1 and not \"=/>\" in y)): #Only if not fully encoded/valid Narsese\n        print(\"//What? Tell \\\"\" + sentence.strip() + \"\\\" in simple sentences: (newline-separated)\")\n        L = []\n        while True:\n            try:\n                s = \" \" + input().rstrip(\"\\n\") + \" \"\n                print(\"//Example input: \" + s.strip() if s.strip() != \"\" else \"//Example done.\")\n            except:\n                exit(0)\n            if s.strip() == \"\":\n                break\n            L.append(sentence_and_types(s)[0])\n        mapped = \",\".join([reduceTypetext(\" \" + \" \".join([typeWord.get(x) for x in part.split(\" \") if x.strip() != \"\" and x in typeWord]) + \" \")[0] for part in L])\n        if mapped.strip() != \"\":\n            (R,mapped,T) = ( reduceTypetext(typetextReduced)[0], mapped, (1.0, 0.45))\n            for i,typeword in enumerate(R.strip().split(\" \")): #generalize grammar indices\n                R = R.replace(typeword, \"_\".join(typeword.split(\"_\")[:-1]) + \"_([0-9]*)\")\n                mapped = mapped.replace(typeword, \"_\".join(typeword.split(\"_\")[:-1])+\"_\\\\\" + str(i+1))\n            for (R2,mapped2,T2,_) in AcquiredGrammar:\n                if R == R2 and mapped == mapped2:\n                    T = Truth_Revision(T, T2)\n                    break\n            print(\"//Induced grammar relation: \" + str((R,mapped,T)))\n            sys.stdout.flush()\n            AcquiredGrammar.append((R,mapped,T,currentTime))\n            AcquiredGrammar.sort(key=lambda T: (-Truth_Expectation(T[2]), -T[3]))\n        return True\n    return False\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "OpenNARS-for-Applications\\english_to_narsese.py/sentence_and_types",
        "OpenNARS-for-Applications\\english_to_narsese.py/Truth_Expectation",
        "OpenNARS-for-Applications\\english_to_narsese.py/Truth_Revision",
        "OpenNARS-for-Applications\\english_to_narsese.py/reduceTypetext"
      ]
    }
  },
  "OpenNARS-for-Applications\\evaluation.py": {
    "ctests": {
      "type": "FunctionDef",
      "name": "ctests",
      "md_content": [
        "**ctests**: The function of ctests is to execute a command-line test and retrieve the test results.\n\n**parameters**:\n- Example: A string representing the example being tested.\n- Args: A string containing the command-line arguments for the test.\n- DoneAfterMetric: A boolean value indicating whether the function should stop after retrieving the test metric.\n\n**Code Description**:\nThe ctests function takes three parameters: Example, Args, and DoneAfterMetric. It executes a command-line test by running the specified command with the given arguments. The test results are captured and processed to extract the relevant information.\n\nFirst, the function uses the run function from the subprocess module to execute the command specified in Args. The stdout and stderr outputs of the command are captured and stored in the result variable. The universal_newlines parameter is set to True to ensure that the captured outputs are returned as strings.\n\nNext, the function checks the returncode of the executed command. If the returncode is not 0, indicating an error, the function prints the captured stdout and stderr outputs and exits with the same returncode.\n\nIf the returncode is 0, the function iterates over the lines of the captured stdout output in reverse order. It searches for a line that contains the substring \"ratio=\". This line typically contains the test metric information.\n\nIf DoneAfterMetric is True, the function prints the example name followed by the found metric line and returns, indicating that the test is done.\n\nIf DoneAfterMetric is False, the function simply prints the found metric line.\n\nIf no metric line is found, the function prints a message indicating that the test was successful.\n\n**Note**:\n- The Args parameter should be a string containing the command-line arguments for the test. The arguments should be separated by spaces.\n- The Example parameter is used to provide context for the test. It is printed along with the metric line if DoneAfterMetric is True.\n- The function relies on the run function from the subprocess module to execute the command. Make sure the necessary dependencies are installed.\n\n**Output Example**:\nExample successful!"
      ],
      "code_start_line": 30,
      "code_end_line": 42,
      "parent": null,
      "params": [
        "Example",
        "Args",
        "DoneAfterMetric"
      ],
      "have_return": true,
      "code_content": "def ctests(Example, Args, DoneAfterMetric):\n    result = run(Args.split(\" \"), stdout=PIPE, stderr=PIPE, universal_newlines=True)\n    if result.returncode != 0:\n        print(result.stdout, result.stderr)\n        exit(result.returncode)\n    for line in reversed(result.stdout.split(\"\\n\")):\n        if \"ratio=\" in line:\n            if DoneAfterMetric:\n                print(Example + \" metrics: \" + line)\n                return\n            else:\n                print(line)\n    print(\"\\n\" + Example + \" successful!\")\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "Test": {
      "type": "FunctionDef",
      "name": "Test",
      "md_content": [
        "**Test**: The function of Test is to evaluate the performance of a test case by analyzing the output string and comparing it with the expected conditions.\n\n**parameters**:\n- Example: A string representing the name of the test case.\n- outputString: A string containing the output generated by the test case.\n\n**Code Description**:\nThe Test function begins by initializing several variables to keep track of timing, confidence, and question statistics. It then splits the outputString into individual lines and sets a flag called AnswerRatioTest to True.\n\nNext, the function iterates over each line in the outputString. For lines that start with the \"Comment: expected\" condition, the function increments the QuestionsTotal counter and the global QuestionsTotalGlobal counter. It then checks if the line is an answer condition or an execution condition.\n\nIf the line is an answer condition, the function extracts the expected output and confidence from the line. It then searches for the corresponding answer in the previous lines of the outputString. If a matching answer is found, the function increments the QuestionsAnswered counter and the global QuestionsAnsweredGlobal counter. It also calculates the maximum confidence obtained and the creation time of that answer. If the AnswerRatioTest flag is False, the function compares the obtained confidence with the expected confidence. If the obtained confidence is lower than the expected confidence, the function prints a failure message and exits.\n\nIf the line is an execution condition, the function extracts the message from the line and searches for a matching execution in the previous lines of the outputString. If a matching execution is found, the function increments the QuestionsAnswered counter and the global QuestionsAnsweredGlobal counter. If no matching execution is found, the function prints a failure message and exits.\n\nAfter processing all the lines in the outputString, the function checks the AnswerRatioTest flag. If it is True, the function prints the Q&A stress test results, including the total number of questions, the number of correctly answered questions, and the answer ratio. If it is False, the function prints the Q&A metrics, including the average answer time, the average answer confidence, and the combined loss.\n\nFinally, the function updates the global timing and confidence variables with the local values.\n\n**Note**:\n- This function is designed to evaluate the performance of a test case by comparing the output with the expected conditions.\n- The outputString should contain the output generated by the test case in the expected format.\n- The function relies on specific conditions in the outputString to identify answers and executions.\n- The function assumes that the outputString contains the relevant information for evaluation.\n- It is important to ensure that the expected conditions in the outputString are correctly formatted to avoid incorrect evaluations."
      ],
      "code_start_line": 52,
      "code_end_line": 142,
      "parent": null,
      "params": [
        "Example",
        "outputString"
      ],
      "have_return": false,
      "code_content": "def Test(Example, outputString):\n    global Timing, ConfidenceCntGlobal, ConfidenceSumGlobal, TimeSumGlobal, TimeCntGlobal, QuestionsTotalGlobal, QuestionsAnsweredGlobal\n    TimeCnt = 0.0\n    TimeSum = 0.0\n    ConfidenceCnt = 0.0\n    ConfidenceSum = 0.0\n    QuestionsTotal = 0.0\n    QuestionsAnswered = 0.0\n    expect_condition = \"Comment: expected: \"\n    expect_condition_answer = expect_condition + \"Answer: \"\n    expect_condition_execution = expect_condition + \"^\"\n    lines = outputString.split('\\n')\n    AnswerRatioTest = True\n    for i in range(len(lines)):\n        line = lines[i].strip()\n        if line.startswith(expect_condition):\n            QuestionsTotal += 1.0\n            QuestionsTotalGlobal += 1.0\n            isAnswerCondition = line.startswith(expect_condition_answer)\n            isExecutionCondition = line.startswith(expect_condition_execution)\n            if isAnswerCondition:\n                ConfidenceExpected = 0\n                ExpectedOutput = line.split(expect_condition_answer)[1].strip() + \" \"\n                if \"Truth:\" in ExpectedOutput:\n                    AnswerRatioTest = False\n                if not AnswerRatioTest:\n                    ExpectedOutput = ExpectedOutput.split(\"Truth:\")[0]\n                    TruthValue = line.split(\"Truth:\")[1]\n                    ConfidenceExpected = float(TruthValue.split(\"confidence=\")[1]) \n                FoundOutput = False\n                ConfidenceObtainedMax = 0\n                CreationTimeOfMax = 0\n                for j in reversed(range(i)): #go in reverse, don't jump over previous expects\n                    line_before = lines[j].strip()\n                    if line_before.startswith(\"Answer:\") and ExpectedOutput in line_before:\n                        ConfidenceObtained = float(line_before.split(\"confidence=\")[1])\n                        CreationTime = int(line_before.split(\"creationTime=\")[1].split(\" \")[0])\n                        if ConfidenceObtained > ConfidenceObtainedMax:\n                            ConfidenceObtainedMax = ConfidenceObtained\n                            CreationTimeOfMax = CreationTime\n                        FoundOutput = True\n                        QuestionsAnswered += 1.0\n                        QuestionsAnsweredGlobal += 1.0\n                    if line_before.startswith(expect_condition):\n                        break\n                if not AnswerRatioTest:\n                    if not FoundOutput or ConfidenceObtainedMax < ConfidenceExpected:\n                        print(\"Failure for \" + line + \" in \" + Example)\n                        exit(0)\n                    TimeSum += float(CreationTime)\n                    TimeCnt += 1.0\n                    ConfidenceSum += ConfidenceObtainedMax\n                    ConfidenceCnt += 1.0\n            if isExecutionCondition:\n                AnswerRatioTest = False\n                Message = line.split(expect_condition)[1]\n                HadAnswer = False\n                for j in reversed(range(i)):\n                    line_before = lines[j].strip()\n                    if line_before.startswith(\"^\"):\n                        if Message != line_before:\n                            print(\"Failure for \" + line + \" in \"+ Example)\n                            exit(0)\n                        else:\n                            HadAnswer = True\n                            QuestionsAnswered += 1.0\n                            QuestionsAnsweredGlobal += 1.0\n                            break\n                if not HadAnswer:\n                    print(\"Failure for \" + line + \" in \"+ Example)\n                    exit(0)\n    if AnswerRatioTest:\n        if QuestionsTotal > 0:\n            print(\"\\nQ&A stress test results for test \" + Example)\n            print(\"Total questions = \" + str(QuestionsTotal))\n            print(\"Correctly answered ones = \" + str(QuestionsAnswered))\n            print(\"Answer ratio = \" + str(QuestionsAnswered / QuestionsTotal))\n        else:\n            print(\"\\nPassed \" + Example)\n    else:\n        if TimeCnt > 0 and ConfidenceCnt > 0:\n            print(\"\\nQ&A metrics for test \" + Example)\n            print(\"Average answer time = \" + str(TimeSum/TimeCnt))\n            print(\"Average answer confidence = \" + str(ConfidenceSum/ConfidenceCnt))\n            print(\"Combined loss = \" + str((1.0 - ConfidenceSum/ConfidenceCnt) * (TimeSum/TimeCnt)))\n        else:\n            print(\"\\nPassed \" + Example)\n    TimeSumGlobal += TimeSum\n    TimeCntGlobal += TimeCnt\n    ConfidenceSumGlobal += ConfidenceSum\n    ConfidenceCntGlobal += ConfidenceCnt\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    }
  },
  "OpenNARS-for-Applications\\inspection_extract_importable_parts.py": {},
  "OpenNARS-for-Applications\\narsese_to_english.py": {
    "narseseToEnglish_noColors": {
      "type": "FunctionDef",
      "name": "narseseToEnglish_noColors",
      "md_content": [
        "**narseseToEnglish_noColors**: The function of narseseToEnglish_noColors is to initialize global variables for color codes used in the NARSese to English translation process.\n\n**parameters**:\n- No parameters are required for this function.\n\n**Code Description**:\nThe `narseseToEnglish_noColors` function is responsible for initializing global variables that store color codes used in the NARSese to English translation process. These color codes are used to add color to the translated output, but this specific function does not include the color codes. The global variables initialized in this function are `GREEN`, `YELLOW`, `CYAN`, `MAGENTA`, `RED`, `RESET`, and `BOLD`.\n\nThe purpose of these global variables is to provide a way to add color to the translated output when needed. However, in this specific implementation, the color codes are not included in the variables. Therefore, the translated output will not have any color applied to it.\n\n**Note**:\n- This function does not take any parameters.\n- The global variables initialized in this function can be used in other parts of the code to add color to the translated output if desired."
      ],
      "code_start_line": 38,
      "code_end_line": 46,
      "parent": null,
      "params": [],
      "have_return": false,
      "code_content": "def narseseToEnglish_noColors():\n    global GREEN, YELLOW, CYAN, MAGENTA, RED, RESET, BOLD\n    GREEN = \"\"\n    YELLOW = \"\"\n    CYAN = \"\"\n    MAGENTA = \"\"\n    RED = \"\"\n    RESET = \"\"\n    BOLD = \"\"\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "narseseToEnglish": {
      "type": "FunctionDef",
      "name": "narseseToEnglish",
      "md_content": [
        "**narseseToEnglish**: The function of narseseToEnglish is to convert Narsese statements into English sentences.\n\n**parameters**:\n- line: A string representing a Narsese statement.\n\n**Code Description**:\nThe `narseseToEnglish` function takes a Narsese statement as input and converts it into an English sentence. It applies a series of string manipulations and regular expressions to transform the Narsese syntax into a more readable English representation.\n\nThe function starts by defining a variable `COLOR` and setting it to the value `GREEN`. It then performs several string replacements on the input `line` to replace specific Narsese syntax with their corresponding English equivalents. For example, it replaces \"(! \" with \"not \", \"#1\" with \"it\", \"$1\" with \"it\", \"#2\" with \"thing\", and \"$2\" with \"thing\".\n\nNext, the function checks the starting pattern of the `line` to determine the appropriate color for the English sentence. If the `line` starts with \"performing \" or \"done with\", the `COLOR` is set to `CYAN`. If it starts with \"Comment: expected:\", the `COLOR` is set to a combination of `BOLD` and `MAGENTA`. If it starts with \"Comment:\" or \"//\", the `COLOR` is set to `MAGENTA`. If it starts with \"Input:\", the `COLOR` is set to `GREEN`. If it starts with \"Derived:\" or \"Revised:\", the `COLOR` is set to `YELLOW`. If it starts with \"Answer:\", \"^\", or contains the phrase \"decision expectation\", the `COLOR` is set to a combination of `BOLD` and `RED`.\n\nAfter determining the color, the function applies a series of regular expressions to transform specific Narsese syntax into their English counterparts. It replaces sets enclosed in curly braces `{}` and square brackets `[]` with the corresponding English terms, using the colors defined earlier. It also replaces image expressions enclosed in parentheses `()` with the English representation, including the color coding. Additionally, it handles implications, conjunctions, similarity, and inheritance statements, replacing them with their English equivalents.\n\nFinally, the function returns the transformed `line` with the appropriate color coding and formatting applied.\n\n**Note**:\n- The function assumes that the input `line` is a valid Narsese statement.\n- The function uses color codes to highlight different parts of the English sentence for better readability. These color codes are not actual colors but placeholders that can be replaced with the desired formatting in the output.\n\n**Output Example**:\nIf the input `line` is \"(<apple --> fruit>)\", the function will return \"apple is fruit\"."
      ],
      "code_start_line": 51,
      "code_end_line": 82,
      "parent": null,
      "params": [
        "line"
      ],
      "have_return": true,
      "code_content": "def narseseToEnglish(line):\n    COLOR = GREEN\n    line = line.rstrip().replace(\"(! \", CYAN + \"not \" + COLOR).replace(\"#1\",\"it\").replace(\"$1\",\"it\").replace(\"#2\",\"thing\").replace(\"$2\",\"thing\")\n    if line.startswith(\"performing \") or line.startswith(\"done with\"):\n        COLOR = CYAN\n    elif line.startswith(\"Comment: expected:\"):\n        COLOR = BOLD + MAGENTA\n    elif line.startswith(\"Comment:\") or line.startswith(\"//\"):\n        COLOR = MAGENTA\n    elif line.startswith(\"Input:\"):\n        COLOR = GREEN\n    elif line.startswith(\"Derived:\") or line.startswith(\"Revised:\"):\n        COLOR = YELLOW\n    elif line.startswith(\"Answer:\") or line.startswith(\"^\") or \"decision expectation\" in line:\n        COLOR = BOLD + RED\n    if not (\" | \" in line or \" \\\\1 \" in line or \" \\\\2 \" in line or \" - \" in line or \" ~ \" in line):\n        #Ext and Int set\n        l = re.sub(r\"{([^><:\\(\\)\\*]*)}\", MAGENTA+r\"\" + GREEN + r\"\\1\" + MAGENTA + \"\" + COLOR, line)\n        l = re.sub(r\"\\[([^><:\\(\\)\\*]*)\\]\", MAGENTA+r\"\" + GREEN + r\"\\1\" + MAGENTA + \"\" + COLOR, l)\n        #Image\n        l = re.sub(r\"\\(([^><:]*)\\s(/1|\\\\1|/2|\\\\1|\\\\2)\\s([^><:]*)\\)\", YELLOW+r\"\" + GREEN + r\"\\1\" + YELLOW + r\" \\2 \" + GREEN + r\"\\3\" + YELLOW + \"\" + COLOR, l)\n        #Implication\n        l = re.sub(r\"<([^:]*)\\s=(/|=|\\|)>\\s([^:]*)>\", CYAN+ STATEMENT_OPENER + GREEN + r\"\\1\" + CYAN + r\" leads to \" + GREEN + r\"\\3\" + CYAN + STATEMENT_CLOSER + COLOR, l)\n        #Conjunction\n        l = re.sub(r\"\\(([^:]*)\\s&(/|&|\\|)\\s([^:]*)\\)\", MAGENTA+r\"\" + GREEN + r\"\\1\" + MAGENTA + r\" and \" + GREEN + r\"\\3\" + MAGENTA + \"\" + COLOR, l)\n        #Similarity and inheritance\n        l = re.sub(r\"<([^><:]*)\\s(-->)\\s([^><:]*)>\", RED+ STATEMENT_OPENER + GREEN + r\"\\1\" + RED + r\" is \" + GREEN + r\"\\3\" + RED + STATEMENT_CLOSER + COLOR, l)\n        l = re.sub(r\"<([^><:]*)\\s(<->)\\s([^><:]*)>\", RED+ STATEMENT_OPENER + GREEN + r\"\\1\" + RED + r\" resembles \" + GREEN + r\"\\3\" + RED + STATEMENT_CLOSER + COLOR, l)\n        #Other compound term copulas (not higher order)\n        l = re.sub(r\"\\(([^><:]*)\\s(\\*|&)\\s([^><:]*)\\)\", YELLOW+r\"\" + GREEN + r\"\\1\" + YELLOW + r\" \" + GREEN + r\"\\3\" + YELLOW + \"\" + COLOR, l)\n        return COLOR + l.replace(\")\",\"\").replace(\"(\",\"\").replace(\"||\", MAGENTA + \"or\" + COLOR).replace(\"==>\", CYAN + \"implies\" + COLOR).replace(\"<=>\", CYAN + \"equals\" + COLOR).replace(\">\",\"\").replace(\"<\",\"\").replace(\"&/\",\"and\").replace(\" * \",\" \").replace(\" & \",\" \").replace(\" /1\",\"\").replace(\"/2\",\"by\") + RESET\n    return \"\"\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    }
  },
  "OpenNARS-for-Applications\\misc\\evaluation\\comparison.py": {
    "ctests": {
      "type": "FunctionDef",
      "name": "ctests",
      "md_content": [
        "**ctests**: The function of ctests is to run tests for the OpenNARS-for-Applications project.\n\n**parameters**:\n- branch: A string representing the branch of the project.\n- example: A string representing the example to be tested.\n- steps: An integer representing the number of steps to run the test.\n- seed: An integer representing the seed value for randomization.\n- successCriteria: A string representing the success criteria for the test.\n\n**Code Description**:\nThe ctests function is responsible for running tests for the OpenNARS-for-Applications project. It takes in several parameters including the branch of the project, the example to be tested, the number of steps to run the test, the seed value for randomization, and the success criteria for the test.\n\nFirst, the function constructs the folder path based on the provided branch. It then prints a command to build the project with the specified seed value. The os.system function is used to change the current directory to the project folder and execute the build command.\n\nNext, the function sets the base path to the current working directory and changes the directory to the project folder. Another build command is executed to ensure the project is built with the specified seed value. The base path is then restored to the original working directory.\n\nThe function constructs the command to run the test by concatenating the project path, the example, and the number of steps. It also generates a filename based on the example, branch, and seed value.\n\nThe run function is called with the constructed command as the argument. The stdout and stderr outputs are captured and stored in the result variable. If the return code of the result is not 0, indicating an error, the function prints the stdout and stderr outputs and exits with the return code.\n\nIf the test is successful, the function opens the file with the generated filename in write mode. It iterates over the reversed lines of the stdout output and writes the line to the file if it contains the specified success criteria. Finally, the function prints a success message indicating the example was successful.\n\n**Note**:\n- The ctests function assumes that the project has already been built and the necessary dependencies are installed.\n- The success criteria should be a unique identifier present in the output of the test.\n\n**Output Example**:\n```\nTest output:\nSuccess criteria met: example1=passed\nexample1 successful!\n```"
      ],
      "code_start_line": 60,
      "code_end_line": 79,
      "parent": null,
      "params": [
        "branch",
        "example",
        "steps",
        "seed",
        "successCriteria"
      ],
      "have_return": true,
      "code_content": "def ctests(branch, example, steps, seed, successCriteria):\n    folder = \"./\" + branch + \"/OpenNARS-for-Applications/\"\n    print(\"sh \" + folder + \"build.sh -DSEED=\"+str(seed))\n    os.system(\"cd \" + folder)\n    basePath = Path.cwd()\n    os.chdir(folder)\n    os.system(\"sh ./build.sh -DSEED=\"+str(seed))\n    os.chdir(basePath)\n    binAndArgs = folder + \"NAR \" + example + \" \" + str(steps)\n    filename = example + \"_\" + branch + \"_\" + str(seed) + \".txt\"\n    result = run(binAndArgs.split(\" \"), stdout=PIPE, stderr=PIPE, universal_newlines=True)\n    if result.returncode != 0:\n        print(result.stdout, result.stderr)\n        exit(result.returncode)\n    with open(filename, 'w') as f:\n        for line in reversed(result.stdout.split(\"\\n\")):\n            if successCriteria+\"=\" in line:\n                print(line)\n                f.write(line + \"\\n\")\n    print(\"\\n\" + example + \" successful!\")\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "pytests": {
      "type": "FunctionDef",
      "name": "pytests",
      "md_content": [
        "**pytests**: The function of pytests is to run a test on a specific branch of the OpenNARS-for-Applications project. It executes a command to build the project with a given seed, and then runs a Python script with specified arguments. The output of the script is captured and saved to a file, and the function checks if the output meets a specified success criteria.\n\n**parameters**:\n- branch: A string representing the name of the branch to test.\n- example: A string representing the name of the Python script to run.\n- steps: An integer specifying the number of steps to run the script.\n- seed: An integer representing the seed value for the build and test.\n- successCriteria: A string specifying the success criteria to check in the output.\n\n**Code Description**:\nThe function begins by constructing a folder path based on the provided branch name. It then prints a command to build the project with the given seed value. The function changes the current working directory to the project folder and executes the build command using the `os.system` function.\n\nNext, the function changes the current working directory to the \"misc/Python\" folder within the project. It constructs a command string to run the specified Python script with the given number of steps. The function also creates a filename based on the example name, branch name, and seed value.\n\nThe function uses the `run` function from the `subprocess` module to execute the command and capture the output. If the return code of the command is not 0 (indicating an error), the function prints the standard output and standard error, and exits with the return code.\n\nThe function then changes the current working directory back to the original base path. It opens the file with the constructed filename in write mode and iterates over the reversed lines of the captured output. If a line contains the specified success criteria, it prints the line and writes it to the file.\n\nFinally, the function prints a success message indicating that the example was successful.\n\n**Note**: \n- The function assumes that the build.sh script and the Python script are located in specific directories within the project structure.\n- The function relies on the availability of the `os` and `subprocess` modules.\n- The success criteria should be a unique string that can be found in the output.\n\n**Output Example**:\n```\nResult: success=true\nExample successful!\n```"
      ],
      "code_start_line": 82,
      "code_end_line": 102,
      "parent": null,
      "params": [
        "branch",
        "example",
        "steps",
        "seed",
        "successCriteria"
      ],
      "have_return": true,
      "code_content": "def pytests(branch, example, steps, seed, successCriteria):\n    folder = \"./\" + branch + \"/OpenNARS-for-Applications/\"\n    print(\"sh \" + folder + \"build.sh -DSEED=\"+str(seed))\n    os.system(\"cd \" + folder)\n    basePath = Path.cwd()\n    os.chdir(folder)\n    os.system(\"sh ./build.sh -DSEED=\"+str(seed))\n    os.chdir(\"./misc/Python/\")\n    binAndArgs = \"python3 \" + example + \" \" + str(steps)\n    filename = example + \"_\" + branch + \"_\" + str(seed) + \".txt\"\n    result = run(binAndArgs.split(\" \"), stdout=PIPE, stderr=PIPE, universal_newlines=True)\n    if result.returncode != 0:\n        print(result.stdout, result.stderr)\n        exit(result.returncode)\n    os.chdir(basePath)\n    with open(filename, 'w') as f:\n        for line in reversed(result.stdout.split(\"\\n\")):\n            if successCriteria+\"=\" in line:\n                print(line)\n                f.write(line + \"\\n\")\n    print(\"\\n\" + example + \" successful!\")\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    }
  },
  "OpenNARS-for-Applications\\misc\\evaluation\\plot.py": {
    "Plot": {
      "type": "FunctionDef",
      "name": "Plot",
      "md_content": [
        "**Plot**: The function of Plot is to generate a plot showing the success ratio over time for different branches of a given example.\n\n**parameters**:\n- example: A string representing the name of the example.\n- successCriteria: A string representing the success criteria to be plotted.\n\n**Code Description**:\nThe Plot function begins by creating a new figure using the `plt.figure()` function. It then sets the title of the plot to the value of the `example` parameter using `plt.title()`. The y-axis label is set to \"Success ratio\" using `plt.ylabel()`, and the x-axis label is set to \"Time\" using `plt.xlabel()`.\n\nNext, a list of colors is defined as `['g', 'y', 'r', 'b']`. Four patches are created using the `mpatches.Patch()` function, each representing a different branch. The color and label of each patch is set based on the branches list. These patches are then added to the plot legend using `plt.legend()`.\n\nA dictionary `BranchRatios` is initialized to store the success ratios for each branch at different time steps. A variable `k` is set to -1 to keep track of the current branch index.\n\nThe function then iterates over each branch in the branches list. For each branch, it iterates over each seed in the seeds list. It constructs a filename based on the example, branch, and seed. It opens the corresponding file in read mode and reads its lines. The lines are reversed using `reversed()` to process them in reverse order.\n\nFor each line, if it is empty, it is skipped. Otherwise, it extracts the success ratio value based on the `successCriteria` parameter. The ratio is converted to a float and added to the ratios list. The ratio is also added to the `BranchRatios` dictionary, grouped by branch and time step.\n\nThe success ratios for each branch are then plotted using `plt.plot()`, with the corresponding color from the colors list.\n\nNext, the function iterates over each branch again. It increments `k` to get the next color from the colors list. For each time step, it calculates the average success ratio for the branch and adds it to the `BranchRatioAvgs` list. The average success ratios for each branch are then plotted using `plt.plot()`.\n\nFinally, the plot is saved as a PNG file with the name based on the example using `plt.savefig()`.\n\n**Note**: This function assumes that the `branches` and `seeds` lists are defined and contain the necessary values. It also assumes that there are text files with the naming convention \"example_branch_seed.txt\" containing the success ratio values for each branch and seed."
      ],
      "code_start_line": 43,
      "code_end_line": 84,
      "parent": null,
      "params": [
        "example",
        "successCriteria"
      ],
      "have_return": false,
      "code_content": "def Plot(example, successCriteria):\n    plt.figure()\n    plt.title(example)\n    plt.ylabel(\"Success ratio\")\n    plt.xlabel(\"Time\")\n    colors = ['g', 'y', 'r', 'b']\n    p1 = mpatches.Patch(color = \"green\", label = branches[0])\n    p2 = mpatches.Patch(color = \"yellow\", label = branches[1])\n    p3 = mpatches.Patch(color = \"red\", label = branches[0] + \" avg.\")\n    p4 = mpatches.Patch(color = \"blue\", label = branches[1] + \" avg.\")\n    plt.legend(handles=[p1, p2, p3, p4])\n    BranchRatios = {}\n    k=-1\n    for Branch in branches:\n        k+=1\n        for seed in seeds:\n            filename = example + \"_\" + Branch + \"_\" + str(seed)\n            with open(filename + \".txt\", 'r') as f:\n                lines = f.readlines()\n            lines = reversed(lines)\n            ratios = []\n            t = 0\n            for l in lines:\n                if l.strip() == \"\":\n                    continue\n                t += 1\n                ratio = float(l.split(successCriteria+\"=\")[1].split(\" \")[0].split(\",\")[0].replace(\"-nan\",\"0\").replace(\"nan\",\"0\"))\n                ratios.append(ratio)\n                if Branch not in BranchRatios:\n                    BranchRatios[Branch] = {}\n                if t not in BranchRatios[Branch]:\n                    BranchRatios[Branch][t] = []\n                BranchRatios[Branch][t].append(ratio)\n            plt.plot(ratios, colors[k])\n    for Branch in branches:\n        k += 1\n        BranchRatioAvgs = []\n        for t in range(1, 1+len(BranchRatios[Branch])):\n            BranchRatioAvg = sum(BranchRatios[Branch][t]) / float(len(BranchRatios[Branch][t]))\n            BranchRatioAvgs.append(BranchRatioAvg)\n        plt.plot(BranchRatioAvgs, colors[k])\n    plt.savefig(example + \".png\")\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    }
  },
  "OpenNARS-for-Applications\\misc\\evaluation\\visualize_demo_run.py": {},
  "OpenNARS-for-Applications\\misc\\Networking\\irc_nar.py": {
    "encode": {
      "type": "FunctionDef",
      "name": "encode",
      "md_content": [
        "**encode**: The function of encode is to encode a given string into UTF-8 format.\n\n**parameters**:\n- st: A string that needs to be encoded.\n\n**Code Description**:\nThe `encode` function takes a string `st` as input and encodes it into UTF-8 format. The function first checks the value of the variable `version`. If `version` is equal to 2, the function simply returns the input string `st` as it is. Otherwise, if `version` is not equal to 2, the function encodes the string `st` using the `encode` method with the parameter \"utf-8\". The encoded string is then returned as the output.\n\nThe purpose of this function is to ensure that the string is encoded in UTF-8 format, which is a widely used character encoding for Unicode.\n\nThis function is called by the `receive_thread` function in the `irc_nar.py` file. In the `receive_thread` function, the `encode` function is used to encode the message before sending it over the IRC connection. This ensures that the message is properly encoded and can be correctly interpreted by the recipient.\n\n**Note**:\n- The `version` variable is not defined within the `encode` function. It should be defined and assigned a value before calling the `encode` function to ensure proper functionality.\n- The `encode` function assumes that the default encoding is UTF-8. If a different encoding is desired, the encoding parameter in the `encode` method can be modified accordingly.\n\n**Output Example**:\nIf the input string `st` is \"Hello, world!\", the output of the `encode` function would be the UTF-8 encoded representation of the string."
      ],
      "code_start_line": 44,
      "code_end_line": 48,
      "parent": null,
      "params": [
        "st"
      ],
      "have_return": true,
      "code_content": "def encode(st):\n    if version == 2:\n        return st\n    else:\n        return st.encode(\"utf-8\")\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Networking\\irc_nar.py/receive_thread"
      ],
      "reference_who": []
    },
    "decode": {
      "type": "FunctionDef",
      "name": "decode",
      "md_content": [
        "**decode**: The function of decode is to convert a string from bytes to Unicode.\n\n**parameters**:\n- st: The string to be decoded.\n\n**Code Description**:\nThe `decode` function takes a string `st` as input and converts it from bytes to Unicode. It first checks the value of the `version` variable. If `version` is equal to 2, the function returns the input string `st` as it is, assuming it is already in Unicode format. Otherwise, if `version` is not equal to 2, the function uses the `decode` method with the \"utf-8\" encoding to convert the string `st` from bytes to Unicode.\n\n**Note**:\n- The `version` variable is not defined in the given code snippet. It is assumed that it is defined elsewhere in the code.\n- The \"utf-8\" encoding is used for decoding the string. If the string `st` is not encoded using the \"utf-8\" encoding, the decoding process may result in an error.\n\n**Output Example**:\nIf `version` is equal to 2:\n```\ndecode(\"Hello\") -> \"Hello\"\n```\nIf `version` is not equal to 2:\n```\ndecode(b\"Hello\") -> \"Hello\"\n```"
      ],
      "code_start_line": 50,
      "code_end_line": 54,
      "parent": null,
      "params": [
        "st"
      ],
      "have_return": true,
      "code_content": "def decode(st):\n    if version == 2:\n        return st\n    else:\n        return st.decode(\"utf-8\")\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "receive_thread": {
      "type": "FunctionDef",
      "name": "receive_thread",
      "md_content": [
        "**receive_thread**: The function of receive_thread is to continuously receive messages from a process and send them over an IRC connection.\n\n**parameters**:\n- a: The process from which messages are received.\n\n**Code Description**:\nThe `receive_thread` function is a loop that runs indefinitely. Within the loop, it reads a line of output from the `proc` process and assigns it to the variable `msg`. \n\nNext, the function checks if `msg` is not empty and if it contains any of the elements in the `Narsese_Filter` list. If both conditions are true, it prints the message with the prefix \"NAR output: \".\n\nFinally, the function sends the encoded message over the IRC connection using the `irc.send` function. The message is encoded using the `encode` function, which ensures that the message is properly encoded in UTF-8 format.\n\nThe purpose of the `receive_thread` function is to continuously receive messages from the `proc` process and send them over the IRC connection. It filters the received messages based on the `Narsese_Filter` list and only sends the messages that match the filter.\n\nThis function is called within the `irc_nar.py` file and is typically used as a separate thread to continuously receive and send messages in the background.\n\n**Note**:\n- The `proc` process should be defined and passed as an argument to the `receive_thread` function before calling it.\n- The `Narsese_Filter` list should be defined and populated with the desired filter elements before calling the `receive_thread` function.\n- The `irc.send` function should be properly configured and connected to the IRC server before calling the `receive_thread` function.\n- The `encode` function is used to encode the message before sending it over the IRC connection. Ensure that the `encode` function is properly defined and imported before calling the `receive_thread` function.\n- The `encode` function assumes that the default encoding is UTF-8. If a different encoding is desired, the encoding parameter in the `encode` method can be modified accordingly."
      ],
      "code_start_line": 67,
      "code_end_line": 72,
      "parent": null,
      "params": [
        "a"
      ],
      "have_return": false,
      "code_content": "def receive_thread(a):\n    while True:\n       msg=proc.stdout.readline()\n       if msg!=None and msg!=\"\" and True in [u in msg for u in Narsese_Filter]:\n          print(\"NAR output: \"+msg)\n          irc.send(encode(\"PRIVMSG \"+ channel +\" : \"+msg+\"\\r\\n\"))\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Networking\\irc_nar.py/encode"
      ]
    }
  },
  "OpenNARS-for-Applications\\misc\\Networking\\irc_receive.py": {
    "encode": {
      "type": "FunctionDef",
      "name": "encode",
      "md_content": [
        "**encode**: The function of encode is to convert a string to bytes using the UTF-8 encoding.\n\n**parameters**:\n- st: The string to be encoded.\n\n**Code Description**:\nThe `encode` function takes a string `st` as input and checks the value of the `version` variable. If the `version` is equal to 2, the function returns the input string as it is. Otherwise, it encodes the string using the UTF-8 encoding and returns the encoded bytes.\n\nThe function first checks if the `version` variable is equal to 2. If it is, it means that the encoding should not be performed and the function simply returns the input string `st`. This is useful when the code is running in a Python 2 environment where strings are already represented as bytes.\n\nIf the `version` variable is not equal to 2, it means that the code is running in a Python 3 environment where strings are represented as Unicode objects. In this case, the function uses the `encode` method of the string object to encode the string using the UTF-8 encoding. The UTF-8 encoding is a widely used encoding that can represent any Unicode character using variable-length sequences of bytes. The `encode` method returns the encoded bytes.\n\n**Note**:\n- The `version` variable is not defined in the code snippet provided. It is assumed that the variable is defined elsewhere in the code and its value determines whether the encoding should be performed or not.\n- The `encode` function assumes that the input string `st` is already in a Unicode format. If the input string is not in a Unicode format, it may raise a `UnicodeEncodeError`.\n\n**Output Example**:\nIf the `version` variable is equal to 2:\n```\nencode(\"Hello World\") => \"Hello World\"\n```\n\nIf the `version` variable is not equal to 2:\n```\nencode(\"Hello World\") => b\"Hello World\"\n```"
      ],
      "code_start_line": 36,
      "code_end_line": 40,
      "parent": null,
      "params": [
        "st"
      ],
      "have_return": true,
      "code_content": "def encode(st):\n    if version == 2:\n        return st\n    else:\n        return st.encode(\"utf-8\")\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "decode": {
      "type": "FunctionDef",
      "name": "decode",
      "md_content": [
        "**decode**: The function of decode is to convert a string from bytes to Unicode.\n\n**parameters**:\n- st: The string to be decoded.\n\n**Code Description**:\nThe `decode` function takes a string `st` as input and checks the value of the `version` variable. If the `version` is equal to 2, the function returns the input string as it is. Otherwise, it decodes the input string using the \"utf-8\" encoding and returns the decoded Unicode string.\n\nThe purpose of this function is to ensure that the input string is in Unicode format, which is the standard format for text in Python 3. In Python 2, strings were represented as bytes by default, but in Python 3, strings are represented as Unicode characters. Therefore, when working with strings that are encoded in a different format, such as UTF-8, it is necessary to decode them into Unicode before performing any operations on them.\n\nThe `decode` function uses the `decode` method of the string object to perform the decoding. The `decode` method takes an encoding as an argument and returns the decoded string. In this case, the encoding used is \"utf-8\", which is a widely used encoding for Unicode characters.\n\n**Note**:\n- It is important to ensure that the `version` variable is correctly set before calling the `decode` function. If the `version` is not set correctly, the function may not behave as expected.\n- The `decode` function assumes that the input string is encoded in UTF-8. If the input string is encoded in a different format, the function may not be able to decode it correctly.\n\n**Output Example**:\nIf the input string is \"Hello, World!\", the `decode` function will return the same string \"Hello, World!\" if the `version` is set to 2. If the `version` is not 2, the function will decode the string using UTF-8 and return the Unicode representation of the string."
      ],
      "code_start_line": 42,
      "code_end_line": 46,
      "parent": null,
      "params": [
        "st"
      ],
      "have_return": true,
      "code_content": "def decode(st):\n    if version == 2:\n        return st\n    else:\n        return st.decode(\"utf-8\")\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    }
  },
  "OpenNARS-for-Applications\\misc\\Networking\\irc_send.py": {
    "encode": {
      "type": "FunctionDef",
      "name": "encode",
      "md_content": [
        "**encode**: The function of encode is to encode a string into bytes using the UTF-8 encoding.\n\n**parameters**:\n- st: A string that needs to be encoded.\n\n**Code Description**:\nThe `encode` function takes a string `st` as input and encodes it into bytes using the UTF-8 encoding. The function first checks the value of the `version` variable. If `version` is equal to 2, the function returns the input string `st` as it is. Otherwise, it encodes the string `st` using the UTF-8 encoding and returns the encoded bytes.\n\nThe purpose of encoding the string is to ensure that it can be transmitted or stored correctly, especially when dealing with different character encodings or network protocols that require specific encoding formats.\n\nIn the given code snippet, the `encode` function is called within the `receive_thread` function. The `receive_thread` function is responsible for receiving messages and sending them over an IRC connection. When sending a message, the `encode` function is used to encode the message string before sending it.\n\n**Note**:\n- The `version` variable is not defined within the `encode` function. It is assumed that the `version` variable is defined and accessible from the calling context.\n- The `encode` function assumes that the default encoding is UTF-8. If a different encoding is required, the code can be modified accordingly.\n\n**Output Example**:\nIf the input string `st` is \"Hello, World!\", the `encode` function will return the encoded bytes: b'Hello, World!'."
      ],
      "code_start_line": 41,
      "code_end_line": 45,
      "parent": null,
      "params": [
        "st"
      ],
      "have_return": true,
      "code_content": "def encode(st):\n    if version == 2:\n        return st\n    else:\n        return st.encode(\"utf-8\")\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Networking\\irc_send.py/receive_thread"
      ],
      "reference_who": []
    },
    "decode": {
      "type": "FunctionDef",
      "name": "decode",
      "md_content": [
        "**decode**: The function of decode is to convert a string from bytes to Unicode.\n\n**parameters**:\n- st: The string to be decoded.\n\n**Code Description**:\nThe `decode` function takes a string `st` as input and checks the value of the `version` variable. If the `version` is equal to 2, the function returns the input string `st` as it is. Otherwise, if the `version` is not equal to 2, the function decodes the input string `st` using the \"utf-8\" encoding and returns the decoded string.\n\nThe purpose of this function is to handle the decoding of strings based on the value of the `version` variable. If the `version` is 2, it assumes that the string is already in Unicode format and returns it as is. If the `version` is not 2, it assumes that the string is in bytes format and needs to be decoded using the \"utf-8\" encoding to convert it to Unicode.\n\n**Note**:\n- The `version` variable is not defined within the scope of the `decode` function. It should be defined and assigned a value before calling the `decode` function.\n- The `decode` function assumes that the input string `st` is encoded using the \"utf-8\" encoding. If the input string is encoded using a different encoding, the function may not produce the expected result.\n\n**Output Example**:\nIf the `version` is 2:\n```\ndecode(\"Hello\") => \"Hello\"\n```\nIf the `version` is not 2:\n```\ndecode(b\"Hello\") => \"Hello\"\n```"
      ],
      "code_start_line": 47,
      "code_end_line": 51,
      "parent": null,
      "params": [
        "st"
      ],
      "have_return": true,
      "code_content": "def decode(st):\n    if version == 2:\n        return st\n    else:\n        return st.decode(\"utf-8\")\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "receive_thread": {
      "type": "FunctionDef",
      "name": "receive_thread",
      "md_content": [
        "**receive_thread**: The function of receive_thread is to continuously receive user input messages and send them over an IRC connection.\n\n**parameters**:\n- a: This parameter is not used in the function and can be ignored.\n\n**Code Description**:\nThe `receive_thread` function is a loop that continuously receives user input messages using the `input()` function. The received message is then stripped of any trailing newline characters using the `rstrip(\"\\n\")` method. \n\nNext, the function checks if the received message is not equal to `None` and not an empty string. If the condition is true, the function calls the `encode` function to encode the message string using the UTF-8 encoding. The encoded message is then sent over the IRC connection using the `irc.send()` function.\n\nThe purpose of the `receive_thread` function is to provide a continuous input mechanism for users to send messages over an IRC connection. By running this function in a separate thread, it allows for simultaneous sending and receiving of messages.\n\n**Note**:\n- The `irc` object used in the `receive_thread` function is not defined within the code snippet provided. It is assumed that the `irc` object is defined and accessible from the calling context.\n- The `encode` function is called within the `receive_thread` function to encode the message string before sending it over the IRC connection. The `encode` function is assumed to be defined and accessible from the calling context.\n- The `receive_thread` function does not have any error handling or termination conditions. It will continue running indefinitely until manually stopped or interrupted.\n\n**Output Example**:\nIf the user enters the message \"Hello, World!\" when prompted, the `receive_thread` function will encode the message using the `encode` function and send it over the IRC connection."
      ],
      "code_start_line": 60,
      "code_end_line": 64,
      "parent": null,
      "params": [
        "a"
      ],
      "have_return": false,
      "code_content": "def receive_thread(a):\n    while True:\n       msg=input().rstrip(\"\\n\")\n       if msg!=None and msg!=\"\":\n          irc.send(encode(\"PRIVMSG \"+ channel +\" : \"+msg+\"\\r\\n\"))\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Networking\\irc_send.py/encode"
      ]
    }
  },
  "OpenNARS-for-Applications\\misc\\Networking\\udp_toothbrush.py": {},
  "OpenNARS-for-Applications\\misc\\Python\\blocks.py": {
    "sim_step": {
      "type": "FunctionDef",
      "name": "sim_step",
      "md_content": [
        "**sim_step**: The function of sim_step is to simulate a step in a block world environment. \n\n**parameters**:\n- None\n\n**Code Description**:\nThe sim_step function is responsible for simulating a step in a block world environment. It iterates through a list of objects and their locations. For each object, it determines the relative location of the object with respect to the self position. It then calls the AddInput function from the NAR module to add a Narsese input representing the object and its relative location to the NAR system.\n\nAfter adding the inputs, the function calls the AddInput function again to add a Narsese input \"G! :|:\" to the NAR system. It retrieves the executions from the output of the AddInput function and appends them to the executions list. It then adds another Narsese input \"10\" to the NAR system and retrieves the executions again, appending them to the executions list.\n\nIf there are any executions in the list, the function checks the operator of the first execution. If the operator is \"^left\", it updates the self position to \"left\" if the current self position is \"centered\", or to \"centered\" if the current self position is \"right\". If the operator is \"^right\", it updates the self position to \"right\" if the current self position is \"centered\", or to \"centered\" if the current self position is \"left\".\n\n**Note**:\n- This function assumes that the objects and selfpos variables are defined and accessible within the same module.\n- The function relies on the AddInput function from the NAR module to communicate with the NAR system.\n- The function assumes that the NAR system is already running and its standard input and output streams are accessible.\n- The function assumes that the AddInput function is defined and accessible within the same module as the sim_step function."
      ],
      "code_start_line": 43,
      "code_end_line": 65,
      "parent": null,
      "params": [],
      "have_return": false,
      "code_content": "def sim_step():\n    global selfpos\n    for (obj, location) in objects:\n        relLoc = \"centered\"\n        if (selfpos == \"left\" and (location == \"centered\" or location == \"right\")) or (selfpos == \"centered\" and location == \"right\"):\n            relLoc = \"right\"\n        if (selfpos == \"right\" and (location == \"centered\" or location == \"left\")) or (selfpos == \"centered\" and location == \"left\"):\n            relLoc = \"left\"\n        NAR.AddInput(\"<%s --> [%s]>. :|:\" % (obj, relLoc))\n    executions = NAR.AddInput(\"G! :|:\")[\"executions\"]\n    executions += NAR.AddInput(\"10\")[\"executions\"]\n    if len(executions) > 0:\n        op = executions[0][\"operator\"]\n        if op == \"^left\":\n            if selfpos == \"centered\":\n                selfpos = \"left\"\n            elif selfpos == \"right\":\n                selfpos = \"centered\"\n        elif op == \"^right\":\n            if selfpos == \"centered\":\n                selfpos = \"right\"\n            elif selfpos == \"left\":\n                selfpos = \"centered\"\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR.py/AddInput"
      ]
    }
  },
  "OpenNARS-for-Applications\\misc\\Python\\Classifiers.py": {
    "AdaptiveHypersphereClassifier": {
      "type": "ClassDef",
      "name": "AdaptiveHypersphereClassifier",
      "md_content": [
        "**AdaptiveHypersphereClassifier**: The function of AdaptiveHypersphereClassifier is to classify input data points into different categories based on a set of prototypes.\n\n**attributes**:\n- spheresize: The radius of the hypersphere used to determine the proximity of a data point to a prototype. Default value is 0.1.\n- adaptation: The rate at which the prototypes adapt to new data points. Default value is 0.01.\n- maxPrototypes: The maximum number of prototypes to be maintained. Default value is 10.\n\n**Code Description**:\nThe AdaptiveHypersphereClassifier class implements a classifier that uses adaptive hyperspheres to classify input data points. The classifier maintains a set of prototypes, which are data points that represent different categories. The class provides methods to calculate the category of a given data point, observe new data points, and return the classification result in a Narsese format.\n\nThe `__init__` method initializes the classifier with the specified spheresize, adaptation, and maxPrototypes values. It also initializes an empty list to store the prototypes.\n\nThe `returnedPrototype` method is a helper method that returns the index of the prototype if there is more than one prototype, otherwise it returns -1 indicating that there is no way to make a distinction with just one prototype.\n\nThe `calc` method takes a data point as input and calculates its category based on the proximity to the prototypes. It iterates over the prototypes and calculates the Euclidean distance between each prototype and the input data point. If the distance is less than the spheresize and smaller than the closest distance found so far, the index of the closest prototype is updated. If a closest prototype is found, its position is updated using the adaptation rate. If no closest prototype is found, the input data point is added as a new prototype. If the number of prototypes exceeds the maximum allowed, the oldest prototype is removed. Finally, the method returns the index of the prototype or -1 if no prototype is found.\n\nThe `observe` method takes a data point and an optional name as input and returns the classification result in a Narsese format. The method calls the `calc` method to determine the category of the data point and formats the result using the provided name.\n\n**Note**: \n- The classifier uses Euclidean distance to measure the proximity between data points and prototypes.\n- The adaptation rate determines how quickly the prototypes adapt to new data points.\n- The maximum number of prototypes limits the memory usage of the classifier.\n\n**Output Example**:\nIf the `calc` method returns 2 and the provided name is \"apple\", the `observe` method will return the following Narsese format: \"<2 --> [apple]>. :|:\""
      ],
      "code_start_line": 27,
      "code_end_line": 53,
      "parent": null,
      "params": [],
      "have_return": true,
      "code_content": "class AdaptiveHypersphereClassifier:\n  def __init__(self, spheresize = 0.1, adaptation = 0.01, maxPrototypes=10):\n    self.prototypes = []\n    self.spheresize = spheresize\n    self.adaptation = adaptation\n    self.maxPrototypes = maxPrototypes\n  def returnedPrototype(self, prototype):\n    if len(self.prototypes) == 1:\n      return -1 #no way to make distinction with just 1 prototype\n    return prototype\n  def calc(self, x):\n    closest_i = -1\n    closest_dist = float(\"inf\")\n    for i, prot in enumerate(self.prototypes):\n      dist = np.linalg.norm(prot - x)\n      if np.linalg.norm(prot - x) < self.spheresize and dist < closest_dist:\n        closest_i = i\n        closest_dist = dist\n    if closest_i != -1:\n      self.prototypes[closest_i] = self.prototypes[closest_i] + (x - self.prototypes[closest_i]) * self.adaptation \n      return self.returnedPrototype(closest_i)\n    self.prototypes.append(x)\n    self.prototypes = self.prototypes[-self.maxPrototypes:]\n    return self.returnedPrototype(len(self.prototypes)-1)\n  def observe(self, x, name = \"\"):\n    narsese = \"%d%s. :|:\" if name == \"\" else \"<%d --> [%s]>. :|:\"\n    return [narsese % (self.calc(x), name)]\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "__init__": {
      "type": "FunctionDef",
      "name": "__init__",
      "md_content": [
        "**__init__**: The function of __init__ is to initialize the AdaptiveHypersphereClassifier object with the given parameters.\n\n**parameters**:\n- spheresize: A float value representing the size of the hypersphere.\n- adaptation: A float value representing the adaptation rate.\n- maxPrototypes: An integer value representing the maximum number of prototypes.\n\n**Code Description**:\nThe __init__ function initializes the AdaptiveHypersphereClassifier object by setting the initial values for the spheresize, adaptation, and maxPrototypes attributes. It also initializes an empty list called prototypes.\n\nThe spheresize parameter determines the size of the hypersphere used for classification. A smaller spheresize value will result in a more precise classification, while a larger value will result in a more general classification.\n\nThe adaptation parameter determines the rate at which the classifier adapts to new data. A higher adaptation value will result in faster adaptation, while a lower value will result in slower adaptation.\n\nThe maxPrototypes parameter determines the maximum number of prototypes that can be stored by the classifier. When the number of prototypes exceeds this limit, the oldest prototypes will be removed to make space for new ones.\n\n**Note**:\n- It is recommended to choose appropriate values for the spheresize, adaptation, and maxPrototypes parameters based on the specific requirements of the classification task.\n- The spheresize and adaptation values can be adjusted during the classification process to fine-tune the classifier's performance.\n- The prototypes attribute can be accessed and modified directly if needed."
      ],
      "code_start_line": 28,
      "code_end_line": 32,
      "parent": "AdaptiveHypersphereClassifier",
      "params": [
        "self",
        "spheresize",
        "adaptation",
        "maxPrototypes"
      ],
      "have_return": false,
      "code_content": "  def __init__(self, spheresize = 0.1, adaptation = 0.01, maxPrototypes=10):\n    self.prototypes = []\n    self.spheresize = spheresize\n    self.adaptation = adaptation\n    self.maxPrototypes = maxPrototypes\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "returnedPrototype": {
      "type": "FunctionDef",
      "name": "returnedPrototype",
      "md_content": [
        "**returnedPrototype**: The function of returnedPrototype is to return the index of the prototype that is closest to the input data point.\n\n**parameters**:\n- prototype: The input data point for which the closest prototype needs to be determined.\n\n**Code Description**:\nThe returnedPrototype function is a method of the AdaptiveHypersphereClassifier class in the Classifiers.py file. This function takes an input data point called \"prototype\" and returns the index of the closest prototype from the list of prototypes stored in the class.\n\nThe function first checks if the number of prototypes is equal to 1. If it is, the function returns -1, indicating that there is no way to make a distinction with just one prototype.\n\nIf there are more than one prototype, the function returns the index of the prototype that is closest to the input data point. The index is determined based on the Euclidean distance between each prototype and the input data point. The prototype with the smallest distance is considered the closest.\n\n**Note**: \n- The function assumes that the prototypes are stored in the \"prototypes\" attribute of the AdaptiveHypersphereClassifier class.\n- The function assumes that the input data point and the prototypes are in the same dimensional space.\n\n**Output Example**:\nIf the input data point is [1, 2, 3] and the prototypes are [[4, 5, 6], [7, 8, 9], [1, 2, 3]], the function will return 2, indicating that the prototype at index 2 ([1, 2, 3]) is the closest to the input data point."
      ],
      "code_start_line": 33,
      "code_end_line": 36,
      "parent": "AdaptiveHypersphereClassifier",
      "params": [
        "self",
        "prototype"
      ],
      "have_return": true,
      "code_content": "  def returnedPrototype(self, prototype):\n    if len(self.prototypes) == 1:\n      return -1 #no way to make distinction with just 1 prototype\n    return prototype\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\Classifiers.py/AdaptiveHypersphereClassifier/calc"
      ],
      "reference_who": []
    },
    "calc": {
      "type": "FunctionDef",
      "name": "calc",
      "md_content": [
        "**calc**: The function of calc is to calculate the index of the prototype that is closest to the input data point and update the prototypes accordingly.\n\n**parameters**:\n- x: The input data point for which the closest prototype needs to be determined.\n\n**Code Description**:\nThe calc function is a method of the AdaptiveHypersphereClassifier class in the Classifiers.py file. This function takes an input data point called \"x\" and calculates the index of the closest prototype from the list of prototypes stored in the class.\n\nThe function iterates over each prototype in the list and calculates the Euclidean distance between the prototype and the input data point using the np.linalg.norm() function. It then compares the calculated distance with the current closest distance. If the calculated distance is smaller than the spheresize and smaller than the current closest distance, the closest_i variable is updated with the index of the current prototype and the closest_dist variable is updated with the calculated distance.\n\nAfter iterating through all the prototypes, the function checks if a closest prototype was found by comparing closest_i with -1. If a closest prototype was found, the function updates the closest prototype by applying the adaptation formula: self.prototypes[closest_i] = self.prototypes[closest_i] + (x - self.prototypes[closest_i]) * self.adaptation. The function then returns the index of the closest prototype by calling the returnedPrototype() function.\n\nIf no closest prototype was found, the function appends the input data point to the list of prototypes and ensures that the list does not exceed the maximum number of prototypes specified by the maxPrototypes attribute. Finally, the function returns the index of the last added prototype by calling the returnedPrototype() function.\n\n**Note**: \n- The function assumes that the prototypes are stored in the \"prototypes\" attribute of the AdaptiveHypersphereClassifier class.\n- The function assumes that the input data point and the prototypes are in the same dimensional space.\n\n**Output Example**:\nIf the input data point is [1, 2, 3] and the prototypes are [[4, 5, 6], [7, 8, 9], [1, 2, 3]], the function will update the prototype at index 2 ([1, 2, 3]) and return 2, indicating that the updated prototype is the closest to the input data point."
      ],
      "code_start_line": 37,
      "code_end_line": 50,
      "parent": "AdaptiveHypersphereClassifier",
      "params": [
        "self",
        "x"
      ],
      "have_return": true,
      "code_content": "  def calc(self, x):\n    closest_i = -1\n    closest_dist = float(\"inf\")\n    for i, prot in enumerate(self.prototypes):\n      dist = np.linalg.norm(prot - x)\n      if np.linalg.norm(prot - x) < self.spheresize and dist < closest_dist:\n        closest_i = i\n        closest_dist = dist\n    if closest_i != -1:\n      self.prototypes[closest_i] = self.prototypes[closest_i] + (x - self.prototypes[closest_i]) * self.adaptation \n      return self.returnedPrototype(closest_i)\n    self.prototypes.append(x)\n    self.prototypes = self.prototypes[-self.maxPrototypes:]\n    return self.returnedPrototype(len(self.prototypes)-1)\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\Classifiers.py/AdaptiveHypersphereClassifier/observe"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\Classifiers.py/AdaptiveHypersphereClassifier/returnedPrototype"
      ]
    },
    "observe": {
      "type": "FunctionDef",
      "name": "observe",
      "md_content": [
        "**observe**: The function of observe is to calculate the index of the prototype that is closest to the input data point and return it as a Narsese statement.\n\n**parameters**:\n- x: The input data point for which the closest prototype needs to be determined.\n- name (optional): The name of the prototype.\n\n**Code Description**:\nThe observe function is a method of the AdaptiveHypersphereClassifier class in the Classifiers.py file. This function takes an input data point called \"x\" and an optional name parameter. It uses the calc function to calculate the index of the closest prototype to the input data point and generates a Narsese statement based on the result.\n\nThe function first checks if the name parameter is empty. If it is, it creates a Narsese statement template using the format \"%d%s. :|:\". Otherwise, it creates a Narsese statement template using the format \"<%d --> [%s]>. :|:\". The %d and %s placeholders in the template will be replaced with the calculated index and the name parameter, respectively.\n\nThe function then calls the calc function with the input data point to get the index of the closest prototype. It uses this index and the name parameter to generate the final Narsese statement by replacing the placeholders in the template.\n\nFinally, the function returns the generated Narsese statement as a list.\n\n**Note**: \n- The function assumes that the calc function is defined and accessible within the same class.\n- The function assumes that the calc function returns the index of the closest prototype.\n- The function assumes that the Narsese statement format is compatible with the NARS (Non-Axiomatic Reasoning System) framework.\n\n**Output Example**:\nIf the input data point is [1, 2, 3] and the name parameter is \"example\", the function will calculate the index of the closest prototype using the calc function and generate the Narsese statement \"<2 --> [example]>. :|:\". The function will return this statement as a list."
      ],
      "code_start_line": 51,
      "code_end_line": 53,
      "parent": "AdaptiveHypersphereClassifier",
      "params": [
        "self",
        "x",
        "name"
      ],
      "have_return": true,
      "code_content": "  def observe(self, x, name = \"\"):\n    narsese = \"%d%s. :|:\" if name == \"\" else \"<%d --> [%s]>. :|:\"\n    return [narsese % (self.calc(x), name)]\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\Classifiers.py/AdaptiveHypersphereClassifier/calc"
      ]
    }
  },
  "OpenNARS-for-Applications\\misc\\Python\\conditioning.py": {
    "printloud": {
      "type": "FunctionDef",
      "name": "printloud",
      "md_content": [
        "**printloud**: The function of printloud is to print the value of the variable 'x' if the variable 'loud' is True.\n\n**parameters**:\n- x: This is an optional parameter that represents the value to be printed. If no value is provided, an empty string will be printed.\n\n**Code Description**:\nThe code defines a function called printloud that takes an optional parameter 'x'. Inside the function, there is an if statement that checks if the variable 'loud' is True. If it is, the value of 'x' is printed using the print() function.\n\n**Note**:\n- It is assumed that the variable 'loud' is defined and has a boolean value before calling the printloud function. If 'loud' is False, nothing will be printed.\n- If no value is provided for 'x', an empty string will be printed."
      ],
      "code_start_line": 8,
      "code_end_line": 10,
      "parent": null,
      "params": [
        "x"
      ],
      "have_return": false,
      "code_content": "def printloud(x=\"\"):\n    if loud:\n        print(x)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    }
  },
  "OpenNARS-for-Applications\\misc\\Python\\count_sheep.py": {
    "count": {
      "type": "FunctionDef",
      "name": "count",
      "md_content": [
        "**count**: The function of count is to increment the value of the global variable `cnt` by 1 if the `executions` list is not empty.\n\n**parameters**:\n- `executions`: A list of executions.\n\n**Code Description**:\nThe `count` function takes a list of executions as input. It first checks if the length of the `executions` list is greater than 0. If it is, the function increments the value of the global variable `cnt` by 1.\n\n**Note**:\n- The `cnt` variable is assumed to be defined and accessible in the global scope.\n- This function does not return any value. It only modifies the value of the `cnt` variable."
      ],
      "code_start_line": 34,
      "code_end_line": 37,
      "parent": null,
      "params": [
        "executions"
      ],
      "have_return": false,
      "code_content": "def count(executions):\n    global cnt\n    if len(executions) > 0:\n        cnt += 1\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    }
  },
  "OpenNARS-for-Applications\\misc\\Python\\discriminativefunction.py": {
    "printloud": {
      "type": "FunctionDef",
      "name": "printloud",
      "md_content": [
        "**printloud**: The function of printloud is to print the value of the variable x if the variable \"loud\" is set to True.\n\n**parameters**:\n- x (optional): The value to be printed. Default value is an empty string.\n\n**Code Description**:\nThe printloud function is a simple utility function that prints the value of the variable x if the variable \"loud\" is set to True. It takes an optional parameter x, which represents the value to be printed. If no value is provided for x, it defaults to an empty string.\n\nThe function first checks the value of the variable \"loud\". If \"loud\" is True, it proceeds to print the value of x using the print() function. If \"loud\" is False, the function does nothing.\n\n**Note**:\n- The behavior of this function depends on the value of the variable \"loud\". Make sure to set \"loud\" to True if you want the function to print the value of x.\n- If no value is provided for x, the function will print an empty string."
      ],
      "code_start_line": 8,
      "code_end_line": 10,
      "parent": null,
      "params": [
        "x"
      ],
      "have_return": false,
      "code_content": "def printloud(x=\"\"):\n    if loud:\n        print(x)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    }
  },
  "OpenNARS-for-Applications\\misc\\Python\\distributedNAR.py": {
    "selectOfPunctuation": {
      "type": "FunctionDef",
      "name": "selectOfPunctuation",
      "md_content": [
        "**selectOfPunctuation**: The function of selectOfPunctuation is to filter a list of selections based on a specified punctuation value.\n\n**parameters**:\n- selections: A list of selections, where each selection is a dictionary.\n- punctuation: The punctuation value to filter the selections.\n\n**Code Description**:\nThe `selectOfPunctuation` function takes in a list of selections and a punctuation value as parameters. It then filters the selections based on the specified punctuation value and returns a new list containing only the selections that have the same punctuation value.\n\nThe function uses a list comprehension to iterate over each selection in the `selections` list. For each selection, it checks if the value of the \"punctuation\" key in the selection dictionary is equal to the specified punctuation value. If it is, the selection is included in the new list. If not, it is skipped.\n\nThis function is useful when you have a list of selections and you want to extract only the selections that have a specific punctuation value. It provides a convenient way to filter the selections based on a specific criterion.\n\n**Note**:\n- The `selections` parameter should be a list of dictionaries, where each dictionary represents a selection.\n- The `punctuation` parameter should be a value that can be compared to the \"punctuation\" key in the selection dictionaries.\n\n**Output Example**:\nIf we have the following list of selections:\n```\nselections = [\n    {\"punctuation\": \"!\"},\n    {\"punctuation\": \".\"},\n    {\"punctuation\": \"?\"},\n    {\"punctuation\": \".\"}\n]\n```\nAnd we call the `selectOfPunctuation` function with `selections` and the punctuation value \".\":\n```\nresult = selectOfPunctuation(selections, \".\")\nprint(result)\n```\nThe output will be:\n```\n[\n    {\"punctuation\": \".\"},\n    {\"punctuation\": \".\"}\n]\n```\n\nIn the project, the `selectOfPunctuation` function is called by two other functions: `Trickle` and `AddInput`. \n\nIn the `Trickle` function, the `selectOfPunctuation` function is used to filter the selections returned by the `NAR.AddInput` function based on the punctuation value \"!\". The filtered selections are then passed as an argument to the recursive call of the `Trickle` function.\n\nIn the `AddInput` function, the `selectOfPunctuation` function is used twice. First, it is used to filter the selections returned by the `NAR.AddInput` function based on the punctuation value \"!\". The filtered selections are then passed as an argument to the recursive call of the `Trickle` function. Second, it is used to filter the selections returned by the `NAR.AddInput` function based on the punctuation value \".\". The filtered selections are then passed as an argument to the recursive call of the `Trickle` function.\n\nThese usages demonstrate how the `selectOfPunctuation` function can be used in the context of the project to filter selections based on different punctuation values before further processing."
      ],
      "code_start_line": 32,
      "code_end_line": 33,
      "parent": null,
      "params": [
        "selections",
        "punctuation"
      ],
      "have_return": true,
      "code_content": "def selectOfPunctuation(selections, punctuation):\n    return [x for x in selections if x[\"punctuation\"] == punctuation]\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\distributedNAR.py/Trickle",
        "OpenNARS-for-Applications\\misc\\Python\\distributedNAR.py/AddInput"
      ],
      "reference_who": []
    },
    "selectionToNarsese": {
      "type": "FunctionDef",
      "name": "selectionToNarsese",
      "md_content": [
        "**selectionToNarsese**: The function of selectionToNarsese is to convert a selection object into a Narsese string representation.\n\n**parameters**:\n- selection: A dictionary object representing a selection, which contains the following keys:\n  - \"term\": A string representing the term of the selection.\n  - \"punctuation\": A string representing the punctuation of the selection.\n  - \"truth\": A dictionary representing the truth value of the selection, which contains the following keys:\n    - \"frequency\": A float representing the frequency of the selection.\n    - \"confidence\": A float representing the confidence of the selection.\n\n**Code Description**:\nThe `selectionToNarsese` function takes a selection object as input and returns a Narsese string representation of the selection. The Narsese string is constructed by concatenating the term, punctuation, and truth values of the selection.\n\nThe function first accesses the \"term\" key of the selection dictionary and concatenates it with the \"punctuation\" key. Then, it appends the Narsese truth value representation by converting the \"frequency\" and \"confidence\" values from the \"truth\" dictionary to strings and concatenating them with the Narsese truth value syntax.\n\nThe function then returns the constructed Narsese string representation of the selection.\n\nThis function is called within the `Trickle` function in the `distributedNAR.py` file. In the `Trickle` function, the `selectionToNarsese` function is used to convert a selection object into a Narsese string representation. The resulting Narsese string is then used as input for further processing within the `Trickle` function.\n\n**Note**:\n- The input selection object must be a dictionary with the required keys (\"term\", \"punctuation\", \"truth\") and their corresponding values.\n- The \"term\" and \"punctuation\" values should be strings.\n- The \"frequency\" and \"confidence\" values in the \"truth\" dictionary should be floats.\n\n**Output Example**:\nIf the input selection object is:\n```\n{\n  \"term\": \"apple\",\n  \"punctuation\": \"!\",\n  \"truth\": {\n    \"frequency\": 0.8,\n    \"confidence\": 0.9\n  }\n}\n```\nThe function will return the following Narsese string:\n```\n\"apple! :|: {0.8 0.9}\"\n```"
      ],
      "code_start_line": 36,
      "code_end_line": 37,
      "parent": null,
      "params": [
        "selection"
      ],
      "have_return": true,
      "code_content": "def selectionToNarsese(selection):\n    return selection[\"term\"] + selection[\"punctuation\"] + \" :|: {\" + str(selection[\"truth\"][\"frequency\"]) + \" \" + str(selection[\"truth\"][\"confidence\"]) + \"}\"\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\distributedNAR.py/Trickle"
      ],
      "reference_who": []
    },
    "Trickle": {
      "type": "FunctionDef",
      "name": "Trickle",
      "md_content": [
        "**Trickle**: The function of Trickle is to perform a recursive traversal of a given node and its selections, filtering them based on priority thresholds and punctuation values.\n\n**parameters**:\n- node: The node to start the traversal from.\n- selections: A list of selections, where each selection is a dictionary.\n- Down (optional): A boolean value indicating the direction of the traversal. Default is True.\n\n**Code Description**:\nThe `Trickle` function takes in a node, a list of selections, and an optional parameter indicating the direction of the traversal. It then performs a recursive traversal of the node and its selections, filtering them based on priority thresholds and punctuation values.\n\nThe function starts by printing the current node using the `print` function. This provides a visual indication of the traversal progress.\n\nNext, the function iterates over each selection in the `selections` list. For each selection, it checks if the `Down` parameter is True and the priority of the selection is less than the `priorityThresholdGoals`. If both conditions are met, the selection is skipped and the loop moves on to the next selection. Similarly, if the `Down` parameter is False and the priority of the selection is less than the `priorityThresholdBeliefs`, the selection is skipped.\n\nIf the selection passes the priority threshold checks, the function converts the selection to a Narsese string representation using the `selectionToNarsese` function. The resulting Narsese string is then used as input for further processing.\n\nIf the `Down` parameter is True, the function recursively calls itself for each incoming node of the current node. It passes the incoming node, the filtered selections with a punctuation value of \"!\", and sets the `Down` parameter to True.\n\nIf the `Down` parameter is False, the function recursively calls itself for each outgoing node of the current node. It passes the outgoing node, the filtered selections with a punctuation value of \".\", and sets the `Down` parameter to False.\n\nThis recursive traversal continues until all nodes and their selections have been processed.\n\n**Note**:\n- The `node` parameter should be a valid node in the traversal hierarchy.\n- The `selections` parameter should be a list of dictionaries, where each dictionary represents a selection.\n- The `Down` parameter determines the direction of the traversal. If set to True, the traversal goes downwards from the current node. If set to False, the traversal goes upwards from the current node.\n- The `priorityThresholdGoals` and `priorityThresholdBeliefs` variables are assumed to be defined and accessible within the same module as the `Trickle` function.\n- The `selectionToNarsese` function is assumed to be defined and accessible within the same module as the `Trickle` function.\n\nThis function is called within the `distributedNAR.py` file in the `OpenNARS-for-Applications` project. It is called by the `AddInput` function and is used to perform recursive traversals of nodes and their selections based on priority thresholds and punctuation values. The `selectOfPunctuation` function is also called within the `Trickle` function to filter selections based on punctuation values before further processing.\n\nThe `Trickle` function provides a way to traverse and filter selections in a hierarchical structure, allowing for more targeted and controlled processing of the data. It is a crucial component in the overall functionality of the `distributedNAR.py` module."
      ],
      "code_start_line": 40,
      "code_end_line": 53,
      "parent": null,
      "params": [
        "node",
        "selections",
        "Down"
      ],
      "have_return": false,
      "code_content": "def Trickle(node, selections, Down=True):\n    print(\"//^ in node:\", node)\n    for selection in selections:\n        if Down and float(selection[\"Priority\"]) < priorityThresholdGoals:\n            continue\n        if not Down and float(selection[\"Priority\"]) < priorityThresholdBeliefs:\n            continue\n        narsese = selectionToNarsese(selection)\n        if Down:\n            for x in incoming[node]:\n                Trickle(x, selectOfPunctuation(NAR.AddInput(narsese, Print=True, usedNAR=processes[x])[\"selections\"], \"!\"), Down=True)\n        else:\n            for x in outgoing[node]:\n                Trickle(x, selectOfPunctuation(NAR.AddInput(narsese, Print=True, usedNAR=processes[x])[\"selections\"], \".\"), Down=False)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\distributedNAR.py/AddInput"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\distributedNAR.py/selectOfPunctuation",
        "OpenNARS-for-Applications\\misc\\Python\\distributedNAR.py/selectionToNarsese",
        "OpenNARS-for-Applications\\misc\\Python\\NAR.py/AddInput"
      ]
    },
    "PerformIndependentSteps": {
      "type": "FunctionDef",
      "name": "PerformIndependentSteps",
      "md_content": [
        "**PerformIndependentSteps**: The function of PerformIndependentSteps is to perform a specified number of independent steps in parallel using the NAR system.\n\n**parameters**:\n- ticks (optional): An integer representing the number of steps to perform. Default is 1.\n\n**Code Description**:\nThe PerformIndependentSteps function utilizes the Parallel function from the joblib library to perform a specified number of independent steps in parallel. The number of steps is determined by the \"ticks\" parameter, which defaults to 1 if not provided.\n\nWithin the function, the Parallel function is called with the \"n_jobs\" parameter set to \"num_cores\" and the \"require\" parameter set to \"sharedmem\". This configuration allows the steps to be executed in parallel using shared memory.\n\nThe steps are performed by calling the AddInput function from the NAR module for each process in the \"processes\" dictionary. The AddInput function is called with the following parameters: the string representation of the \"ticks\" parameter, the \"Print\" parameter set to True, and the \"usedNAR\" parameter set to the corresponding process from the \"processes\" dictionary.\n\nThe AddInput function sends the Narsese input to the NAR system for processing and returns the parsed output. By calling the AddInput function in parallel for each process, the steps are performed independently and concurrently.\n\n**Note**:\n- The PerformIndependentSteps function assumes that the NAR system is already running and the necessary processes are available in the \"processes\" dictionary.\n- The function relies on the AddInput function from the NAR module to send the Narsese input to the NAR system and retrieve the parsed output.\n- The function uses the Parallel function from the joblib library to execute the steps in parallel using shared memory.\n- The number of steps to perform is determined by the \"ticks\" parameter, which defaults to 1 if not provided.\n\nThe PerformIndependentSteps function is called by the AddInput function in the distributedNAR.py module. The AddInput function checks the input string and performs different actions based on its content. If the input string consists of digits, indicating the number of steps to perform, the PerformIndependentSteps function is called with the parsed integer value of the input string.\n\nBy calling the PerformIndependentSteps function, the AddInput function performs the specified number of independent steps in parallel using the NAR system.\n\nAdditionally, the AddInput function in the distributedNAR.py module is called by other parts of the project to send Narsese inputs to the NAR system. The function handles different types of inputs, including goals and regular Narsese statements, and utilizes the PerformIndependentSteps function to perform the steps in parallel.\n\nOverall, the PerformIndependentSteps function plays a crucial role in executing independent steps in parallel using the NAR system, providing efficient processing capabilities for the project."
      ],
      "code_start_line": 55,
      "code_end_line": 56,
      "parent": null,
      "params": [
        "ticks"
      ],
      "have_return": false,
      "code_content": "def PerformIndependentSteps(ticks=1):\n    Parallel(n_jobs=num_cores, require='sharedmem')(delayed(NAR.AddInput)(str(ticks), Print=True, usedNAR=x) for x in processes.values())\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\distributedNAR.py/AddInput"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR.py/AddInput"
      ]
    },
    "AddInput": {
      "type": "FunctionDef",
      "name": "AddInput",
      "md_content": [
        "**AddInput**: The function of AddInput is to send a Narsese input to the NAR (Non-Axiomatic Reasoning) system and process the output.\n\n**parameters**:\n- narsese: A string representing the Narsese input to be added.\n- node (optional): The node to which the input is added. Default is None.\n\n**Code Description**:\nThe `AddInput` function is a key component of the distributedNAR.py module in the OpenNARS-for-Applications project. It is responsible for sending a Narsese input to the NAR system and processing the output.\n\nThe function takes two parameters: `narsese`, which is a string representing the Narsese input to be added, and `node`, which is an optional parameter representing the node to which the input is added. If the `node` parameter is not provided, it defaults to None.\n\nThe function starts by checking if the `narsese` input is a digit. If it is, it calls the `PerformIndependentSteps` function with the parsed integer value of the `narsese` input. This function performs the specified number of independent steps in parallel using the NAR system.\n\nIf the `narsese` input does not consist of digits, the function checks if it ends with \"! :|:\". This indicates that the input is a goal. In this case, the function calls the `Trickle` function with the `master` node, the filtered selections based on the punctuation value \"!\", and sets the `Down` parameter to True. The `Trickle` function performs a recursive traversal of the node and its selections, filtering them based on priority thresholds and punctuation values.\n\nIf the `narsese` input does not meet the above conditions, the function calls the `Trickle` function with the `node` parameter, the filtered selections based on the punctuation value \".\", and sets the `Down` parameter to False. This performs a recursive traversal of the node and its selections in the opposite direction.\n\nThe `AddInput` function provides a way to add Narsese inputs to the NAR system and perform various operations based on the input content. It leverages other functions in the module, such as `PerformIndependentSteps` and `Trickle`, to execute the necessary steps and process the output.\n\n**Note**:\n- The `narsese` parameter should be a valid Narsese input string.\n- The `node` parameter is optional and defaults to None if not provided.\n- The function relies on other functions in the distributedNAR.py module, such as `PerformIndependentSteps` and `Trickle`, to perform specific operations based on the input content.\n- The function assumes that the NAR system is already running and the necessary processes and nodes are available for traversal.\n- The function provides flexibility in handling different types of Narsese inputs, including goals and regular statements, and performs the appropriate operations based on the input content."
      ],
      "code_start_line": 59,
      "code_end_line": 65,
      "parent": null,
      "params": [
        "narsese",
        "node"
      ],
      "have_return": false,
      "code_content": "def AddInput(narsese, node = None):\n    if narsese.isdigit():\n        PerformIndependentSteps(int(narsese))\n    elif narsese.endswith(\"! :|:\"): #is goal\n        Trickle(master, selectOfPunctuation(NAR.AddInput(narsese, Print=True, usedNAR = processes[master])[\"selections\"], \"!\"), Down=True)\n    else:\n        Trickle(node, selectOfPunctuation(NAR.AddInput(narsese, Print=True, usedNAR = processes[node])[\"selections\"], \".\"), Down=False)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\distributedNAR.py/selectOfPunctuation",
        "OpenNARS-for-Applications\\misc\\Python\\distributedNAR.py/Trickle",
        "OpenNARS-for-Applications\\misc\\Python\\distributedNAR.py/PerformIndependentSteps",
        "OpenNARS-for-Applications\\misc\\Python\\NAR.py/AddInput"
      ]
    }
  },
  "OpenNARS-for-Applications\\misc\\Python\\gridlearn.py": {
    "state": {
      "type": "FunctionDef",
      "name": "state",
      "md_content": [
        "**state**: The function of state is to convert a given XY coordinate into a string representation.\n\n**parameters**:\n- XY: A tuple representing the XY coordinate.\n\n**Code Description**:\nThe `state` function takes a tuple `XY` as input, which represents the XY coordinate. It then converts the XY coordinate into a string representation by concatenating the string representations of the X and Y values with an underscore in between. The resulting string is returned as the output.\n\nThe code uses the `str` function to convert the X and Y values of the `XY` tuple into strings. It then concatenates these strings using the `+` operator and adds an underscore between them using the string literal \"_\".\n\nThe function is called by the `contingency` function in the `gridlearn.py` file. The `contingency` function uses the `state` function to generate strings representing different states in a contingency statement. The resulting strings are used to construct a larger string that represents the contingency statement.\n\n**Note**:\n- The `XY` parameter should be a tuple with two elements representing the X and Y coordinates.\n- The function assumes that the X and Y values of the `XY` tuple can be converted to strings using the `str` function.\n\n**Output Example**:\nIf the `XY` parameter is `(3, 4)`, the function will return the string `\"3_4\"`."
      ],
      "code_start_line": 9,
      "code_end_line": 10,
      "parent": null,
      "params": [
        "XY"
      ],
      "have_return": true,
      "code_content": "def state(XY):\n    return str(XY[0]) + \"_\" + str(XY[1])\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\gridlearn.py/contingency"
      ],
      "reference_who": []
    },
    "contingency": {
      "type": "FunctionDef",
      "name": "contingency",
      "md_content": [
        "**contingency**: The function of the `contingency` function is to generate a contingency statement based on the given input.\n\n**parameters**:\n- `pre`: A string representing the precondition of the contingency statement.\n- `op`: A string representing the operator of the contingency statement.\n- `cons`: A string representing the consequence of the contingency statement.\n\n**Code Description**:\nThe `contingency` function takes three input parameters: `pre`, `op`, and `cons`. It constructs a contingency statement by concatenating these parameters with specific formatting. The resulting contingency statement is returned as a tuple of two strings.\n\nThe function uses the `state` function from the `gridlearn.py` file to convert the `pre` and `cons` parameters into string representations. The `state` function takes a tuple representing an XY coordinate and converts it into a string representation. The resulting strings are then used to construct the contingency statement.\n\nThe first string in the tuple represents a contingency statement where the precondition (`pre`) is combined with a wildcard (`?1`) using the logical operator `&/`. The consequence (`cons`) is then added with the logical operator `=/>`. The second string in the tuple represents a contingency statement where the precondition (`pre`) is combined with the operator (`op`) using the logical operator `&/`. The consequence (`cons`) is then added with the logical operator `=/>`.\n\nThe `contingency` function is called within the `gridlearn.py` file and is used to generate contingency statements based on specific preconditions, operators, and consequences.\n\n**Note**:\n- The `pre`, `op`, and `cons` parameters should be strings.\n- The function assumes that the `state` function is defined in the `gridlearn.py` file and is correctly implemented.\n\n**Output Example**:\nIf the `pre` parameter is \"A\", the `op` parameter is \"B\", and the `cons` parameter is \"C\", the function will return the tuple of strings: (\"<A &/ ?1) =/> C>?\", \"<A &/ B) =/> C>\")."
      ],
      "code_start_line": 12,
      "code_end_line": 13,
      "parent": null,
      "params": [
        "pre",
        "op",
        "cons"
      ],
      "have_return": true,
      "code_content": "def contingency(pre, op, cons):\n    return (\"<(\" + state(pre) + \" &/ ?1) =/> \" + state(cons) + \">?\", \"<(\" + state(pre) + \" &/ \" + op + \") =/> \" + state(cons) + \">\")\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\gridlearn.py/state"
      ]
    },
    "execute": {
      "type": "FunctionDef",
      "name": "execute",
      "md_content": [
        "**execute**: The function of execute is to perform a specific execution based on the given list of executions.\n\n**parameters**:\n- executions: A list of executions, where each execution is a dictionary containing an \"operator\" key.\n\n**Code Description**:\nThe execute function takes a list of executions as input. It first assigns the current position to the variable lastposition. Then, it checks if the executions list is not empty. If it is not empty, it retrieves the first execution from the list. \n\nNext, it checks the value of the \"operator\" key in the execution dictionary. If the value is \"^left\", it updates the position by subtracting 1 from the x-coordinate of the current position. If the value is \"^right\", it updates the position by adding 1 to the x-coordinate. If the value is \"^up\", it updates the position by adding 1 to the y-coordinate. If the value is \"^down\", it updates the position by subtracting 1 from the y-coordinate. \n\nAfter updating the position, it prints the corresponding direction. \n\nIf the updated position is in the list of unreachables, it reverts the position back to the last position. Finally, it returns the value of the \"operator\" key from the execution dictionary.\n\n**Note**: \n- The global variable \"position\" is used to keep track of the current position.\n- The variables \"SX\" and \"SY\" are assumed to be defined elsewhere in the code.\n- The variable \"unreachables\" is assumed to be a list of positions that are not reachable.\n\n**Output Example**: \nIf the input executions list is [{\"operator\": \"^left\"}], and the current position is (2, 3), the function will update the position to (1, 3) and print \"^left\". It will then return \"^left\"."
      ],
      "code_start_line": 21,
      "code_end_line": 40,
      "parent": null,
      "params": [
        "executions"
      ],
      "have_return": true,
      "code_content": "def execute(executions):\n    global position\n    lastposition = position\n    if executions:\n        execution = executions[0]\n        if execution[\"operator\"] == \"^left\":\n            position = (max(0, position[0] - 1), position[1])\n            print(\"^left\")\n        if execution[\"operator\"] == \"^right\":\n            position = (min(SX-1, position[0] + 1), position[1])\n            print(\"^right\")\n        if execution[\"operator\"] == \"^up\":\n            position = (position[0], min(SY-1, position[1] + 1))\n            print(\"^up\")\n        if execution[\"operator\"] == \"^down\":\n            position = (position[0], max(0, position[1] - 1))\n            print(\"^down\")\n        if position in unreachables:\n            position = lastposition\n        return execution[\"operator\"]\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "checkAnswer": {
      "type": "FunctionDef",
      "name": "checkAnswer",
      "md_content": [
        "**checkAnswer**: The function of checkAnswer is to compare the user's answer with the correct solution and return a corresponding message based on the comparison.\n\n**parameters**:\n- answers: A list of dictionaries representing the user's answers. Each dictionary contains the keys \"term\" and \"truth\".\n- solution: A string representing the correct solution.\n\n**Code Description**:\nThe checkAnswer function first checks if the answers list is empty or if the first answer's term is \"None\". If either of these conditions is true, the function returns the string \"None\".\n\nIf the first answer's term is equal to the solution, the function returns a string concatenating \"Correct \" with the truth value of the first answer.\n\nIf none of the above conditions are met, the function returns a string concatenating \"Incorrect \" with the truth value of the first answer.\n\n**Note**: \n- The function assumes that the answers list is not empty and that the first answer's term is always present.\n- The function only compares the first answer's term with the solution. If there are multiple answers, only the first one is considered.\n\n**Output Example**:\n- If the answers list is empty or the first answer's term is \"None\":\n    - checkAnswer([], \"apple\") returns \"None\"\n    - checkAnswer([{\"term\": \"None\", \"truth\": 0.8}], \"apple\") returns \"None\"\n- If the first answer's term is equal to the solution:\n    - checkAnswer([{\"term\": \"apple\", \"truth\": 0.9}], \"apple\") returns \"Correct 0.9\"\n- If the first answer's term is not equal to the solution:\n    - checkAnswer([{\"term\": \"banana\", \"truth\": 0.7}], \"apple\") returns \"Incorrect 0.7\""
      ],
      "code_start_line": 45,
      "code_end_line": 50,
      "parent": null,
      "params": [
        "answers",
        "solution"
      ],
      "have_return": true,
      "code_content": "def checkAnswer(answers, solution):\n    if not answers or answers[0][\"term\"] == \"None\":\n        return \"None\"\n    if answers[0][\"term\"] == solution:\n        return \"Correct \" + str(answers[0][\"truth\"])\n    return \"Incorrect \" + str(answers[0][\"truth\"])\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    }
  },
  "OpenNARS-for-Applications\\misc\\Python\\gridplan.py": {
    "state": {
      "type": "FunctionDef",
      "name": "state",
      "md_content": [
        "**state**: The function of state is to convert a given XY coordinate into a string representation.\n\n**parameters**:\n- XY: A tuple representing the XY coordinate.\n\n**Code Description**:\nThe `state` function takes a tuple `XY` as input, which represents the XY coordinate. It then converts the XY coordinate into a string representation by concatenating the string representations of the X and Y values with an underscore in between. The resulting string is returned as the output.\n\nThe code first converts the X value of the XY coordinate to a string using the `str` function. It then concatenates the string representation of the X value with an underscore character using the `+` operator. Next, it converts the Y value of the XY coordinate to a string using the `str` function. Finally, it concatenates the string representation of the Y value with the previously created string using the `+` operator. The resulting string is returned as the output of the function.\n\nThis function is called by the `contingency` function in the `gridplan.py` file. The `contingency` function uses the `state` function to convert the pre and cons coordinates into string representations, which are then used to construct a contingency statement.\n\n**Note**:\n- The input `XY` should be a tuple containing two values representing the X and Y coordinates.\n- The function assumes that the input `XY` will always be a valid tuple.\n\n**Output Example**:\nIf the input `XY` is `(3, 5)`, the function will return the string `\"3_5\"`."
      ],
      "code_start_line": 8,
      "code_end_line": 9,
      "parent": null,
      "params": [
        "XY"
      ],
      "have_return": true,
      "code_content": "def state(XY):\n    return str(XY[0]) + \"_\" + str(XY[1])\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\gridplan.py/contingency"
      ],
      "reference_who": []
    },
    "contingency": {
      "type": "FunctionDef",
      "name": "contingency",
      "md_content": [
        "**contingency**: The function of contingency is to construct a contingency statement by combining the string representations of the pre and cons coordinates with the given operation.\n\n**parameters**:\n- pre: A tuple representing the pre coordinate.\n- op: A string representing the operation.\n- cons: A tuple representing the cons coordinate.\n\n**Code Description**:\nThe `contingency` function takes three parameters: `pre`, `op`, and `cons`. It constructs a contingency statement by combining the string representations of the `pre` and `cons` coordinates with the given operation `op`. The resulting contingency statement is returned as the output.\n\nThe code first calls the `state` function to convert the `pre` coordinate into a string representation. It passes the `pre` coordinate as an argument to the `state` function, which returns the string representation of the `pre` coordinate. The string representation is then concatenated with the `op` string using the `+` operator.\n\nNext, the code concatenates the resulting string with the string representation of the `cons` coordinate. It calls the `state` function again, passing the `cons` coordinate as an argument, and receives the string representation of the `cons` coordinate. Finally, the code concatenates the string representation of the `cons` coordinate with the previously created string using the `+` operator.\n\nThe resulting string represents a contingency statement in the form \"<(pre &/ op) =/> cons>.\". The function returns this contingency statement as the output.\n\nThis function is called within the `gridplan.py` file and is used to construct contingency statements based on the pre and cons coordinates and the specified operation.\n\n**Note**:\n- The `pre` and `cons` coordinates should be tuples containing two values representing the X and Y coordinates.\n- The `op` parameter should be a string representing the operation to be performed in the contingency statement.\n- The function assumes that the input coordinates and operation are valid.\n\n**Output Example**:\nIf the `pre` coordinate is `(3, 5)`, the `op` is `\"move\"`, and the `cons` coordinate is `(4, 6)`, the function will return the string \"<(3_5 &/ move) =/> 4_6>.\"."
      ],
      "code_start_line": 11,
      "code_end_line": 12,
      "parent": null,
      "params": [
        "pre",
        "op",
        "cons"
      ],
      "have_return": true,
      "code_content": "def contingency(pre, op, cons):\n    return \"<(\" + state(pre) + \" &/ \" + op + \") =/> \" + state(cons) + \">.\" \n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\gridplan.py/state"
      ]
    },
    "execute": {
      "type": "FunctionDef",
      "name": "execute",
      "md_content": [
        "**execute**: The function of execute is to perform a series of executions based on the given list of executions.\n\n**parameters**:\n- executions: A list of executions to be performed.\n\n**Code Description**:\nThe `execute` function is responsible for executing a series of actions based on the given list of executions. It starts by initializing a variable `lastposition` with the current value of the global variable `position`. This `lastposition` variable is used to store the previous position in case the current position becomes unreachable.\n\nThe function then checks if the `executions` list is not empty. If it is not empty, it retrieves the first execution from the list and assigns it to the variable `execution`. \n\nNext, the function checks the value of the `\"operator\"` key in the `execution` dictionary. If the value is `\"^left\"`, the function updates the `position` variable by subtracting 1 from the x-coordinate of the current position. The `max` function is used to ensure that the x-coordinate does not go below 0. After updating the `position` variable, the function prints the string `^left`.\n\nSimilarly, if the value of the `\"operator\"` key is `\"^right\"`, the function updates the `position` variable by adding 1 to the x-coordinate of the current position. The `min` function is used to ensure that the x-coordinate does not exceed the maximum x-coordinate value `SX-1`. After updating the `position` variable, the function prints the string `^right`.\n\nIf the value of the `\"operator\"` key is `\"^up\"`, the function updates the `position` variable by adding 1 to the y-coordinate of the current position. The `min` function is used to ensure that the y-coordinate does not exceed the maximum y-coordinate value `SY-1`. After updating the `position` variable, the function prints the string `^up`.\n\nSimilarly, if the value of the `\"operator\"` key is `\"^down\"`, the function updates the `position` variable by subtracting 1 from the y-coordinate of the current position. The `max` function is used to ensure that the y-coordinate does not go below 0. After updating the `position` variable, the function prints the string `^down`.\n\nAfter executing the action based on the first execution, the function checks if the current position is in the `unreachables` list. If the current position is in the `unreachables` list, the function reverts the `position` variable back to the previous position stored in the `lastposition` variable.\n\n**Note**: It is important to provide a valid list of executions as the parameter to ensure the correct execution of actions. The `position` variable is a global variable that is modified within the function. The `unreachables` list is used to determine if a position is unreachable."
      ],
      "code_start_line": 42,
      "code_end_line": 60,
      "parent": null,
      "params": [
        "executions"
      ],
      "have_return": false,
      "code_content": "def execute(executions):\n    global position\n    lastposition = position\n    if executions:\n        execution = executions[0]\n        if execution[\"operator\"] == \"^left\":\n            position = (max(0, position[0] - 1), position[1])\n            print(\"^left\")\n        if execution[\"operator\"] == \"^right\":\n            position = (min(SX-1, position[0] + 1), position[1])\n            print(\"^right\")\n        if execution[\"operator\"] == \"^up\":\n            position = (position[0], min(SY-1, position[1] + 1))\n            print(\"^up\")\n        if execution[\"operator\"] == \"^down\":\n            position = (position[0], max(0, position[1] - 1))\n            print(\"^down\")\n    if position in unreachables:\n        position = lastposition\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    }
  },
  "OpenNARS-for-Applications\\misc\\Python\\identitymatching.py": {
    "printloud": {
      "type": "FunctionDef",
      "name": "printloud",
      "md_content": [
        "**printloud**: The function of printloud is to print the value of the variable x if the variable \"loud\" is set to True.\n\n**parameters**:\n- x (optional): The value to be printed. If not provided, an empty string will be printed.\n\n**Code Description**:\nThe printloud function is defined with a single parameter, x, which is set to an empty string by default. The function first checks if the variable \"loud\" is set to True. If it is, the function proceeds to print the value of x using the print() function.\n\n**Note**:\n- It is assumed that the variable \"loud\" is defined and set to either True or False before calling the printloud function. If \"loud\" is set to False, the function will not print anything.\n- If the x parameter is not provided when calling the printloud function, an empty string will be printed."
      ],
      "code_start_line": 32,
      "code_end_line": 34,
      "parent": null,
      "params": [
        "x"
      ],
      "have_return": false,
      "code_content": "def printloud(x=\"\"):\n    if loud:\n        print(x)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    }
  },
  "OpenNARS-for-Applications\\misc\\Python\\matchtosample_handeye.py": {
    "op_left": {
      "type": "FunctionDef",
      "name": "op_left",
      "md_content": [
        "**op_left**: The function of op_left is to perform a specific operation called \"op_left\" in the NAR (Non-Axiomatic Reasoning) system.\n\n**parameters**:\n- None\n\n**Code Description**:\nThe op_left function is a simple function that performs the \"op_left\" operation in the NAR system. It starts by declaring a global variable called \"fovea\". \n\nNext, it calls the AddInput function from the NAR module to add a Narsese input to the NAR system. The Narsese input is \"G. :|: {0.0 0.05}\". The AddInput function sends the input to the NAR system for processing and returns the parsed output.\n\nAfter adding the input, the function assigns the value \"L\" to the \"fovea\" variable.\n\n**Note**:\n- The op_left function assumes that the NAR system is already running and the AddInput function is accessible.\n- The function does not take any parameters.\n- The function modifies the global variable \"fovea\" and calls the AddInput function to interact with the NAR system.\n\n**Relationship with other objects**:\n- The op_left function calls the AddInput function from the NAR module to add a Narsese input to the NAR system.\n\nRaw code:\n```python\ndef op_left():\n    global fovea\n    NAR.AddInput(\"G. :|: {0.0 0.05}\")\n    fovea = \"L\"\n```"
      ],
      "code_start_line": 11,
      "code_end_line": 14,
      "parent": null,
      "params": [],
      "have_return": false,
      "code_content": "def op_left():\n    global fovea\n    NAR.AddInput(\"G. :|: {0.0 0.05}\")\n    fovea = \"L\"\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR.py/AddInput"
      ]
    },
    "op_right": {
      "type": "FunctionDef",
      "name": "op_right",
      "md_content": [
        "**op_right**: The function of op_right is to perform a specific operation in the context of the NAR (Non-Axiomatic Reasoning) system. \n\n**parameters**:\n- None\n\n**Code Description**:\nThe op_right function is a part of the OpenNARS-for-Applications project and is located in the matchtosample_handeye.py file. This function is responsible for executing a specific operation within the NAR system. \n\nThe function starts by declaring the variable \"fovea\" as a global variable. This allows the function to access and modify the value of \"fovea\" outside of its scope. \n\nNext, the function calls the AddInput function from the NAR.py module. The AddInput function is responsible for sending a Narsese input to the NAR system for processing. In this case, the Narsese input is \"G. :|: {0.0 0.05}\". The AddInput function communicates with the NAR system through its standard input and output streams. \n\nAfter calling the AddInput function, the function assigns the value \"R\" to the \"fovea\" variable. This indicates that the operation performed by the op_right function is related to the right side of the fovea. \n\n**Note**:\n- The op_right function assumes that the NAR system is already running and its standard input and output streams are accessible.\n- The function relies on the AddInput function from the NAR.py module to send the Narsese input to the NAR system.\n- The function modifies the global variable \"fovea\" to indicate the operation performed by the op_right function.\n- The specific details of the operation performed by the op_right function are not provided in the code snippet."
      ],
      "code_start_line": 16,
      "code_end_line": 19,
      "parent": null,
      "params": [],
      "have_return": false,
      "code_content": "def op_right():\n    global fovea\n    NAR.AddInput(\"G. :|: {0.0 0.05}\")\n    fovea = \"R\"\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR.py/AddInput"
      ]
    },
    "op_up": {
      "type": "FunctionDef",
      "name": "op_up",
      "md_content": [
        "**op_up**: The function of op_up is to update the value of the global variable \"fovea\" and add a Narsese input to the NAR (Non-Axiomatic Reasoning) system.\n\n**parameters**:\n- None\n\n**Code Description**:\nThe op_up function begins by declaring the \"fovea\" variable as a global variable. This allows the function to modify the value of \"fovea\" outside of its local scope.\n\nNext, the function calls the AddInput function from the NAR module. The AddInput function is responsible for sending a Narsese input to the NAR system for processing. In this case, the Narsese input is \"G. :|: {0.0 0.05}\". The function passes this input as a parameter to the AddInput function.\n\nAfter calling the AddInput function, the op_up function assigns the value \"U\" to the \"fovea\" variable. This updates the value of the global variable \"fovea\" to \"U\".\n\n**Note**:\n- The op_up function assumes that the NAR system is already running and accessible.\n- The function relies on the AddInput function from the NAR module to send the Narsese input to the NAR system.\n- The function updates the value of the global variable \"fovea\" to \"U\" after adding the Narsese input to the NAR system.\n\nThe op_up function is called within the project hierarchy from the matchtosample_handeye.py file. It is part of the Python module within the misc directory. The op_up function interacts with the NAR system by using the AddInput function from the NAR module. The AddInput function is responsible for sending Narsese inputs to the NAR system and processing the output. By calling the AddInput function, the op_up function adds the Narsese input \"G. :|: {0.0 0.05}\" to the NAR system. After adding the input, the op_up function updates the value of the global variable \"fovea\" to \"U\".\n\nPlease refer to the documentation of the AddInput function in the NAR module for more information on how the Narsese input is processed and the output is handled.\n\n**Note**:\n- The op_up function assumes that the NAR system is already running and accessible.\n- The function relies on the AddInput function from the NAR module to send the Narsese input to the NAR system.\n- The function updates the value of the global variable \"fovea\" to \"U\" after adding the Narsese input to the NAR system."
      ],
      "code_start_line": 21,
      "code_end_line": 24,
      "parent": null,
      "params": [],
      "have_return": false,
      "code_content": "def op_up():\n    global fovea\n    NAR.AddInput(\"G. :|: {0.0 0.05}\")\n    fovea = \"U\"\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR.py/AddInput"
      ]
    },
    "create_new_match_to_sample_scenario": {
      "type": "FunctionDef",
      "name": "create_new_match_to_sample_scenario",
      "md_content": [
        "**create_new_match_to_sample_scenario**: The function of create_new_match_to_sample_scenario is to generate a new scenario for the match-to-sample task in the NAR (Non-Axiomatic Reasoning) system.\n\n**parameters**:\n- None\n\n**Code Description**:\nThe create_new_match_to_sample_scenario function starts by printing \"//NEW SCENARIO!!!!\" to indicate the start of a new scenario. \n\nNext, the function randomly selects one of the four predefined items, which are represented as dictionaries with keys \"U\", \"L\", and \"R\". Each key represents a different stimulus location. The selected item is assigned to the global variable \"items\".\n\nThe function then sets the fovea variable to \"U\" to indicate that the fovea is focused on the upper stimulus location. This assignment is currently commented out, and the fovea is always set to \"U\".\n\nThe function adds four Narsese inputs to the NAR system using the AddInput function. Each input represents a pick action for one of the stimulus locations. The inputs have the form \"dt=1.0 <(LB1 &/ ^pick) =/> G>. {0.0 0.99}\", where \"LB1\" is the location of the stimulus and \"G\" is the goal to be achieved. The parameters \"dt=1.0\" and \"{0.0 0.99}\" specify the time and confidence values associated with the input.\n\n**Note**:\n- The create_new_match_to_sample_scenario function assumes that the NAR system is already running and the AddInput function is accessible.\n- The function generates a new scenario by selecting a random item and setting the fovea variable.\n- The Narsese inputs added to the NAR system represent pick actions for each stimulus location.\n\n**Calling Situation**:\nThe create_new_match_to_sample_scenario function is called within the op_pick function in the matchtosample_handeye.py file. After a successful or failed pick action, the op_pick function calls create_new_match_to_sample_scenario to generate a new scenario for the match-to-sample task. The function is also called at the end of the op_pick function to continue the loop and perform the next pick action.\n\nThe op_pick function is called within the main loop of the program, which suggests that the create_new_match_to_sample_scenario function is an essential part of the overall functionality of the program.\n\n**Note**:\n- The op_pick function is responsible for handling the logic of successful and failed pick actions in the match-to-sample task.\n- The create_new_match_to_sample_scenario function is called within the op_pick function to generate new scenarios for the task."
      ],
      "code_start_line": 26,
      "code_end_line": 38,
      "parent": null,
      "params": [],
      "have_return": false,
      "code_content": "def create_new_match_to_sample_scenario():\n    global items, fovea\n    print(\"//NEW SCENARIO!!!!\")\n    items = random.choice([{\"U\" : \"A1\", \"L\" : \"B1\", \"R\" : \"B2\"},\n                           {\"U\" : \"A1\", \"L\" : \"B2\", \"R\" : \"B1\"},\n                           {\"U\" : \"X1\", \"L\" : \"B1\", \"R\" : \"B2\"},\n                           {\"U\" : \"X1\", \"L\" : \"B2\", \"R\" : \"B1\"}])\n    fovea = \"U\" #random.choice([\"U\", \"L\", \"R\"])\n    #easy to train extra not to pick a stimulus just for stimulus sake\n    NAR.AddInput(\"dt=1.0 <(LB1 &/ ^pick) =/> G>. {0.0 0.99}\")\n    NAR.AddInput(\"dt=1.0 <(RB1 &/ ^pick) =/> G>. {0.0 0.99}\")\n    NAR.AddInput(\"dt=1.0 <(LB2 &/ ^pick) =/> G>. {0.0 0.99}\")\n    NAR.AddInput(\"dt=1.0 <(RB2 &/ ^pick) =/> G>. {0.0 0.99}\")\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\matchtosample_handeye.py/op_pick"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR.py/AddInput"
      ]
    },
    "rewarded_after_pick": {
      "type": "FunctionDef",
      "name": "rewarded_after_pick",
      "md_content": [
        "**rewarded_after_pick**: The function of rewarded_after_pick is to determine whether a pick action is rewarded or not based on the match-to-sample cases.\n\n**parameters**:\n- No parameters are passed to this function.\n\n**Code Description**:\nThe function `rewarded_after_pick` checks if a pick action is rewarded by iterating through a list of match-to-sample cases. Each match-to-sample case is a tuple containing two elements: a sample and another item. The function then checks if the fovea (a variable that is not defined in the given code snippet) is not equal to \"U\" and if the item at index \"U\" in the `items` dictionary is equal to the sample, and the item at index `fovea` in the `items` dictionary is equal to the other item. If all these conditions are met for any match-to-sample case, the function returns True, indicating that the pick action is rewarded. If none of the match-to-sample cases satisfy the conditions, the function returns False, indicating that the pick action is not rewarded.\n\n**Note**:\n- The code snippet provided does not include the definition of the `fovea` variable and the `items` dictionary. Therefore, the behavior of the function may not be accurately described without this information.\n\n**Output Example**:\n- If the match_to_sample_cases list is `[(\"X1\", \"B2\"), (\"A1\", \"B1\")]`, and the `fovea` variable is not equal to \"U\", and the `items` dictionary has the values `{\"U\": \"X1\", \"A1\": \"B1\"}`, then the function will return True."
      ],
      "code_start_line": 40,
      "code_end_line": 45,
      "parent": null,
      "params": [],
      "have_return": true,
      "code_content": "def rewarded_after_pick():\n    match_to_sample_cases = [(\"X1\", \"B2\"), (\"A1\", \"B1\")]\n    for (sample, other) in match_to_sample_cases:\n        if fovea != \"U\" and  items[\"U\"] == sample and items[fovea] == other:\n            return True\n    return False\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\matchtosample_handeye.py/op_pick"
      ],
      "reference_who": []
    },
    "stats": {
      "type": "FunctionDef",
      "name": "stats",
      "md_content": [
        "**stats**: The function of stats is to calculate and return the statistics of successes, failures, ratio, and t.\n\n**parameters**:\n- None\n\n**Code Description**:\nThe `stats` function calculates the statistics of successes, failures, ratio, and t. It first calculates the ratio by dividing the number of successes by the sum of successes and failures. If the sum of successes and failures is 0, the ratio is set to 0 to avoid division by zero. The function then returns a formatted string that includes the values of failures, successes, ratio, and t.\n\nThis function is called by the following objects in the project:\n- `op_pick` function in `OpenNARS-for-Applications/misc/Python/matchtosample_handeye.py/op_pick`\n\nIn the `op_pick` function, the `stats` function is called to print the statistics after each pick operation. If the pick operation is successful, the `successes` counter is incremented and the `stats` function is called with the prefix \"//SUCCESS +++++++\". If the pick operation fails, the `failures` counter is incremented and the `stats` function is called with the prefix \"//FAILURE +++++++\". The `stats` function is also called when the `op_pick` function is executed every 1000 iterations.\n\nAfter the `stats` function is called, the output is flushed to the standard output using `sys.stdout.flush()`. If the sum of successes and failures reaches 1000, the program exits. Finally, a new match-to-sample scenario is created and the value \"20\" is added as input to the NAR system.\n\n**Note**:\n- The `successes` and `failures` variables are assumed to be defined and accessible in the scope of the `stats` function.\n- The `t` variable is assumed to be defined and accessible in the scope of the `stats` function.\n- The `NAR` object is assumed to be defined and accessible in the scope of the `op_pick` function.\n- The `rewarded_after_pick` function is assumed to be defined and accessible in the scope of the `op_pick` function.\n- The `time` module is assumed to be imported and accessible in the scope of the `op_pick` function.\n\n**Output Example**:\n\"failures=10, successes=90 ratio=0.9, t=1000\""
      ],
      "code_start_line": 50,
      "code_end_line": 52,
      "parent": null,
      "params": [],
      "have_return": true,
      "code_content": "def stats():\n    ratio = 0 if successes+failures == 0 else successes / (failures + successes)\n    return f\"failures={failures}, successes={successes} ratio={ratio}, t={t}\"\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\matchtosample_handeye.py/op_pick"
      ],
      "reference_who": []
    },
    "op_pick": {
      "type": "FunctionDef",
      "name": "op_pick",
      "md_content": [
        "**op_pick**: The function of op_pick is to handle the logic of successful and failed pick actions in the match-to-sample task. It determines whether a pick action is rewarded or not based on the match-to-sample cases and updates the statistics accordingly.\n\n**parameters**:\n- failure (optional): A boolean value indicating whether the pick action is a failure. Default is False.\n\n**Code Description**:\nThe `op_pick` function starts by checking if the `failure` parameter is False and if the pick action is rewarded by calling the `rewarded_after_pick` function. If the pick action is rewarded, the function adds a Narsese input \"G. :|:\" to the NAR system using the `AddInput` function. The `successes` counter is incremented, and the statistics are printed using the `stats` function with the prefix \"//SUCCESS +++++++\". The output is flushed to the standard output using `sys.stdout.flush()`. If the current iteration `t` is a multiple of 1000, the function sleeps for 1 second.\n\nIf the pick action is not rewarded or the `failure` parameter is True, the function adds a Narsese input \"G. :|: {0.0 0.999}\" to the NAR system using the `AddInput` function. The `failures` counter is incremented, and the statistics are printed using the `stats` function with the prefix \"//FAILURE +++++++\". The output is flushed to the standard output using `sys.stdout.flush()`. If the current iteration `t` is a multiple of 1000, the function sleeps for 1 second.\n\nAfter each pick action, the function checks if the total number of successes and failures is equal to 1000. If this condition is true, the program exits.\n\nFinally, the function calls the `create_new_match_to_sample_scenario` function to generate a new scenario for the match-to-sample task by creating new Narsese inputs and setting the fovea variable. The function also adds the Narsese input \"20\" to the NAR system.\n\n**Note**:\n- The `failures` and `successes` variables are assumed to be defined and accessible in the scope of the `op_pick` function.\n- The `t` variable is assumed to be defined and accessible in the scope of the `op_pick` function.\n- The `NAR` object is assumed to be defined and accessible in the scope of the `op_pick` function.\n- The `rewarded_after_pick` function is assumed to be defined and accessible in the scope of the `op_pick` function.\n- The `time` module is assumed to be imported and accessible in the scope of the `op_pick` function.\n\n**Calling Situation**:\nThe `op_pick` function is called within the main loop of the program. It is responsible for handling the logic of successful and failed pick actions in the match-to-sample task. After a successful or failed pick action, the function calls the `create_new_match_to_sample_scenario` function to generate a new scenario for the task. The function is also called at the end of the `op_pick` function to continue the loop and perform the next pick action.\n\nThe `op_pick` function is an essential part of the overall functionality of the program, as it determines the success or failure of pick actions and updates the statistics accordingly.\n\n**Note**:\n- The `create_new_match_to_sample_scenario` function is called within the `op_pick` function to generate new scenarios for the match-to-sample task.\n- The `rewarded_after_pick` function is called within the `op_pick` function to determine whether a pick action is rewarded or not based on the match-to-sample cases.\n- The `stats` function is called within the `op_pick` function to calculate and print the statistics of successes, failures, ratio, and `t`.\n- The `AddInput` function is called within the `op_pick` function to add Narsese inputs to the NAR system."
      ],
      "code_start_line": 54,
      "code_end_line": 73,
      "parent": null,
      "params": [
        "failure"
      ],
      "have_return": false,
      "code_content": "def op_pick(failure=False):\n    global failures, successes\n    if failure == False and rewarded_after_pick():\n        NAR.AddInput(\"G. :|:\")\n        successes += 1\n        print(\"//SUCCESS +++++++\", stats())\n        sys.stdout.flush()\n        if t % 1000 == 0:\n            time.sleep(1.0)\n    else:\n        NAR.AddInput(\"G. :|: {0.0 0.999}\")\n        print(\"//FAILURE +++++++\", stats())\n        failures += 1\n        sys.stdout.flush()\n        if t % 1000 == 0:\n            time.sleep(1.0)\n    if successes + failures == 1000:\n        exit(0)\n    create_new_match_to_sample_scenario()\n    NAR.AddInput(\"20\")\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\matchtosample_handeye.py/create_new_match_to_sample_scenario",
        "OpenNARS-for-Applications\\misc\\Python\\matchtosample_handeye.py/rewarded_after_pick",
        "OpenNARS-for-Applications\\misc\\Python\\matchtosample_handeye.py/stats",
        "OpenNARS-for-Applications\\misc\\Python\\NAR.py/AddInput"
      ]
    },
    "step": {
      "type": "FunctionDef",
      "name": "step",
      "md_content": [
        "**step**: The function of step is to perform a single step of the match-to-sample hand-eye coordination task.\n\n**parameters**:\n- None\n\n**Code Description**:\nThe step function is responsible for executing a single step of the match-to-sample hand-eye coordination task. It performs the following steps:\n\n1. Retrieve the value of the item at the fovea position: The variable \"val\" is assigned the value of the item at the fovea position in the \"items\" list.\n\n2. Add input to the NAR system: The AddInput function is called to send a Narsese input to the NAR system. The Narsese input is constructed by concatenating the fovea position, the value at the fovea position, and \". :|:\". This input represents a statement that asserts the value at the fovea position. The AddInput function processes the input and returns the output.\n\n3. Retrieve the executions from the NAR system: The executions variable is assigned the value of the \"executions\" key in the output returned by the AddInput function. This represents the executions generated by the NAR system in response to the input.\n\n4. Execute the first execution: If there are any executions, the function enters a loop and iterates over each execution. The \"i\" variable represents the index of the current execution, and the \"execution\" variable represents the current execution itself.\n\n5. Retrieve the operator name: The opname variable is assigned the value of the \"operator\" key in the current execution. This represents the name of the operator associated with the execution.\n\n6. Execute the operator: The ops dictionary is accessed using the opname as the key, and the corresponding value (a function) is called. This executes the operator associated with the current execution.\n\n7. Break the loop: After executing the operator, the loop is broken using the \"break\" statement. This ensures that only the first execution is processed.\n\n**Note**:\n- The step function assumes that the \"items\" list, the \"fovea\" variable, the \"NAR\" object, and the \"ops\" dictionary are defined and accessible within the same module as the step function.\n- The function relies on the AddInput function to send input to the NAR system and retrieve the executions.\n- The function assumes that the AddInput function is defined and accessible within the same module as the step function.\n- The function assumes that the NAR system is already running and its standard input and output streams are accessible.\n- The function assumes that the ops dictionary contains the necessary operator functions to be executed based on the operator names retrieved from the NAR system.\n- The function only executes the first execution and breaks the loop. If there are multiple executions, the remaining executions will not be processed."
      ],
      "code_start_line": 81,
      "code_end_line": 89,
      "parent": null,
      "params": [],
      "have_return": false,
      "code_content": "def step():\n    val = items[fovea]\n    NAR.AddInput(fovea + val + \". :|:\")\n    executions = NAR.AddInput(\"G! :|:\")[\"executions\"]\n    if executions:\n        for i, execution in enumerate(executions):\n            opname = execution[\"operator\"]\n            ops[opname]()\n            break\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR.py/AddInput"
      ]
    }
  },
  "OpenNARS-for-Applications\\misc\\Python\\minigrid_ona.py": {
    "ASCIIpaint": {
      "type": "FunctionDef",
      "name": "ASCIIpaint",
      "md_content": [
        "**ASCIIpaint**: The function of ASCIIpaint is to generate ASCII art representations of objects with different colors.\n\n**parameters**:\n- COLOR: A string representing the color of the object.\n- objectchar: A string representing the character to be used for the object.\n\n**Code Description**:\nThe ASCIIpaint function takes in two parameters: COLOR and objectchar. It first checks the value of objectchar and based on its value, it returns a specific ASCII art representation of the object with the specified color.\n\nIf objectchar is equal to \"W\", the function returns a white background with a space character.\nIf objectchar is equal to \"L\", the function returns the specified color with the character \"L\".\nIf objectchar is equal to \"V\", the function returns the color red with the character \"v\".\nIf objectchar is equal to \"^\", the function returns the color red with the character \"^\".\nIf objectchar is equal to \"<\", the function returns the color red with the character \"<\".\nIf objectchar is equal to \">\", the function returns the color red with the character \">\".\nIf objectchar is none of the above, the function returns the specified color with the character objectchar.\n\nThis function is used to generate ASCII art representations of objects with different colors. It is called by the colorify function in the minigrid_ona.py file. The colorify function takes in a string and iterates over each character. For every even-indexed character, it stores the character in the variable lasts. For every odd-indexed character, it determines the color based on the value of the character (G for green, B for blue, R for red, Y for yellow, and default to white). It then calls the ASCIIpaint function with the stored lasts character and the determined color, and appends the result to the string S. If the character is a newline character, it resets the even flag to True and appends a newline character to the string S. Finally, it returns the generated string S.\n\n**Note**: The ASCIIpaint function is dependent on the colorify function in the minigrid_ona.py file for its usage. It is important to ensure that the colorify function is called before using the ASCIIpaint function to generate the desired ASCII art representation.\n\n**Output Example**:\nIf the COLOR parameter is set to RED and the objectchar parameter is set to \"L\", the function will return the following ASCII art representation:\n```\nL\n```\nThis represents an object with the color red and the character \"L\"."
      ],
      "code_start_line": 24,
      "code_end_line": 38,
      "parent": null,
      "params": [
        "COLOR",
        "objectchar"
      ],
      "have_return": true,
      "code_content": "def ASCIIpaint(COLOR, objectchar):\n    if objectchar == \"W\":\n        return WHITE + \";47m \"\n    elif objectchar == \"L\":\n        return COLOR + \"mL\" #\";47mL\"\n    elif objectchar == \"V\":\n        return RED + \"m\" + \"v\"\n    elif objectchar == \"^\":\n        return RED + \"m\" + \"^\"\n    elif objectchar == \"<\":\n        return RED + \"m\" + \"<\"\n    elif objectchar == \">\":\n        return RED + \"m\" + \">\"\n    else:\n        return COLOR + \"m\" + objectchar\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\minigrid_ona.py/colorify"
      ],
      "reference_who": []
    },
    "colorify": {
      "type": "FunctionDef",
      "name": "colorify",
      "md_content": [
        "**colorify**: The function of colorify is to generate a colored ASCII art representation of a given string.\n\n**parameters**:\n- x: A string representing the input text.\n\n**Code Description**:\nThe colorify function takes in a string as input and iterates over each character in the string. For every even-indexed character, it stores the character in the variable \"lasts\". For every odd-indexed character, it determines the color based on the value of the character. If the character is \"G\", the color is set to green. If the character is \"B\", the color is set to blue. If the character is \"R\", the color is set to red. If the character is \"Y\", the color is set to yellow. If the character is none of the above, the color is set to white.\n\nThe function then calls the ASCIIpaint function with the stored \"lasts\" character and the determined color. It appends the result of the ASCIIpaint function to the string \"S\". If the character is a newline character (\"\\n\"), it resets the even flag to True and appends a newline character to the string \"S\". Finally, the function returns the generated string \"S\".\n\n**Note**: The colorify function relies on the ASCIIpaint function to generate the colored ASCII art representation. It is important to ensure that the ASCIIpaint function is defined and called before using the colorify function.\n\n**Output Example**:\nIf the input string is \"GBRY\", the colorify function will return the following colored ASCII art representation:\n```\nL\n```\nThis represents an object with the colors green, blue, red, and yellow, respectively, and the characters \"L\"."
      ],
      "code_start_line": 40,
      "code_end_line": 63,
      "parent": null,
      "params": [
        "x"
      ],
      "have_return": true,
      "code_content": "def colorify(x):\n    S=\"\"\n    even = True\n    lasts = \"\"\n    for s in x:\n        if even:\n            lasts = s\n        else:\n            COLOR = WHITE\n            if s == \"G\":\n                COLOR = GREEN\n            if s == \"B\":\n                COLOR = BLUE\n            if s == \"R\":\n                COLOR = RED\n            if s == \"Y\":\n                COLOR = YELLOW\n            S += ASCIIpaint(COLOR, lasts) + RESET\n        if s == \"\\n\":\n            even = True\n            S += \"\\n\"\n        else:\n            even = not even\n    return S\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\minigrid_ona.py/renderANSI"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\minigrid_ona.py/ASCIIpaint"
      ]
    },
    "renderANSI": {
      "type": "FunctionDef",
      "name": "renderANSI",
      "md_content": [
        "**renderANSI**: The function of renderANSI is to render an ASCII art representation of the environment in the ANSI terminal.\n\n**parameters**:\n- env: An environment object representing the state of the environment.\n\n**Code Description**:\nThe renderANSI function takes in an environment object as input and performs the following steps:\n\n1. It uses the escape sequence \"\\033[1;1H\\033[2J\" to clear the terminal screen and move the cursor to the top-left corner.\n2. It extracts the ASCII representation of the environment by splitting the string representation of the environment object at the \"<PassiveEnvChecker\" substring and taking the second part.\n3. It calls the colorify function with the extracted ASCII representation as input to generate a colored ASCII art representation of the environment.\n4. It prints the colored ASCII art representation of the environment.\n5. It prints the RESET escape sequence to reset the terminal colors.\n\nThe renderANSI function relies on the colorify function to generate the colored ASCII art representation of the environment. It is important to ensure that the colorify function is defined and called before using the renderANSI function.\n\n**Note**: The renderANSI function assumes that the terminal supports ANSI escape sequences for color and cursor control. The function may not work correctly if the terminal does not support these features.\n\nThe renderANSI function is part of the minigrid_ona.py module in the OpenNARS-for-Applications project. It is called to render the environment state in the terminal for visualization purposes.\n\n**Note**: The renderANSI function is typically called in a loop to continuously update and display the environment state in real-time.\n\nPlease refer to the documentation of the colorify function for more information on how the colored ASCII art representation is generated."
      ],
      "code_start_line": 65,
      "code_end_line": 69,
      "parent": null,
      "params": [
        "env"
      ],
      "have_return": false,
      "code_content": "def renderANSI(env):\n    print(\"\\033[1;1H\\033[2J\")\n    asciigrid = str(env).split(\"<PassiveEnvChecker\")[1] #WG (wall green)\n    print(colorify(asciigrid))\n    print(RESET)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\minigrid_ona.py/colorify"
      ]
    },
    "coneForward": {
      "type": "FunctionDef",
      "name": "coneForward",
      "md_content": [
        "**coneForward**: The function of coneForward is to generate a list of coordinates representing a cone-shaped view in front of an agent in a grid environment.\n\n**Parameters**:\n- viewDistance: An optional parameter that specifies the distance of the cone-shaped view. The default value is 6.\n\n**Code Description**:\nThe function starts by initializing an empty list `L` to store the coordinates of the cone-shaped view. It also initializes an index variable to keep track of the number of cells added to the list. The starting position of the cone is set to (2, 5) using the variables `StartIndexX` and `StartIndexY`. Two more variables, `indexX` and `indexY`, are used to keep track of the current position while iterating through the cone.\n\nThe width of the cone is initially set to 3, representing the three cells right in front of the agent. The function then enters a nested loop, where the outer loop iterates `viewDistance` times and the inner loop iterates `width` times. In each iteration, the function checks if the current index is not 0 or 2 (representing the corner cells of the cone). If it is not a corner cell, the current coordinates `(indexX, indexY, k)` are appended to the list `L`. The `indexX` is incremented by 1 in each iteration, and the `index` is incremented as well.\n\nAfter each inner loop iteration, the `StartIndexX` is updated by subtracting 1, ensuring that the cone moves one cell to the left in the next iteration. The `indexX` is reset to the updated `StartIndexX`, and the `indexY` is decremented by 1 to move the cone one cell up. The width of the cone is increased by 2, but limited to a maximum of 7 cells.\n\nOnce all iterations are completed, the function returns the list `L` containing the coordinates of the cone-shaped view.\n\n**Note**: \n- The cone-shaped view is represented by a list of tuples, where each tuple contains the x-coordinate, y-coordinate, and the distance from the agent.\n- The cone starts with the three cells right in front of the agent and expands wider as it moves forward.\n- The corner cells of the cone are excluded from the view as the system cannot toggle switches diagonally.\n\n**Output Example**:\nIf `viewDistance` is set to 6, the function may return the following list of coordinates:\n[(2, 5, 0), (3, 5, 0), (4, 5, 0), (3, 4, 1), (4, 4, 1), (5, 4, 1), (2, 3, 2), (3, 3, 2), (4, 3, 2), (5, 3, 2), (6, 3, 2), (1, 2, 3), (2, 2, 3), (3, 2, 3), (4, 2, 3), (5, 2, 3), (6, 2, 3), (7, 2, 3), (0, 1, 4), (1, 1, 4), (2, 1, 4), (3, 1, 4), (4, 1, 4), (5, 1, 4), (6, 1, 4), (7, 1, 4), (8, 1, 4), (0, 0, 5), (1, 0, 5), (2, 0, 5), (3, 0, 5), (4, 0, 5), (5, 0, 5), (6, 0, 5), (7, 0, 5), (8, 0, 5), (9, 0, 5)]"
      ],
      "code_start_line": 84,
      "code_end_line": 100,
      "parent": null,
      "params": [
        "viewDistance"
      ],
      "have_return": true,
      "code_content": "def coneForward(viewDistance=6):\n    L=[]\n    index = 0\n    StartIndexX, StartIndexY = (2,5)\n    indexX, indexY = (StartIndexX,StartIndexY)\n    width = 3 #cone starts with the 3 cells right in front of agent\n    for k in range(viewDistance):\n        for h in range(width):\n            if index != 0 and index != 2: #remove corner items as the system can't toggle switches if diagonal\n                L.append((indexX, indexY, k))\n            indexX += 1\n            index+=1\n        StartIndexX = max(0, StartIndexX - 1)\n        indexX=StartIndexX\n        indexY -=1\n        width=min(7,width+2)\n    return L\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\minigrid_ona.py/nearestObject",
        "OpenNARS-for-Applications\\misc\\Python\\minigrid_ona.py/observationToEvent"
      ],
      "reference_who": []
    },
    "coneRight": {
      "type": "FunctionDef",
      "name": "coneRight",
      "md_content": [
        "**coneRight**: The function of coneRight is to generate a list of coordinates representing a cone shape to the right of a given starting point. The cone shape is determined by the view distance parameter.\n\n**parameters**:\n- viewDistance: An optional parameter that specifies the distance of the cone shape. The default value is 3.\n\n**Code Description**:\nThe function starts by initializing an empty list L to store the coordinates of the cone shape. It then sets the starting index coordinates (StartIndexX, StartIndexY) to (3, 6). Two additional variables (indexX, indexY) are initialized with the starting index values.\n\nThe function uses nested for loops to iterate over the range of viewDistance. The outer loop controls the height of the cone, while the inner loop controls the width of each row. Within the inner loop, the x-coordinate of the left side of the cone (xLeft) is calculated by incrementing the indexX value by 1. The coordinates (xLeft, indexY, h) are then appended to the list L. After each iteration of the inner loop, the indexX value is incremented by 1.\n\nOnce the inner loop completes, the StartIndexX value is incremented by 1, and the indexX value is reset to the updated StartIndexX value. The indexY value is decremented by 1 to move to the next row of the cone.\n\nAfter the completion of the outer loop, the function inserts an additional coordinate (4, 5, 1) at index 1 of the list L.\n\nFinally, the function returns the list L, which contains the coordinates representing the cone shape to the right of the starting point.\n\nThe function is called by two other objects in the project: nearestObject and observationToEvent. In the nearestObject function, the coneRight function is used along with coneForward and coneLeft to scan the cells and determine the nearest object. The result of the coneRight function is used in the comparison to decide the direction of the nearest object. In the observationToEvent function, the coneRight function is again used to scan the cells and encode the state of the cone shape to the right.\n\n**Note**: \n- The viewDistance parameter determines the size of the cone shape. Increasing the value will result in a larger cone.\n- The starting index coordinates (StartIndexX, StartIndexY) can be modified to change the starting point of the cone shape.\n- The function assumes that the cells variable is defined and accessible within the scope of the function.\n\n**Output Example**:\n[(4, 6, 0), (5, 6, 0), (6, 6, 0), (5, 5, 1), (6, 5, 1), (6, 4, 1)]"
      ],
      "code_start_line": 102,
      "code_end_line": 115,
      "parent": null,
      "params": [
        "viewDistance"
      ],
      "have_return": true,
      "code_content": "def coneRight(viewDistance=3):\n    L=[]\n    StartIndexX, StartIndexY = (3,6)\n    indexX, indexY = (StartIndexX,StartIndexY)\n    for h in range(viewDistance):\n        for k in range(viewDistance-h):\n            xLeft = indexX+1\n            L.append((xLeft, indexY, h))\n            indexX+=1\n        StartIndexX+=1\n        indexX = StartIndexX\n        indexY-=1\n    L.insert(1, (4,5,1))\n    return L\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\minigrid_ona.py/nearestObject",
        "OpenNARS-for-Applications\\misc\\Python\\minigrid_ona.py/observationToEvent"
      ],
      "reference_who": []
    },
    "coneLeft": {
      "type": "FunctionDef",
      "name": "coneLeft",
      "md_content": [
        "**coneLeft**: The function of coneLeft is to generate a list of coordinates representing a cone-shaped view to the left of a given starting position.\n\n**parameters**:\n- viewDistance (optional): An integer representing the distance of the cone-shaped view. The default value is 3.\n\n**Code Description**:\nThe coneLeft function takes an optional parameter, viewDistance, which determines the distance of the cone-shaped view. The function initializes an empty list, L, to store the coordinates of the cone-shaped view. It also initializes the starting position coordinates, StartIndexX and StartIndexY, to (3, 6). Two additional variables, indexX and indexY, are set to the starting position coordinates.\n\nThe function then enters a nested loop, where the outer loop iterates over the range of viewDistance, and the inner loop iterates over the range of viewDistance minus the current outer loop index. Within the inner loop, the variable xLeft is calculated by subtracting 1 from indexX. The coordinates (xLeft, indexY, h) are appended to the list L. The indexX is decremented by 1 in each iteration of the inner loop.\n\nAfter the inner loop completes, the starting position coordinates, StartIndexX and StartIndexY, are decremented by 1. The indexX is reset to the updated StartIndexX, and the indexY is decremented by 1. This process is repeated for the remaining iterations of the outer loop.\n\nFinally, the coordinates (2, 5, 1) are inserted at index 1 in the list L. The function then returns the list L.\n\n**Note**: \n- The coneLeft function generates a cone-shaped view to the left of the starting position.\n- The viewDistance parameter determines the distance of the cone-shaped view. The default value is 3.\n- The coordinates in the returned list represent the x and y positions, as well as the height (h) of each point in the cone-shaped view.\n\n**Output Example**:\n[(2, 5, 1), (2, 6, 0), (1, 6, 0), (1, 7, 0), (0, 7, 0), (0, 8, 0)]"
      ],
      "code_start_line": 117,
      "code_end_line": 130,
      "parent": null,
      "params": [
        "viewDistance"
      ],
      "have_return": true,
      "code_content": "def coneLeft(viewDistance=3):\n    L=[]\n    StartIndexX, StartIndexY = (3,6)\n    indexX, indexY = (StartIndexX,StartIndexY)\n    for h in range(viewDistance):\n        for k in range(viewDistance-h):\n            xLeft = indexX-1\n            L.append((xLeft, indexY, h))\n            indexX-=1\n        StartIndexX-=1\n        indexX = StartIndexX\n        indexY-=1\n    L.insert(1, (2,5,1))\n    return L\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\minigrid_ona.py/nearestObject",
        "OpenNARS-for-Applications\\misc\\Python\\minigrid_ona.py/observationToEvent"
      ],
      "reference_who": []
    },
    "scan": {
      "type": "FunctionDef",
      "name": "scan",
      "md_content": [
        "**scan**: The function of scan is to perform a scan of the environment using a cone-shaped sensor and return information about the nearest object or wall.\n\n**parameters**:\n- cone: A function that represents the cone-shaped sensor used for scanning the environment.\n- cells: A 3-dimensional array representing the grid cells of the environment.\n- colorBlind: A boolean parameter indicating whether the scanning should be color-blind or not. It is set to True by default.\n- wall: A boolean parameter indicating whether the scanning should consider walls or not. It is set to False by default.\n\n**Code Description**:\nThe scan function starts by checking if the scanning should be color-blind. If colorBlind is True, it sets the value of the cell at position (3, 6, 1) in the cells array to 0.\n\nNext, it calls the cone function and assigns the returned value to the variable L.\n\nThen, it iterates over each tuple (x, y, distance) in L. For each tuple, it checks if the scanning should be color-blind. If colorBlind is True, it sets the value of the cell at position (x, y, 1) in the cells array to 0.\n\nIt then checks if the value of the cell at position (x, y, 0) in the cells array is not equal to 0, 1, and if the distance is 0 or wall is True or the value of the cell at position (x, y, 0) is not equal to 2. If this condition is true, it returns the distance and the cell at position (x, y) in the cells array.\n\nIf no non-empty cell is found, it checks if wall is False. If wall is False, it recursively calls the scan function with the same parameters but with wall set to True. This is done to find the nearest wall.\n\nIf no non-empty cell or wall is found, it returns a distance of 9999 and a numpy array representing an empty cell.\n\n**Note**: \n- The scan function assumes that the cells array is properly initialized and has the correct dimensions.\n- The cone function is expected to return a list of tuples representing the objects detected by the sensor. Each tuple contains the x and y coordinates of the object and the distance from the sensor.\n\n**Output Example**:\n- If a non-empty cell is found, the function may return a tuple like (3, [1, 0, 0]) representing the distance and the cell's state.\n- If no non-empty cell or wall is found, the function may return (9999, [1, 0, 0]) representing a distance of 9999 and an empty cell."
      ],
      "code_start_line": 132,
      "code_end_line": 143,
      "parent": null,
      "params": [
        "cone",
        "cells",
        "colorBlind",
        "wall"
      ],
      "have_return": true,
      "code_content": "def scan(cone, cells, colorBlind=True, wall=False):\n    if colorBlind:\n        cells[3][6][1] = 0\n    L = cone()\n    for (x,y,distance) in L:\n        if colorBlind:\n            cells[x][y][1] = 0\n        if cells[x][y][0] != 0 and cells[x][y][0] != 1 and (distance==0 or wall or cells[x][y][0] != 2): #a seen object or physical contact with a wall: #a seen object or physical contact with a wall\n            return distance, cells[x][y] #return first non-empty cell\n    if not wall:\n        return scan(cone, cells, colorBlind=colorBlind, wall=True) #nearest wall\n    return 9999, np.array([1,0,0])\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\minigrid_ona.py/nearestObject",
        "OpenNARS-for-Applications\\misc\\Python\\minigrid_ona.py/observationToEvent"
      ],
      "reference_who": []
    },
    "stateconcat": {
      "type": "FunctionDef",
      "name": "stateconcat",
      "md_content": [
        "**stateconcat**: The function of stateconcat is to concatenate the elements of a given state into a single string, removing any newline characters and spaces.\n\n**parameters**:\n- state: A state object containing multiple elements.\n\n**Code Description**:\nThe stateconcat function takes a state object as input and converts it into a string representation. It achieves this by first converting the state object to a string using the str() function. Then, it uses the replace() method to remove any newline characters (\"\\n\") and spaces (\" \") from the string representation of the state. The resulting string is then returned as the output of the function.\n\nThis function is used to convert the state objects into a format that can be easily processed or compared with other strings. By removing newline characters and spaces, the resulting string can be used as a compact representation of the state.\n\nIn the context of the project, the stateconcat function is called by two other functions: nearestObject and observationToEvent. Both of these functions use the stateconcat function to convert the state objects into strings before further processing or encoding them.\n\nThe nearestObject function uses the stateconcat function to convert the \"forward\", \"left\", and \"right\" states into strings before encoding them using the encode() function. The resulting encoded strings are then returned as the output of the nearestObject function.\n\nThe observationToEvent function also uses the stateconcat function to convert the \"forward\", \"left\", and \"right\" states into strings before encoding them using the encode() function. Additionally, it uses the stateconcat function to convert the \"holding\" state into a string representation. These encoded strings are then combined with the logical operators \" &/ \" and \" :|: \" to form a Narsese statement, which is returned as the output of the observationToEvent function.\n\n**Note**: \n- The stateconcat function assumes that the input state object has a valid string representation.\n- The resulting string from the stateconcat function may not preserve the original formatting of the state object.\n- The stateconcat function only removes newline characters and spaces from the string representation of the state. Other characters or formatting may still be present in the resulting string.\n\n**Output Example**:\nIf the input state is:\n```\n[\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\n```\nThe output of the stateconcat function would be:\n```\n'[[1,2,3],[4,5,6],[7,8,9]]'\n```"
      ],
      "code_start_line": 145,
      "code_end_line": 146,
      "parent": null,
      "params": [
        "state"
      ],
      "have_return": true,
      "code_content": "def stateconcat(state):\n    return str(state).replace(\"\\n\",\"\").replace(\" \",\"\")\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\minigrid_ona.py/nearestObject",
        "OpenNARS-for-Applications\\misc\\Python\\minigrid_ona.py/observationToEvent"
      ],
      "reference_who": []
    },
    "encode": {
      "type": "FunctionDef",
      "name": "encode",
      "md_content": [
        "**encode**: The function of encode is to encode the given direction and state into a NARSese string.\n\n**parameters**:\n- direction: A string representing the direction.\n- state: A string representing the state.\n\n**Code Description**:\nThe encode function takes in a direction and a state as parameters. It first removes the square brackets from the state string using the replace() method. Then, it creates a NARSese string by formatting the state and direction into a specific pattern. The state is enclosed in double curly braces, while the direction is enclosed in square brackets. The resulting NARSese string is returned as the output.\n\nThis function is called by two other objects in the project: nearestObject and observationToEvent. In the nearestObject function, the encode function is used to encode the direction and the concatenated forward, left, and right states. The encoded string is then returned as the output. In the observationToEvent function, the encode function is used to encode the directions and the concatenated forward, left, and right states. The encoded strings are further used to construct a NARSese string, which is returned as the final output.\n\n**Note**: \n- The encode function assumes that the state parameter is a string representation of a list, where the square brackets are used to enclose the elements of the list.\n- The encode function uses the f-string formatting syntax to create the NARSese string.\n\n**Output Example**:\nIf the direction is \"forward\" and the state is \"[A, B, C]\", the output of the encode function would be \"<{A, B, C} --> [forward]>\"."
      ],
      "code_start_line": 148,
      "code_end_line": 151,
      "parent": null,
      "params": [
        "direction",
        "state"
      ],
      "have_return": true,
      "code_content": "def encode(direction, state):\n    state = state.replace(\"[\",\"\").replace(\"]\",\"\")\n    ret = f\"<{{{state}}} --> [{direction}]>\"\n    return ret\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\minigrid_ona.py/nearestObject",
        "OpenNARS-for-Applications\\misc\\Python\\minigrid_ona.py/observationToEvent"
      ],
      "reference_who": []
    },
    "nearestObject": {
      "type": "FunctionDef",
      "name": "nearestObject",
      "md_content": [
        "**nearestObject**: The function of nearestObject is to determine the nearest object in a grid environment based on the distances obtained from scanning the cells in different directions.\n\n**parameters**:\n- cells: A 3-dimensional array representing the grid cells of the environment.\n\n**Code Description**:\nThe nearestObject function takes in the cells parameter, which represents the grid cells of the environment. It performs three scans using the coneForward, coneLeft, and coneRight functions to obtain the distances and states of the objects in front, to the left, and to the right of the agent, respectively.\n\nThe function first calls the scan function with the coneForward function and the cells parameter to obtain the distance and state of the objects in front of the agent. It then calls the scan function with the coneLeft function and the cells parameter to obtain the distance and state of the objects to the left of the agent. Finally, it calls the scan function with the coneRight function and the cells parameter to obtain the distance and state of the objects to the right of the agent.\n\nThe function then compares the distances obtained from the scans. If the distance in front is less than or equal to the distances to the left and right, it encodes the direction as \"forward\" and concatenates the state obtained from the scan in front. If the distance to the left is less than or equal to the distances in front and to the right, it encodes the direction as \"left\" and concatenates the state obtained from the scan to the left. If the distance to the right is less than or equal to the distances in front and to the left, it encodes the direction as \"right\" and concatenates the state obtained from the scan to the right.\n\nThe function returns the encoded direction and concatenated state as the output.\n\n**Note**: \n- The coneForward, coneLeft, and coneRight functions are used to scan the cells and obtain the distances and states of the objects in different directions.\n- The scan function is used to perform the scanning using the cone-shaped sensor and return information about the nearest object or wall.\n- The encode function is used to encode the direction and state into a NARSese string.\n- The stateconcat function is used to concatenate the elements of a given state into a single string.\n- The cells parameter represents the grid cells of the environment, where each cell contains information about the objects present.\n\n**Output Example**:\nIf the distances obtained from the scans are as follows:\n- Distance in front: 2\n- Distance to the left: 3\n- Distance to the right: 4\n\nThe function may return the following encoded string:\n\"<left --> [3,4,5,6]>\""
      ],
      "code_start_line": 153,
      "code_end_line": 162,
      "parent": null,
      "params": [
        "cells"
      ],
      "have_return": true,
      "code_content": "def nearestObject(cells):\n    dist_f, forward = scan(coneForward, cells)\n    dist_l, left = scan(coneLeft, cells)\n    dist_r, right = scan(coneRight, cells)\n    if dist_f <= dist_l and dist_f <= dist_r:\n        return encode(\"forward\", stateconcat(forward))\n    if dist_l <= dist_f and dist_l <= dist_r:\n        return encode(\"left\", stateconcat(left))\n    if dist_r <= dist_l and dist_r <= dist_f:\n        return encode(\"right\", stateconcat(right))\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\minigrid_ona.py/observationToEvent"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\minigrid_ona.py/coneForward",
        "OpenNARS-for-Applications\\misc\\Python\\minigrid_ona.py/coneRight",
        "OpenNARS-for-Applications\\misc\\Python\\minigrid_ona.py/coneLeft",
        "OpenNARS-for-Applications\\misc\\Python\\minigrid_ona.py/scan",
        "OpenNARS-for-Applications\\misc\\Python\\minigrid_ona.py/stateconcat",
        "OpenNARS-for-Applications\\misc\\Python\\minigrid_ona.py/encode"
      ]
    },
    "observationToEvent": {
      "type": "FunctionDef",
      "name": "observationToEvent",
      "md_content": [
        "**observationToEvent**: The function of observationToEvent is to convert the information obtained from scanning the grid environment into a NARSese statement representing the current observation.\n\n**parameters**:\n- cells: A 3-dimensional array representing the grid cells of the environment.\n\n**Code Description**:\nThe observationToEvent function takes in the cells parameter, which represents the grid cells of the environment. It performs three scans using the coneForward, coneLeft, and coneRight functions to obtain the distances and states of the objects in front, to the left, and to the right of the agent, respectively.\n\nThe function first calls the scan function with the coneForward function and the cells parameter to obtain the distance and state of the objects in front of the agent. It then calls the scan function with the coneLeft function and the cells parameter to obtain the distance and state of the objects to the left of the agent. Finally, it calls the scan function with the coneRight function and the cells parameter to obtain the distance and state of the objects to the right of the agent.\n\nThe function then uses the stateconcat function to concatenate the obtained states into single strings. It further uses the encode function to encode the directions and the concatenated states into NARSese strings. The encoded strings are combined with the logical operators \" &/ \" and \" :|: \" to form a Narsese statement representing the current observation.\n\nThe Narsese statement is returned as the output of the observationToEvent function.\n\n**Note**: \n- The coneForward, coneLeft, and coneRight functions are used to scan the cells and obtain the distances and states of the objects in different directions.\n- The scan function is used to perform the scanning using the cone-shaped sensor and return information about the nearest object or wall.\n- The encode function is used to encode the direction and state into a NARSese string.\n- The stateconcat function is used to concatenate the elements of a given state into a single string.\n- The cells parameter represents the grid cells of the environment, where each cell contains information about the objects present.\n\n**Output Example**:\nIf the distances obtained from the scans are as follows:\n- Distance in front: 2\n- Distance to the left: 3\n- Distance to the right: 4\n\nThe function may return the following Narsese statement:\n\"( [3,4,5,6] &/ [1,2,3] ). :|:\""
      ],
      "code_start_line": 165,
      "code_end_line": 172,
      "parent": null,
      "params": [
        "cells"
      ],
      "have_return": true,
      "code_content": "def observationToEvent(cells):\n    forward = encode(\"forward\", stateconcat(scan(coneForward,cells)[1]))\n    left = encode(\"left\", stateconcat(scan(coneLeft,cells)[1]))\n    right = encode(\"right\", stateconcat(scan(coneRight,cells)[1]))\n    inventory = encode(\"holding\", stateconcat(cells[3][6]))\n    obj = nearestObject(cells)\n    narsese = \"( \" + obj + \" &/ \" + inventory + \" ). :|:\"\n    return narsese\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\minigrid_ona.py/coneForward",
        "OpenNARS-for-Applications\\misc\\Python\\minigrid_ona.py/coneRight",
        "OpenNARS-for-Applications\\misc\\Python\\minigrid_ona.py/coneLeft",
        "OpenNARS-for-Applications\\misc\\Python\\minigrid_ona.py/scan",
        "OpenNARS-for-Applications\\misc\\Python\\minigrid_ona.py/stateconcat",
        "OpenNARS-for-Applications\\misc\\Python\\minigrid_ona.py/encode",
        "OpenNARS-for-Applications\\misc\\Python\\minigrid_ona.py/nearestObject"
      ]
    }
  },
  "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py": {
    "ValueReporter": {
      "type": "ClassDef",
      "name": "ValueReporter",
      "md_content": [
        "**ValueReporter**: The ValueReporter class is responsible for reporting values and calculating the frequency and confidence of sensed values based on a given input.\n\n**Attributes**:\n- `values`: A list that stores the values reported by the ValueReporter.\n- `AIKR_Limit`: An optional parameter that sets the limit for the number of values to be stored in the `values` list.\n\n**Code Description**:\nThe `ValueReporter` class has an `__init__` method that initializes the `values` list and sets the `AIKR_Limit` attribute. The `reportValue` method takes an input value `x` and calculates the frequency and confidence of the sensed value based on the values stored in the `values` list.\n\nThe `reportValue` method first checks if `RangeUpdate` is set to True. If it is, the input value `x` is appended to the `values` list. If the `AIKR_Limit` attribute is not None, the `values` list is truncated to the last `AIKR_Limit` values.\n\nNext, the method calculates the weights `wplus` and `wminus` based on the values in the `values` list. The weight is determined by the absolute difference between the input value `x` and each value in the `values` list. If a value in the `values` list is less than `x`, the weight is added to `wplus`. If a value in the `values` list is greater than `x`, the weight is added to `wminus`.\n\nThe total weight `w` is calculated as the sum of `wplus` and `wminus`. The frequency is calculated as the ratio of `wplus` to the total weight `w`, and the confidence is calculated as the ratio of `w` to `w+1.0`. The sensed value truth is represented as a tuple `(frequency, confidence * Sensation_Reliance)`.\n\nIf the `Print` parameter is set to True, the sensed value truth is printed to the console. Finally, the sensed value truth is returned.\n\n**Note**: \n- The `ValueReporter` class can be used to track and analyze the frequency and confidence of sensed values over time.\n- The `AIKR_Limit` attribute can be used to limit the number of values stored in the `values` list.\n- The `reportValue` method calculates the frequency and confidence of the sensed value based on the values stored in the `values` list.\n- The `RangeUpdate` parameter determines whether the `values` list should be updated with the new input value.\n- The `Uniform_Weight` parameter determines whether the weights should be calculated uniformly or based on the absolute difference between the input value and each value in the `values` list.\n- The `Print` parameter determines whether the sensed value truth should be printed to the console.\n\n**Output Example**:\nIf the `Print` parameter is set to True, the following output may be printed to the console:\n```\n<{S} --> [P]>. :|: {frequency, confidence * Sensation_Reliance} from value x\n```\nThe sensed value truth is returned as a tuple `(frequency, confidence * Sensation_Reliance)`."
      ],
      "code_start_line": 4,
      "code_end_line": 27,
      "parent": null,
      "params": [],
      "have_return": true,
      "code_content": "class ValueReporter:\n  def __init__(self, AIKR_Limit=1000):\n    self.values = []\n    self.AIKR_Limit = AIKR_Limit\n  def reportValue(self, x, Sensation_Reliance = 0.9, RangeUpdate=True, Uniform_Weight=False, Print=False):\n    if RangeUpdate:\n        self.values.append(x)\n        if self.AIKR_Limit != None:\n            self.values = self.values[-self.AIKR_Limit:]\n    wplus = 0\n    wminus = 0\n    for y in self.values:\n      weight = 1.0 if Uniform_Weight else abs(x - y)\n      if y < x:\n        wplus += weight\n      elif y > x:\n        wminus += weight\n    w = wplus+wminus\n    frequency = wplus/(wplus+wminus) if w > 0 else 0.5\n    confidence = w/(w+1.0) if w > 0 else 0.0\n    Sensed_Value_Truth = (frequency, confidence * Sensation_Reliance)\n    if Print:\n        print(\"<{S} --> [P]>. :|:\", str(Sensed_Value_Truth).replace(\"(\",\"{\").replace(\")\",\"}\"), \"from value\", x)\n    return Sensed_Value_Truth\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Nalifier/AddInput",
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Nalifier/AddInputVector",
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Nalifier/ShellInput"
      ],
      "reference_who": []
    },
    "reportValue": {
      "type": "FunctionDef",
      "name": "reportValue",
      "md_content": [
        "**reportValue**: The function of reportValue is to calculate the frequency and confidence of a given value based on a list of previously reported values.\n\n**parameters**:\n- x: The value for which the frequency and confidence need to be calculated.\n- Sensation_Reliance (optional): The reliance factor for the confidence calculation. Default value is 0.9.\n- RangeUpdate (optional): A boolean flag indicating whether to update the list of values. Default value is True.\n- Uniform_Weight (optional): A boolean flag indicating whether to use uniform weight for the calculation. Default value is False.\n- Print (optional): A boolean flag indicating whether to print the calculated values. Default value is False.\n\n**Code Description**:\nThe function first checks if the RangeUpdate flag is set to True. If it is, the given value is appended to the list of values. If the AIKR_Limit (an attribute of the object) is not None, the list of values is trimmed to the last AIKR_Limit elements.\n\nNext, the function initializes two variables, wplus and wminus, to keep track of the weights for values greater than and less than the given value, respectively.\n\nThen, a loop iterates over each value in the list of values. For each value, the weight is calculated as either 1.0 (if Uniform_Weight is True) or the absolute difference between the given value and the current value. If the current value is less than the given value, the weight is added to wplus. If the current value is greater than the given value, the weight is added to wminus.\n\nAfter the loop, the total weight, w, is calculated as the sum of wplus and wminus. The frequency is calculated as the ratio of wplus to the total weight (wplus + wminus), unless the total weight is 0, in which case the frequency is set to 0.5. The confidence is calculated as the ratio of w to (w + 1.0), unless the total weight is 0, in which case the confidence is set to 0.0.\n\nThe Sensed_Value_Truth is then calculated as a tuple containing the frequency and the confidence multiplied by the Sensation_Reliance.\n\nIf the Print flag is set to True, the calculated values are printed.\n\nFinally, the Sensed_Value_Truth is returned as the output of the function.\n\n**Note**:\n- The RangeUpdate flag determines whether the list of values should be updated with the given value. If set to False, the list remains unchanged.\n- The Uniform_Weight flag determines whether all values have equal weight in the calculation. If set to True, the weight is always 1.0.\n- The Print flag can be used to display the calculated values for debugging or monitoring purposes.\n\n**Output Example**:\nIf the function is called with x=5, Sensation_Reliance=0.9, RangeUpdate=True, Uniform_Weight=False, and Print=False, the output could be:\n(0.75, 0.6923076923076923)"
      ],
      "code_start_line": 8,
      "code_end_line": 27,
      "parent": "ValueReporter",
      "params": [
        "self",
        "x",
        "Sensation_Reliance",
        "RangeUpdate",
        "Uniform_Weight",
        "Print"
      ],
      "have_return": true,
      "code_content": "  def reportValue(self, x, Sensation_Reliance = 0.9, RangeUpdate=True, Uniform_Weight=False, Print=False):\n    if RangeUpdate:\n        self.values.append(x)\n        if self.AIKR_Limit != None:\n            self.values = self.values[-self.AIKR_Limit:]\n    wplus = 0\n    wminus = 0\n    for y in self.values:\n      weight = 1.0 if Uniform_Weight else abs(x - y)\n      if y < x:\n        wplus += weight\n      elif y > x:\n        wminus += weight\n    w = wplus+wminus\n    frequency = wplus/(wplus+wminus) if w > 0 else 0.5\n    confidence = w/(w+1.0) if w > 0 else 0.0\n    Sensed_Value_Truth = (frequency, confidence * Sensation_Reliance)\n    if Print:\n        print(\"<{S} --> [P]>. :|:\", str(Sensed_Value_Truth).replace(\"(\",\"{\").replace(\")\",\"}\"), \"from value\", x)\n    return Sensed_Value_Truth\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "Truth_c2w": {
      "type": "FunctionDef",
      "name": "Truth_c2w",
      "md_content": [
        "**Truth_c2w**: The function of Truth_c2w is to calculate the complementary value of a given confidence value.\n\n**parameters**:\n- c: A float value representing the confidence value.\n\n**Code Description**:\nThe Truth_c2w function takes a confidence value as input and calculates its complementary value using the formula c / (1 - c). This formula is derived from the definition of confidence in the context of the NARS (Non-Axiomatic Reasoning System) framework.\n\nIn the NARS framework, confidence represents the degree of belief in a statement or proposition. It ranges from 0 to 1, where 0 indicates complete disbelief and 1 indicates absolute certainty. The complementary value of confidence is used to represent the degree of disbelief.\n\nThe function first calculates the complementary value by dividing the confidence value by the difference between 1 and the confidence value. This ensures that the result is within the range of 0 to 1.\n\n**Note**:\n- The input confidence value should be a float between 0 and 1, inclusive.\n- The function does not handle division by zero. If the input confidence value is 1, the function will raise a ZeroDivisionError.\n\n**Output Example**:\n- Example 1:\n  - Input: c = 0.7\n  - Output: 2.3333333333333335\n- Example 2:\n  - Input: c = 0.2\n  - Output: 0.25"
      ],
      "code_start_line": 29,
      "code_end_line": 30,
      "parent": null,
      "params": [
        "c"
      ],
      "have_return": true,
      "code_content": "def Truth_c2w(c):\n    return c / (1 - c);\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Truth_Revision"
      ],
      "reference_who": []
    },
    "Truth_w2c": {
      "type": "FunctionDef",
      "name": "Truth_w2c",
      "md_content": [
        "**Truth_w2c**: The function of Truth_w2c is to calculate the truth value confidence based on the given weight.\n\n**parameters**:\n- w: A numeric value representing the weight.\n\n**Code Description**:\nThe Truth_w2c function takes a weight value as input and calculates the truth value confidence based on the weight. It uses a conditional statement to check if the weight is greater than 0. If it is, the function calculates the truth value confidence by dividing the weight by the sum of the weight and 1. If the weight is not greater than 0, the function returns 0.\n\nThis function is used in several other functions within the project. It is called by the following objects:\n\n1. OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/TruthValue:\n   - The TruthValue function calls the Truth_w2c function as part of its return statement. It passes the sum of two weight values (w_plus and w_minus) as the input to the Truth_w2c function. The return value of the Truth_w2c function is used to calculate the second element of the return value of the TruthValue function.\n\n2. OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Truth_Abduction:\n   - The Truth_Abduction function calls the Truth_w2c function as part of its return statement. It passes the product of three values (f1, c1, and c2) as the input to the Truth_w2c function. The return value of the Truth_w2c function is used to calculate the second element of the return value of the Truth_Abduction function.\n\n3. OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Truth_Comparison:\n   - The Truth_Comparison function calls the Truth_w2c function as part of its return statement. It passes the product of three values (f0, c1, and c2) as the input to the Truth_w2c function. The return value of the Truth_w2c function is used to calculate the second element of the return value of the Truth_Comparison function.\n\n4. OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Truth_Revision:\n   - The Truth_Revision function calls the Truth_w2c function as part of its return statement. It passes the product of three values (f0, c1, and c2) as the input to the Truth_w2c function. The return value of the Truth_w2c function is used to calculate the second element of the return value of the Truth_Revision function.\n\n**Note**: \n- The Truth_w2c function expects a numeric value as input for the weight parameter.\n- The function returns a numeric value representing the truth value confidence.\n- The function uses a conditional statement to handle the case when the weight is not greater than 0.\n\n**Output Example**:\nIf the weight value is 2, the function will return 0.6666666666666666."
      ],
      "code_start_line": 32,
      "code_end_line": 33,
      "parent": null,
      "params": [
        "w"
      ],
      "have_return": true,
      "code_content": "def Truth_w2c(w):\n    return w/(w + 1) if w > 0 else 0\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/TruthValue",
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Truth_Abduction",
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Truth_Comparison",
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Truth_Revision"
      ],
      "reference_who": []
    },
    "Truth_w2f": {
      "type": "FunctionDef",
      "name": "Truth_w2f",
      "md_content": [
        "**Truth_w2f**: The function of Truth_w2f is to calculate the truth value of a given proposition based on the positive and negative weights assigned to it.\n\n**parameters**:\n- w_plus: A numeric value representing the positive weight of the proposition.\n- w_minus: A numeric value representing the negative weight of the proposition.\n\n**Code Description**:\nThe Truth_w2f function takes two parameters, w_plus and w_minus, which represent the positive and negative weights of a proposition, respectively. It calculates the truth value of the proposition using the following formula:\n\n```\nw_plus / (w_plus + w_minus) if w_plus + w_minus > 0 else 0.5\n```\n\nIf the sum of w_plus and w_minus is greater than 0, the function divides w_plus by the sum of w_plus and w_minus to calculate the truth value. Otherwise, it returns a default truth value of 0.5.\n\nThis function is called by the TruthValue function in the Nalifier.py module. The TruthValue function uses the Truth_w2f function to calculate the truth value of a proposition and combines it with the truth value calculated by the Truth_w2c function to return a tuple of truth values.\n\n**Note**:\n- The Truth_w2f function assumes that the positive and negative weights provided are numeric values.\n- If the sum of w_plus and w_minus is 0 or less, the function returns a default truth value of 0.5.\n\n**Output Example**:\nIf w_plus is 3 and w_minus is 1, the function will return 0.75."
      ],
      "code_start_line": 35,
      "code_end_line": 36,
      "parent": null,
      "params": [
        "w_plus",
        "w_minus"
      ],
      "have_return": true,
      "code_content": "def Truth_w2f(w_plus, w_minus):\n    return w_plus / (w_plus + w_minus) if w_plus + w_minus > 0 else 0.5\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/TruthValue"
      ],
      "reference_who": []
    },
    "TruthValue": {
      "type": "FunctionDef",
      "name": "TruthValue",
      "md_content": [
        "**TruthValue**: The function of TruthValue is to calculate the truth value of a proposition based on the positive and negative weights assigned to it.\n\n**parameters**:\n- w_plus: A numeric value representing the positive weight of the proposition.\n- w_minus: A numeric value representing the negative weight of the proposition.\n\n**Code Description**:\nThe TruthValue function takes two parameters, w_plus and w_minus, which represent the positive and negative weights of a proposition, respectively. It calculates the truth value of the proposition by calling two other functions: Truth_w2f and Truth_w2c. \n\nThe Truth_w2f function is responsible for calculating the truth value based on the positive and negative weights. It divides the positive weight (w_plus) by the sum of the positive and negative weights (w_plus + w_minus) to calculate the truth value. If the sum of the weights is 0 or less, the function returns a default truth value of 0.5.\n\nThe Truth_w2c function is responsible for calculating the truth value confidence based on the given weight. It takes a weight value as input and calculates the truth value confidence by dividing the weight by the sum of the weight and 1. If the weight is not greater than 0, the function returns 0.\n\nThe TruthValue function calls both the Truth_w2f and Truth_w2c functions as part of its return statement. It passes the positive and negative weights (w_plus and w_minus) to the Truth_w2f function and the sum of the weights to the Truth_w2c function. The return values of both functions are combined into a tuple and returned as the result of the TruthValue function.\n\nThis function is used in several other functions within the project. It is called by the following objects:\n\n1. Truth_Abduction: The Truth_Abduction function calls the TruthValue function as part of its return statement. It passes the product of three values (f1, c1, and c2) as the input to the TruthValue function. The return value of the TruthValue function is used to calculate the second element of the return value of the Truth_Abduction function.\n\n2. Truth_Comparison: The Truth_Comparison function calls the TruthValue function as part of its return statement. It passes the product of three values (f0, c1, and c2) as the input to the TruthValue function. The return value of the TruthValue function is used to calculate the second element of the return value of the Truth_Comparison function.\n\n3. Truth_Revision: The Truth_Revision function calls the TruthValue function as part of its return statement. It passes the product of three values (f0, c1, and c2) as the input to the TruthValue function. The return value of the TruthValue function is used to calculate the second element of the return value of the Truth_Revision function.\n\n**Note**: \n- The TruthValue function expects two numeric values as input for the positive and negative weights.\n- The function returns a tuple of two numeric values representing the truth value and truth value confidence.\n- The Truth_w2f function assumes that the positive and negative weights provided are numeric values.\n- The Truth_w2c function expects a numeric value as input for the weight parameter.\n- The Truth_w2c function returns a numeric value representing the truth value confidence.\n- The Truth_w2c function uses a conditional statement to handle the case when the weight is not greater than 0.\n\n**Output Example**:\nIf w_plus is 3 and w_minus is 1, the function will return (0.75, 0.75)."
      ],
      "code_start_line": 38,
      "code_end_line": 39,
      "parent": null,
      "params": [
        "w_plus",
        "w_minus"
      ],
      "have_return": true,
      "code_content": "def TruthValue(w_plus, w_minus):\n    return (Truth_w2f(w_plus, w_minus), Truth_w2c(w_plus + w_minus))\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Truth_w2c",
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Truth_w2f"
      ]
    },
    "Truth_Abduction": {
      "type": "FunctionDef",
      "name": "Truth_Abduction",
      "md_content": [
        "**Truth_Abduction**: The function of Truth_Abduction is to perform truth abduction based on two input values.\n\n**parameters**:\n- v1: The first input value, represented as a tuple (f1, c1).\n- v2: The second input value, represented as a tuple (f2, c2).\n\n**Code Description**:\nThe Truth_Abduction function takes two input values, v1 and v2, and performs truth abduction based on these values. It first unpacks the tuples to extract the factors and confidences, assigning them to variables f1, c1, f2, and c2. It then calls the Truth_w2c function with the product of f1, c1, and c2 as the input. The return value of the Truth_w2c function is combined with f2 to form a new tuple, which is returned as the result of the Truth_Abduction function.\n\n**Note**:\n- The Truth_w2c function is called within the Truth_Abduction function to calculate the truth value confidence.\n- The input values v1 and v2 are expected to be tuples containing factors and confidences.\n- The function assumes that the Truth_w2c function is defined and accessible.\n\n**Output Example**:\nIf v1 is (0.8, 0.6) and v2 is (0.5, 0.7), the function will return (0.5, 0.4666666666666667)."
      ],
      "code_start_line": 41,
      "code_end_line": 43,
      "parent": null,
      "params": [
        "v1",
        "v2"
      ],
      "have_return": true,
      "code_content": "def Truth_Abduction(v1, v2):\n    ((f1,c1), (f2,c2)) = (v1, v2)\n    return (f2, Truth_w2c(f1 * c1 * c2))\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Truth_Induction",
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Nalifier/inheritances"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Truth_w2c"
      ]
    },
    "Truth_Induction": {
      "type": "FunctionDef",
      "name": "Truth_Induction",
      "md_content": [
        "**Truth_Induction**: The function of Truth_Induction is to perform truth induction based on two input values.\n\n**parameters**:\n- v1: The first input value, represented as a tuple (f1, c1).\n- v2: The second input value, represented as a tuple (f2, c2).\n\n**Code Description**:\nThe Truth_Induction function takes two input values, v1 and v2, and performs truth induction based on these values. It calls the Truth_Abduction function with v2 as the first argument and v1 as the second argument. The return value of the Truth_Abduction function is then returned as the result of the Truth_Induction function.\n\n**Note**:\n- The Truth_Abduction function is called within the Truth_Induction function to perform truth abduction.\n- The input values v1 and v2 are expected to be tuples containing factors and confidences.\n- The function assumes that the Truth_Abduction function is defined and accessible.\n\n**Output Example**:\nIf v1 is (0.8, 0.6) and v2 is (0.5, 0.7), the function will return (0.5, 0.4666666666666667)."
      ],
      "code_start_line": 45,
      "code_end_line": 46,
      "parent": null,
      "params": [
        "v1",
        "v2"
      ],
      "have_return": true,
      "code_content": "def Truth_Induction(v1, v2):\n    return Truth_Abduction(v2, v1)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Nalifier/inheritances"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Truth_Abduction"
      ]
    },
    "Truth_Comparison": {
      "type": "FunctionDef",
      "name": "Truth_Comparison",
      "md_content": [
        "**Truth_Comparison**: The function of Truth_Comparison is to compare the truth values of two given inputs and calculate a new truth value based on the comparison.\n\n**parameters**:\n- v1: The first input value, which is a tuple containing two elements: (f1, c1). f1 represents the belief in the truth value, and c1 represents the confidence in the truth value.\n- v2: The second input value, which is also a tuple containing two elements: (f2, c2). f2 represents the belief in the truth value, and c2 represents the confidence in the truth value.\n\n**Code Description**:\nThe Truth_Comparison function takes two input values, v1 and v2, and extracts the belief and confidence values from each input. It then calculates a new belief value, f0, using the formula: f0 = 1.0 - (1.0 - f1) * (1.0 - f2). This formula combines the belief values of the two inputs to calculate a new belief value.\n\nNext, the function checks if the calculated belief value, f0, is equal to 0.0. If it is, the function returns 0.0. Otherwise, it calculates a new confidence value using the Truth_w2c function, passing the product of f0, c1, and c2 as the weight parameter. The Truth_w2c function calculates the truth value confidence based on the given weight.\n\nFinally, the function returns a tuple containing two elements: the calculated belief value (0.0 if f0 is 0.0) and the calculated confidence value using the Truth_w2c function.\n\n**Note**:\n- The Truth_Comparison function expects two input values, v1 and v2, in the form of tuples.\n- The function uses the Truth_w2c function to calculate the truth value confidence.\n- The function handles the case when the calculated belief value, f0, is equal to 0.0 by returning 0.0.\n- The function returns a tuple containing the calculated belief value and confidence value.\n\n**Output Example**:\nIf v1 = (0.8, 0.9) and v2 = (0.6, 0.7), the function will return (0.6666666666666666, 0.8571428571428571)."
      ],
      "code_start_line": 48,
      "code_end_line": 51,
      "parent": null,
      "params": [
        "v1",
        "v2"
      ],
      "have_return": true,
      "code_content": "def Truth_Comparison(v1, v2):\n    ((f1,c1), (f2, c2)) = (v1, v2)   \n    f0 = 1.0 - (1.0 - f1) * (1.0 - f2)\n    return (0.0 if f0 == 0.0 else ((f1*f2) / f0), Truth_w2c(f0 * c1 * c2))\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Nalifier/inheritances"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Truth_w2c"
      ]
    },
    "Truth_FrequencyComparison": {
      "type": "FunctionDef",
      "name": "Truth_FrequencyComparison",
      "md_content": [
        "**Truth_FrequencyComparison**: The function of Truth_FrequencyComparison is to compare the truth values of two input values and calculate a new truth value based on their frequency difference.\n\n**parameters**:\n- v1: The first input value, which is a tuple containing a frequency value (f1) and a confidence value (c1).\n- v2: The second input value, which is also a tuple containing a frequency value (f2) and a confidence value (c2).\n\n**Code Description**:\nThe Truth_FrequencyComparison function takes two input values, v1 and v2, and extracts the frequency values (f1 and f2) and confidence values (c1 and c2) from them using tuple unpacking. It then calculates the absolute difference between the frequency values (abs(f1 - f2)) and subtracts it from 1.0 to obtain a new frequency value. The confidence values (c1 and c2) are multiplied together to obtain the new confidence value. Finally, the function returns a tuple containing the new frequency value and the new confidence value.\n\nThis function is called by two objects in the project: \"differenceEvaluate\" and \"inheritances\". In the \"differenceEvaluate\" function, the Truth_FrequencyComparison function is used to calculate the truth difference between two input values (T1 and T2). The result is then used to update the biggest difference property, truth, relation, and arguments based on certain conditions. In the \"inheritances\" function, the Truth_FrequencyComparison function is used to compare the truth values of two input values (T1 and T2) for different properties. The result is used to calculate the truth values for inheritance relationships and update the biggest difference property, truth, relation, and arguments.\n\n**Note**:\n- The input values (v1 and v2) should be tuples containing frequency and confidence values.\n- The function assumes that the input values have the correct format and structure.\n- The function does not handle any exceptions or errors that may occur during the calculation.\n\n**Output Example**:\nIf v1 = (0.8, 0.9) and v2 = (0.6, 0.7), the function will return (0.4, 0.63)."
      ],
      "code_start_line": 53,
      "code_end_line": 55,
      "parent": null,
      "params": [
        "v1",
        "v2"
      ],
      "have_return": true,
      "code_content": "def Truth_FrequencyComparison(v1, v2):\n    ((f1,c1), (f2,c2)) = (v1, v2)\n    return (1.0-abs(f1 - f2), c1*c2)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Nalifier/differenceEvaluate",
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Nalifier/inheritances"
      ],
      "reference_who": []
    },
    "Truth_Negation": {
      "type": "FunctionDef",
      "name": "Truth_Negation",
      "md_content": [
        "**Truth_Negation**: The function of Truth_Negation is to negate the truth value of a given proposition.\n\n**parameters**:\n- v1: A tuple representing a proposition, where the first element is the truth value (f) and the second element is the confidence value (c).\n\n**Code Description**:\nThe `Truth_Negation` function takes a proposition as input and returns a new proposition with the negated truth value. The input proposition is expected to be in the form of a tuple, where the first element represents the truth value and the second element represents the confidence value.\n\nThe function first unpacks the input tuple into two variables, `f` and `c`. It then calculates the negated truth value by subtracting the original truth value from 1.0. The confidence value remains unchanged.\n\nFinally, the function returns a new tuple with the negated truth value and the same confidence value.\n\nThis function is used in the `differenceEvaluate` method of the `Nalifier` class in the `Nalifier.py` file. In the `differenceEvaluate` method, the `Truth_Negation` function is called to negate the truth value of a comparison between two truth values. The result of this negation is used in further calculations to determine the biggest difference between two terms.\n\n**Note**:\n- The input proposition is expected to be a tuple with two elements.\n- The truth value of the input proposition should be a floating-point number between 0.0 and 1.0.\n- The confidence value of the input proposition can be any floating-point number.\n\n**Output Example**:\nIf the input proposition is `(0.8, 0.9)`, the function will return `(0.2, 0.9)`."
      ],
      "code_start_line": 57,
      "code_end_line": 59,
      "parent": null,
      "params": [
        "v1"
      ],
      "have_return": true,
      "code_content": "def Truth_Negation(v1):\n    (f, c) = v1\n    return (1.0-f, c)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Nalifier/differenceEvaluate",
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Nalifier/inheritances"
      ],
      "reference_who": []
    },
    "Truth_Revision": {
      "type": "FunctionDef",
      "name": "Truth_Revision",
      "md_content": [
        "**Truth_Revision**: The function of Truth_Revision is to perform truth revision based on the given input values.\n\n**parameters**:\n- v1: A tuple representing the first input value, consisting of a float value (f1) and a confidence value (c1).\n- v2: A tuple representing the second input value, consisting of a float value (f2) and a confidence value (c2).\n\n**Code Description**:\nThe Truth_Revision function takes two input values and performs truth revision based on these values. It first extracts the float values (f1 and f2) and confidence values (c1 and c2) from the input tuples (v1 and v2). Then, it calculates the weight values (w1 and w2) by calling the Truth_c2w function for each confidence value. The weight values are obtained by calculating the complementary values of the confidence values using the formula c / (1 - c).\n\nNext, the function calculates the total weight (w) by summing up the individual weight values (w1 and w2). If the total weight is equal to 0.0, indicating that both input values have a confidence value of 0, the function returns a tuple (0.5, 0.0) representing a neutral truth value.\n\nIf the total weight is not 0.0, the function proceeds to calculate the revised truth value. It uses the formula (w1 * f1 + w2 * f2) / w to calculate the revised float value. This formula calculates the weighted average of the input float values based on their respective weights. The result is then divided by the total weight to ensure that the revised float value is within the range of 0 to 1.\n\nThe function also calculates the revised confidence value using the Truth_w2c function. It passes the total weight (w) as the input to the Truth_w2c function. The Truth_w2c function calculates the truth value confidence based on the weight. If the weight is greater than 0, the function divides the weight by the sum of the weight and 1. If the weight is not greater than 0, the function returns 0.\n\nFinally, the function returns a tuple representing the revised truth value. The first element of the tuple is the revised float value, which is the result of the weighted average calculation. The second element of the tuple is the revised confidence value, which is the result of the Truth_w2c calculation. The function ensures that the revised confidence value is not greater than a maximum confidence value (MAX_CONFIDENCE), which is set to 0.99.\n\n**Note**:\n- The input values should be provided as tuples in the format ((float_value, confidence_value), (float_value, confidence_value)).\n- The confidence values should be floats between 0 and 1, inclusive.\n- The function uses the Truth_c2w and Truth_w2c functions to calculate the weight and confidence values, respectively.\n- The function handles the case when both input values have a confidence value of 0, returning a neutral truth value.\n- The function ensures that the revised confidence value is not greater than the maximum confidence value (MAX_CONFIDENCE).\n\n**Output Example**:\n- Example 1:\n  - Input: v1 = ((0.6, 0.8), (0.7, 0.9))\n  - Output: (0.65, 0.8888888888888888)\n- Example 2:\n  - Input: v1 = ((0.2, 0.5), (0.3, 0.6))\n  - Output: (0.25, 0.6666666666666666)"
      ],
      "code_start_line": 61,
      "code_end_line": 69,
      "parent": null,
      "params": [
        "v1",
        "v2"
      ],
      "have_return": true,
      "code_content": "def Truth_Revision(v1, v2):\n    MAX_CONFIDENCE = 0.99\n    ((f1,c1), (f2,c2)) = (v1, v2)\n    w1 = Truth_c2w(c1)\n    w2 = Truth_c2w(c2)\n    w = w1 + w2\n    if w == 0.0:\n        return (0.5, 0.0)\n    return ( min(1.0, (w1 * f1 + w2 * f2) / w), min(MAX_CONFIDENCE, max(max(Truth_w2c(w), c1), c2)))\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Nalifier/inheritances",
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Nalifier/AddInput"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Truth_c2w",
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Truth_w2c"
      ]
    },
    "Truth_Difference": {
      "type": "FunctionDef",
      "name": "Truth_Difference",
      "md_content": [
        "**Truth_Difference**: The function of Truth_Difference is to calculate the difference between two truth values.\n\n**parameters**:\n- v1: The first truth value, represented as a tuple (f1, c1), where f1 is the frequency and c1 is the confidence.\n- v2: The second truth value, represented as a tuple (f2, c2), where f2 is the frequency and c2 is the confidence.\n\n**Code Description**:\nThe Truth_Difference function takes two truth values as input and calculates the difference between them. The truth values are represented as tuples, where the first element represents the frequency and the second element represents the confidence.\n\nThe function first unpacks the input tuples into separate variables, f1, c1, f2, and c2. It then calculates the difference between the frequencies and the product of the confidences. The difference between the frequencies is calculated by subtracting the second frequency (f2) from the first frequency (f1) and multiplying it by the first frequency (f1 * (1.0 - f2)). The product of the confidences is calculated by multiplying the first confidence (c1) with the second confidence (c2) (c1 * c2).\n\nThe function returns the calculated difference as a tuple (f1 * (1.0 - f2), c1 * c2).\n\nThis function is used in the Nalifier.py module in the differenceEvaluate method of the Nalifier class. The differenceEvaluate method calculates the difference between two truth values and updates the biggestDifferenceProp, biggestDifferenceTruth, relation, biggestDifferenceArg1, and biggestDifferenceArg2 variables based on the calculated difference and other conditions. The Truth_Difference function is called within the differenceEvaluate method to calculate the truth difference.\n\n**Note**:\n- The input truth values should be represented as tuples with two elements: the frequency and the confidence.\n- The calculated difference is returned as a tuple with two elements: the difference between the frequencies and the product of the confidences.\n\n**Output Example**:\nIf the input truth values are v1 = (0.8, 0.9) and v2 = (0.6, 0.7), the function will return the difference as (0.16, 0.63)."
      ],
      "code_start_line": 71,
      "code_end_line": 73,
      "parent": null,
      "params": [
        "v1",
        "v2"
      ],
      "have_return": true,
      "code_content": "def Truth_Difference(v1, v2):\n    ((f1,c1), (f2,c2)) = (v1, v2)\n    return (f1 * (1.0 - f2), c1*c2)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Nalifier/differenceEvaluate"
      ],
      "reference_who": []
    },
    "Truth_Expectation": {
      "type": "FunctionDef",
      "name": "Truth_Expectation",
      "md_content": [
        "**Truth_Expectation**: The function of Truth_Expectation is to calculate the expectation value of a given truth value.\n\n**parameters**:\n- T: A tuple representing a truth value, where the first element is the frequency and the second element is the confidence.\n\n**Code Description**:\nThe `Truth_Expectation` function takes a truth value `T` as input and calculates the expectation value using the formula `(c * (f - 0.5) + 0.5)`, where `f` is the frequency and `c` is the confidence of the truth value. The function first unpacks the frequency and confidence from the input tuple `T`. It then applies the formula to calculate the expectation value. The calculated expectation value is returned as the output of the function.\n\nThis function is called by the `differenceEvaluate` and `inheritances` methods in the `Nalifier` class of the `Nalifier.py` file. In the `differenceEvaluate` method, the `Truth_Expectation` function is used to calculate the expectation value of the truth difference between two truth values. The calculated expectation value is compared with the current biggest difference truth value, and if it is greater, the biggest difference truth value is updated. In the `inheritances` method, the `Truth_Expectation` function is used to calculate the expectation value of the truth intermediate between two truth values. The calculated expectation value is used to determine the common properties between the two terms.\n\n**Note**: \n- The input truth value `T` should be a tuple with two elements representing the frequency and confidence.\n- The calculated expectation value is a float value between 0 and 1.\n- The `Truth_Expectation` function assumes that the input truth value is valid and follows the expected format.\n\n**Output Example**: \nIf the input truth value `T` is `(0.7, 0.9)`, the `Truth_Expectation` function will return `0.725`."
      ],
      "code_start_line": 75,
      "code_end_line": 77,
      "parent": null,
      "params": [
        "T"
      ],
      "have_return": true,
      "code_content": "def Truth_Expectation(T):\n    (f,c) = T\n    return (c * (f - 0.5) + 0.5)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Nalifier/differenceEvaluate",
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Nalifier/inheritances",
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Nalifier/AddInput"
      ],
      "reference_who": []
    },
    "Nalifier": {
      "type": "ClassDef",
      "name": "Nalifier",
      "md_content": [
        "**Nalifier**: The Nalifier class is responsible for creating and managing instances and concepts in the NARS (Non-Axiomatic Reasoning System) framework. It implements the NAL (Non-Axiomatic Logic) inference rules for matching and inheritance between instances and concepts.\n\n**Attributes**:\n- SUFFICIENT_MATCH_EXP: A threshold value that determines when an instance is considered a match to an existing instance. Default value is 0.8.\n- SUFFICIENT_DIFFERENCE_EXP: A threshold value that determines how much difference is required to consider an instance as different from the best matched one. Default value is 0.0.\n- COMMON_PROPERTY_EXP: A threshold value that determines how similar properties need to be in order to be used for building new concepts. Default value is 0.5.\n- InstanceCreation: A boolean flag that indicates whether new instances should be created. Default value is True.\n- ConceptCreation: A boolean flag that indicates whether new concepts should be created. Default value is False.\n- RelativeComparison: A boolean flag that indicates whether relative comparison should be used for property values. Default value is False.\n- ClosedWorldAssumption: A boolean flag that indicates whether the closed world assumption should be used. Default value is False.\n- UseIntensionalDifference: A boolean flag that indicates whether intensional difference should be used for non-continuous properties. Default value is True.\n- usecounts: A dictionary that keeps track of the usage count of each prototype.\n- prototypes: A dictionary that stores the prototypes (concepts) and their associated properties.\n- position0: A dictionary that stores the position0 property values for instances.\n- position1: A dictionary that stores the position1 property values for instances.\n- conceptnames: A set that stores the names of concepts.\n- current_prototypes: A dictionary that stores the current prototypes (instances) and their associated properties.\n- last_instance: A variable that stores the last instance processed.\n- last_winner: A dictionary that stores the best matching prototype and its associated properties.\n- last_winner_truth_exp: A variable that stores the truth expectation of the best matching prototype.\n- last_winner_reldata: A tuple that stores the information about the biggest difference between the last instance and the best matching prototype.\n- last_winner_common_properties: A set that stores the common properties between the last instance and the best matching prototype.\n- last_label: A variable that stores the last label property encountered.\n- last_label_frequency: A variable that stores the frequency of the last label property.\n- winner_match_asymmetric: A boolean flag that indicates whether the best match was based on asymmetric comparison.\n- binary_extreme_comparison_properties: A set that stores the binary extreme comparison properties.\n- continuous_comparison_properties: A set that stores the continuous comparison properties.\n- label_properties: A set that stores the label properties.\n- Events: A list that stores the generated events.\n- concept_id: A variable that stores the concept ID.\n- sensorValueReporters: A dictionary that stores the value reporters for sensor properties.\n- conceptValueReporters: A dictionary that stores the value reporters for concept properties.\n- BestMatch: A variable that stores the best match relationship.\n- BiggestDifference: A variable that stores the biggest difference relationship.\n- propertyOfInterest: A variable that stores the property of interest.\n\n**Code Description**: The Nalifier class is initialized with an AIKR_Limit parameter, which sets the limit for the number of prototypes (concepts) that can be stored. The class provides methods for adding input, removing instance properties, evaluating differences, handling inheritances, and processing shell input.\n\nThe `removeInstanceProperties` method removes the properties associated with the worst prototype from the conceptValueReporters dictionary.\n\nThe `differenceEvaluate` method evaluates the difference between two truth values and updates the biggest difference if necessary.\n\nThe `inheritances` method calculates the inheritances between two instances and returns the inheritances, biggest difference, and common properties.\n\nThe `AddInput` method processes the input string and performs matching and inheritance operations. It updates the prototypes, usecounts, and other variables accordingly. It also generates events based on the input.\n\nThe `AddInputVector` method processes input vectors and adds them to the prototypes.\n\nThe `ShellInput` method processes shell input commands and updates the class attributes accordingly.\n\nThe `process` function is not a part of the Nalifier class, but it uses the Nalifier class to process input and perform actions based on the input.\n\n**Note**: The Nalifier class is a key component in the NARS framework for managing instances and concepts. It provides functionality for matching, inheritance, and concept creation. The class attributes and methods should be used carefully and in accordance with the requirements of the application.\n\n**Output Example**: None"
      ],
      "code_start_line": 104,
      "code_end_line": 493,
      "parent": null,
      "params": [],
      "have_return": true,
      "code_content": "class Nalifier:\n    #identify instance as existing instance if matching better than this value, else create new one:\n    SUFFICIENT_MATCH_EXP = 0.8 # 0.5 #sys.argv[1] if len(sys.argv) > 1 else 0.5 #0.5 #0.5   #how good match to the best case in order to not use the new instance ID\n    SUFFICIENT_DIFFERENCE_EXP = 0.0 #how much difference there needs to be to describe the case as different than to the best matched one\n    COMMON_PROPERTY_EXP = 0.5 #how similar properties need to be in order for them to be used for building new concepts\n    InstanceCreation=True\n    ConceptCreation=False\n    RelativeComparison=False\n    ClosedWorldAssumption=False\n    UseIntensionalDifference=True\n    usecounts = {}\n    prototypes = {}\n    position0 = {}\n    position1 = {}\n    conceptnames = set([])\n    current_prototypes = {}\n    last_instance = None\n    last_winner = None\n    last_winner_truth_exp = 0.0\n    last_winner_reldata = None\n    last_winner_common_properties = set([])\n    last_label = None\n    last_label_frequency = 0.5\n    winner_match_asymmetric = False\n    binary_extreme_comparison_properties = set([])\n    continuous_comparison_properties = set([])\n    label_properties = set([])\n    Events = []\n    concept_id = 1\n    sensorValueReporters = dict([])\n    conceptValueReporters = dict([])\n    BestMatch = \"\"\n    BiggestDifference = \"\"\n    propertyOfInterest = None\n    \n    def __init__(self, AIKR_Limit = 10):\n      self.AIKR_Limit = AIKR_Limit\n\n    def removeInstanceProperties(self, worstproto):\n      removals = []\n      for key in self.conceptValueReporters.keys():\n          if key.startswith(worstproto + \"_\"):\n              removals.append(key)\n      for removal in removals:\n          del self.conceptValueReporters[removal]\n\n    def differenceEvaluate(self, T1, T2, property, biggestDifferenceProp, biggestDifferenceTruth, term1, term2, relation, biggestDifferenceArg1, biggestDifferenceArg2, relativeDifference = None):\n      continuous = property in self.continuous_comparison_properties\n      truthDifference = Truth_Negation(Truth_FrequencyComparison(T1, T2)) if continuous else Truth_Difference(T1, T2)\n      if relativeDifference is not None:\n          truthDifference = relativeDifference\n      #print(\"DIFFERENCE EVAL\", property, T1,T2,Truth_Expectation(truthDifference))\n      if (self.propertyOfInterest is None or property == self.propertyOfInterest) and Truth_Expectation(truthDifference) > Truth_Expectation(biggestDifferenceTruth):\n        if T1[0] < T2[0]:\n          relation = \"-\"\n        else:\n          relation = \"+\"\n        biggestDifferenceProp = property\n        biggestDifferenceTruth = truthDifference\n        biggestDifferenceArg1 = term1\n        biggestDifferenceArg2 = term2\n      return biggestDifferenceProp, biggestDifferenceTruth, relation, biggestDifferenceArg1, biggestDifferenceArg2\n\n    def inheritances(self, term1, terms_term1, term2, terms_term2, requireSameProperties=False, asymmetricComparison=True):\n        Inheritances = dict([])\n        biggestDifferenceProp = None\n        biggestDifferenceTruth = (0.0, 1.0)\n        biggestDifferenceArg1 = None\n        biggestDifferenceArg2 = None\n        rel = \"+\"\n        commonProperties = set([])\n        incomparable = []\n        ((extension1, intension1), (extension2, intension2)) = (terms_term1, terms_term2)\n        if term2 in self.conceptnames and not asymmetricComparison:\n          return None, None, None\n        if term2 not in self.conceptnames and asymmetricComparison:\n          return None, None, None\n        hadMissingProp = False\n        w_plus = 0\n        w_minus = 0\n        truth2 = (0.5, 0.0)\n        truth3 = (0.5, 0.0)\n        f_Induction = Truth_Induction if asymmetricComparison else Truth_Comparison\n        f_Abduction = Truth_Abduction if asymmetricComparison else Truth_Comparison\n        for prop1, T1 in intension1:\n            for prop2, T2 in intension2:\n                if prop1 == prop2:\n                    w_plus+=1\n                    truthPlus = (1.0, 0.5)\n                    truth2 = Truth_Revision(truth2, truthPlus)\n                    truthIntermediate = f_Induction(T1, T2) if prop1 not in self.continuous_comparison_properties else Truth_FrequencyComparison(T1, T2)\n                    if Truth_Expectation(truthIntermediate) > self.COMMON_PROPERTY_EXP:\n                        commonProperties.add((prop2, Truth_Revision(T1, T2)))\n                    truth3 = Truth_Revision(truth3, truthIntermediate)\n                    instance_property = term2 + \"_\" + prop1\n                    nodeRelativeDifference = None\n                    if prop1 in self.continuous_comparison_properties and self.RelativeComparison and instance_property in self.conceptValueReporters:\n                        #get the second truth value from the value reporter of term1_prop1\n                        nodeRelativeDifference = Truth_Negation(Truth_FrequencyComparison((0.5, 0.9), self.conceptValueReporters[instance_property].reportValue(T1[0], Sensation_Reliance=T1[1], RangeUpdate=False, Print=False)))\n                        #print(\"//RELATIVE VALUE GET\", instance_property, T1, nodeRelativeDifference, self.conceptValueReporters[instance_property].values)\n                    biggestDifferenceProp, biggestDifferenceTruth, rel, biggestDifferenceArg1, biggestDifferenceArg2 = self.differenceEvaluate(T1, T2, prop1, biggestDifferenceProp, biggestDifferenceTruth, term1, term2, rel, biggestDifferenceArg1, biggestDifferenceArg2, relativeDifference=nodeRelativeDifference)\n        for prop1, T1 in extension1:\n            for prop2, T2 in extension2:\n                if prop1 == prop2:\n                    w_plus+=1\n                    truthPlus = (1.0, 0.5)\n                    truth2 = Truth_Revision(truth2, truthPlus)\n                    truth3 = Truth_Revision(truth3, f_Abduction(T1, T2))\n        for prop2, T2 in intension2:\n            AHasProperty = False\n            for prop1, T1 in intension1:\n                if prop1 == prop2:\n                    AHasProperty = True\n            if not AHasProperty and requireSameProperties:\n                hadMissingProp = True\n            if not AHasProperty and self.ClosedWorldAssumption and prop2 not in self.continuous_comparison_properties:\n                w_minus+=1\n                truthMinus = (0.0, 0.5)\n                truth2 = Truth_Revision(truth2, truthMinus)\n                T1 = (0.0, 1.0) #fabricated truth since the property does not appear in T1\n                truth3 = Truth_Revision(truth3, f_Induction(T1, T2))\n                #biggestDifferenceProp, biggestDifferenceTruth, rel, biggestDifferenceArg1, biggestDifferenceArg2 = differenceEvaluate(T1, T2, prop2, biggestDifferenceProp, biggestDifferenceTruth, term1, term2, rel, biggestDifferenceArg1, biggestDifferenceArg2)\n                if prop2 in self.label_properties:\n                    incomparable.append(term2)\n        for inst1, T1 in extension1:\n            BHasInstance = False\n            for inst2, T2 in extension2:\n                if inst1 == inst2:\n                    BHasInstance = True\n            if not BHasInstance and applyCWA:\n                w_minus+=1\n                truthMinus = (0.0, 0.5)\n                truth2 = Truth_Revision(truth2, truthMinus)\n                T2 = (0.0, 1.0) #fabricated truth since the property does not appear in T1\n                truth3 = Truth_Revision(truth3, f_Abduction(T1, T2))\n        if not (hadMissingProp and requireSameProperties):\n            Inheritances[term2] = truth3\n        for bad_term in incomparable:\n            Inheritances.pop(bad_term, None)\n        return Inheritances, (biggestDifferenceProp, biggestDifferenceTruth, rel, biggestDifferenceArg1, biggestDifferenceArg2), commonProperties\n\n    def AddInput(self, inp, inverted=False, Print=False, Sensation_Reliance=0.9): #<{instance} --> [property]>. :|: %frequency%\n        if inp.startswith(\"//\"):\n            print(inp)\n            return\n        if inp != \"1\":\n            instance = inp.split(\"{\")[1].split(\"}\")[0]\n            property = inp.split(\"[\")[1].split(\"]\")[0]\n            if \"|->\" in inp:\n                if property not in self.sensorValueReporters:\n                  self.sensorValueReporters[property] = ValueReporter()\n                self.continuous_comparison_properties.add(property)\n            frequency = float(inp.split(\"%\")[1].split(\"%\")[0].split(\";\")[0]) if \"%\" in inp else 1.0\n            if property == \"position0\":\n              position0[instance] = frequency\n              return\n            if property == \"position1\":\n              position1[instance] = frequency\n              return\n            if property.startswith(\"label_\"):\n              self.last_label = property.split(\"label_\")[1]\n              self.last_label_frequency = frequency\n            if not inverted and property in self.binary_extreme_comparison_properties:\n                NAL_AddInput(\"<{\" + instance + \"}\" + \" --> [\" + \"anti_\" +  property + \"]>. :|: %\" + str(1-frequency) + \"%\", True, Print=Print)\n        if inp == \"1\": # or (instance != self.last_instance and self.last_instance is not None):\n            #DETERMINE BEST MATCH IN CURRENT PROTOTYPES:\n            if self.last_winner is not None and self.last_winner_truth_exp > self.SUFFICIENT_MATCH_EXP:\n                for k,v in self.last_winner.items(): #just 1\n                    if k not in self.usecounts:\n                      self.usecounts[k] = 1\n                    else:\n                      self.usecounts[k] = self.usecounts[k] + 1\n                    (biggestDifferenceProp, biggestDifferenceTruth, rel, biggestDifferenceArg1, biggestDifferenceArg2) = self.last_winner_reldata\n                    if Truth_Expectation(biggestDifferenceTruth) > self.SUFFICIENT_DIFFERENCE_EXP:\n                      reduced_instance_representation = self.last_instance\n                      #USE VARIABLE INSTEAD OF 2 STATEMENTS!!!!\n                      termname = lambda T: \"{\" + T + \"}\" if T not in self.conceptnames else T\n                      inst1 = termname(reduced_instance_representation) #\"#1\"\n                      inst2 = termname(k)\n                      inst1forRel = termname(biggestDifferenceArg1) if rel == \"+\" else termname(biggestDifferenceArg2)\n                      inst2forRel = termname(biggestDifferenceArg2) if rel == \"+\" else termname(biggestDifferenceArg1)\n                      evP = None\n                      self.BiggestDifference = (rel, biggestDifferenceProp)\n                      rel = \"--> \" if self.winner_match_asymmetric else \"<->\"\n                      self.BestMatch = (rel, k)\n                      #print(\"//BEST MATCH!!!\", self.BestMatch, self.BiggestDifference)\n                      if self.RelativeComparison:\n                          for props in self.current_prototypes[list(self.current_prototypes.keys())[0]]:\n                              for prop in props:\n                                instance_property = k + \"_\" + prop[0]\n                                frequency = prop[1][0]\n                                if instance_property not in self.conceptValueReporters:\n                                    self.conceptValueReporters[instance_property] = ValueReporter()\n                                self.conceptValueReporters[instance_property].reportValue(frequency, Print=False, Sensation_Reliance=prop[1][1])\n                                #print(\"//RELATIVE VALUE SET\", instance_property, self.conceptValueReporters[instance_property].reportValue(frequency, RangeUpdate=False, Print=False, Sensation_Reliance=prop[1][1]))\n                      relStatement = f\"<({inst1forRel} * {inst2forRel}) --> (+ {biggestDifferenceProp})>\"\n                      if self.UseIntensionalDifference and biggestDifferenceProp not in self.continuous_comparison_properties:\n                          relStatement = f\"<({inst1forRel} ~ {inst2forRel}) --> [{biggestDifferenceProp}]>\"\n                      if self.last_label is not None: \n                        #ev1 = f\"((<{{{inst2}}} <-> {inst1}> && {relStatement}) && <{{{inst2}}} --> {self.last_label}>). :|: %{self.last_label_frequency};{0.9}%\"\n                        ev1 = f\"(<{inst1forRel} {rel} {inst2forRel}> && {relStatement}). :|: %{self.last_label_frequency};{0.9}%\"\n                      else:\n                        ev1 = f\"(<{inst1forRel} {rel} {inst2forRel}> && {relStatement}). :|:\"\n                      inst1 = inst1.replace(\"{\",\"\").replace(\"}\",\"\") #not elegant\n                      inst2 = inst2.replace(\"{\",\"\").replace(\"}\",\"\") #todo improve\n                      if inst1 in self.position0 and inst2 in self.position0 and inst1 in self.position1 and inst2 in self.position1 and not self.winner_match_asymmetric:\n                          if self.position0[inst1] > self.position0[inst2]:\n                            if position1[inst1] > position1[inst2]:\n                              evP = f\"(<({{{inst1}}} * {{{inst2}}}) --> (+ position0)> && <({{{inst1}}} * {{{inst2}}}) --> (+ position1)>). :|: %1.0;0.6%\"\n                            else:\n                              evP = f\"(<({{{inst1}}} * {{{inst2}}}) --> (+ position0)> && <({{{inst2}}} * {{{inst1}}}) --> (+ position1)>). :|: %1.0;0.6%\"\n                          else:\n                            if self.position1[inst1] > self.position1[inst2]:\n                              evP = f\"(<({{{inst2}}} * {{{inst1}}}) --> (+ position0)> && <({{{inst1}}} * {{{inst2}}}) --> (+ position1)>). :|: %1.0;0.6%\"\n                            else:\n                              evP = f\"(<({{{inst2}}} * {{{inst1}}}) --> (+ position0)> && <({{{inst2}}} * {{{inst1}}}) --> (+ position1)>). :|: %1.0;0.6%\"\n                      self.Events.append(ev1)\n                      if evP is not None:\n                        if Print:\n                          print(evP)\n                        self.Events.append(evP)\n                      if Print:\n                        print(ev1)\n                    else:\n                      if self.last_label is not None:\n                        ev2 = f\"<{{{k}}} --> {self.last_label}>. :|: %{self.last_label_frequency};{0.9}%\"\n                      else:\n                        ev2 = f\"<{{{k}}} --> [see]>. :|:\"\n                      self.Events.append(ev2)\n                      if Print:\n                        print(ev2)\n                      break\n            if self.last_winner is not None:\n                #ADD NEW CONCEPT NODE IF THE MATCH WAS BASED ON INSTANCE (symmetric) COMPARISON\n                names = sorted([k for (k,v) in self.last_winner_common_properties])\n                conceptname = \"_\".join(names)\n                #print(conceptname); exit(0);\n                if self.ConceptCreation and conceptname != \"\" and not self.winner_match_asymmetric:\n                    conceptname += \"_\" + str(self.concept_id)\n                    self.concept_id += 1\n                    self.conceptnames.add(conceptname)\n                    print(\"//CONCEPT CREATION\", conceptname, self.last_winner_common_properties)\n                    self.prototypes[conceptname] = (set([]), self.last_winner_common_properties)\n            #else:\n            if self.winner_match_asymmetric or not (self.last_winner is not None and self.last_winner_truth_exp > self.SUFFICIENT_MATCH_EXP):\n              if self.last_winner is None:\n                if self.last_label is not None:\n                  ev3 = f\"<{{{self.last_instance}}} --> {self.last_label}>. :|: %{self.last_label_frequency};{0.9}%\"\n                else:\n                  ev3 = f\"<{{{self.last_instance}}} --> [see]>. :|:\"\n                self.Events.append(ev3)\n                if Print:\n                  print(ev3)\n              if self.InstanceCreation:\n                self.prototypes.update(self.current_prototypes)\n            self.current_prototypes = {}\n        if inp == \"1\":\n            self.propertyOfInterest = None\n            if self.last_instance not in self.prototypes:\n                self.removeInstanceProperties(self.last_instance)\n            return\n        self.last_instance = instance\n        if Print:\n          print(\"//\" + inp)\n        if instance not in self.current_prototypes:\n            self.current_prototypes[instance] = (set(),set())\n        #check if instance is in prototypes, in which case the truth value is the revised one:\n        RevisedInstanceProperty = False\n        if instance in self.prototypes:\n            for (prop, TV) in self.prototypes[instance][1]:\n                if prop == property:\n                    self.current_prototypes[instance][1].add((property, Truth_Revision((frequency, 0.9), TV)))\n                    RevisedInstanceProperty = True\n                    break\n        if not RevisedInstanceProperty:\n            self.current_prototypes[instance][1].add((property, (frequency, 0.9)))\n        if self.RelativeComparison:\n            instance_property = instance+\"_\"+property\n            if instance_property not in self.conceptValueReporters:\n                self.conceptValueReporters[instance_property] = ValueReporter()\n            self.conceptValueReporters[instance_property].reportValue(frequency, Print=False, Sensation_Reliance=Sensation_Reliance)\n            #print(\"//RELATIVE VALUE INIT\", instance_property, self.conceptValueReporters[instance_property].reportValue(frequency, RangeUpdate=False, Print=False, Sensation_Reliance=Sensation_Reliance))\n        winner = None\n        winner_truth_exp = 0.0\n        for (key, value) in self.prototypes.items():\n            candidate, reldata, commonProperties = self.inheritances(instance, self.current_prototypes[instance], key, value, asymmetricComparison=False)\n            if candidate is not None and list(candidate.values()):\n              candidate_truth_exp = Truth_Expectation(list(candidate.values())[0])\n              if candidate_truth_exp > winner_truth_exp:\n                  winner = candidate\n                  winner_truth_exp = candidate_truth_exp\n                  self.last_winner_reldata = reldata\n                  self.last_winner_common_properties = commonProperties\n                  self.winner_match_asymmetric = False\n        if winner_truth_exp <= self.SUFFICIENT_MATCH_EXP:\n          for (key, value) in self.prototypes.items():\n            candidate, reldata, commonProperties = self.inheritances(instance, self.current_prototypes[instance], key, value, asymmetricComparison=True)\n            if candidate is not None and list(candidate.values()):\n              candidate_truth_exp = Truth_Expectation(list(candidate.values())[0])\n              if candidate_truth_exp > winner_truth_exp:\n                  winner = candidate\n                  winner_truth_exp = candidate_truth_exp\n                  self.last_winner_reldata = reldata\n                  self.last_winner_common_properties = commonProperties\n                  self.winner_match_asymmetric = True\n        self.last_winner_truth_exp = winner_truth_exp\n        self.last_winner = winner\n        #capacity limit exceeded\n        if len(self.prototypes) > self.AIKR_Limit:\n          minuse = 99999999\n          worstproto = None\n          for proto in self.prototypes:\n            usecount = self.usecounts[proto] if proto in self.usecounts else 0\n            if usecount < minuse:\n              minuse = usecount\n              worstproto = proto\n          self.usecounts.pop(worstproto, None)\n          self.prototypes.pop(worstproto, None)\n          self.position0.pop(worstproto, None)\n          self.position1.pop(worstproto, None)\n          self.conceptnames.discard(worstproto)\n          self.removeInstanceProperties(worstproto)\n\n    def AddInputVector(self, name, values, dimname=None, Print=False, UseHistogram=True, Sensation_Reliance = 0.9):\n        global sensorValueReporters\n        if dimname is None:\n          dimname = name\n        for i, value in enumerate(values):\n            propertyName = dimname + str(i)\n            if UseHistogram:\n                if propertyName not in self.sensorValueReporters:\n                  self.sensorValueReporters[propertyName] = ValueReporter()\n                #binary_extreme_comparison_properties.add(propertyName)\n                self.continuous_comparison_properties.add(propertyName)\n                (f,c) = self.sensorValueReporters[propertyName].reportValue(value, Print=False, RangeUpdate=self.InstanceCreation, Sensation_Reliance = Sensation_Reliance)\n            else:\n                (f,c) = (value, Sensation_Reliance)\n            self.AddInput(\"<{\" + name + \"} |-> [\" + propertyName + \"]>. :|: %\" + str(f) + \"%\", Print=Print, Sensation_Reliance=Sensation_Reliance) # + str(c) + \"%\")\n\n    def ShellInput(self, inp):\n        if inp.startswith(\"*SET_CONTINUOUS=\"):\n            propertyName = inp.split(\"*SET_CONTINUOUS=\")[1]\n            if propertyName not in self.sensorValueReporters:\n              self.sensorValueReporters[propertyName] = ValueReporter()\n            self.continuous_comparison_properties.add(propertyName)\n            return None\n        if inp.startswith(\"*PROTOTYPES\"):\n            print(\"//\"+str(self.prototypes))\n            return None\n        if inp.startswith(\"*PROPERTY_OF_INTEREST=\"):\n            self.propertyOfInterest = inp.split(\"*PROPERTY_OF_INTEREST=\")[1]\n            if self.propertyOfInterest == \"\":\n                self.propertyOfInterest = None\n            return None\n        if inp.startswith(\"*RESET_PROTOTYPES=\"):\n            self = Nalifier(int(inp.split(\"*RESET_PROTOTYPES=\")[1]))\n            return None\n        if inp.startswith(\"*SUFFICIENT_MATCH_EXP=\"):\n            self.SUFFICIENT_MATCH_EXP = float(inp.split(\"*SUFFICIENT_MATCH_EXP=\")[1])\n            return None\n        if inp.startswith(\"*SUFFICIENT_DIFFERENCE_EXP=\"):\n            self.SUFFICIENT_DIFFERENCE_EXP = float(inp.split(\"*SUFFICIENT_DIFFERENCE_EXP=\")[1])\n            return None\n        if inp.startswith(\"*COMMON_PROPERTY_EXP=\"):\n            self.COMMON_PROPERTY_EXP = float(inp.split(\"*COMMON_PROPERTY_EXP=\")[1])\n            return None\n        if inp.startswith(\"*CONCEPT_CREATION=\"):\n            self.ConceptCreation = True if inp.split(\"*CONCEPT_CREATION=\")[1].lower() == \"true\" else False\n            return None\n        if inp.startswith(\"*INSTANCE_CREATION=\"):\n            self.InstanceCreation = True if inp.split(\"*INSTANCE_CREATION=\")[1].lower() == \"true\" else False\n            return None\n        if inp.startswith(\"*RELATIVE_COMPARISON=\"):\n            self.RelativeComparison = True if inp.split(\"*RELATIVE_COMPARISON=\")[1].lower() == \"true\" else False\n            return None\n        if inp.startswith(\"*CLOSED_WORLD_ASSUMPTION=\"):\n            self.ClosedWorldAssumption = True if inp.split(\"*CLOSED_WORLD_ASSUMPTION=\")[1].lower() == \"true\" else False\n            return None\n        if inp.startswith(\"*USE_INTENSIONAL_DIFFERENCE=\"): #will be used for non-continuous properties only even when true\n            self.UseIntensionalDifference = True if inp.split(\"*USE_INTENSIONAL_DIFFERENCE=\")[1].lower() == \"true\" else False\n            return None\n        lhs = inp.split(\". :|:\")[0]\n        if inp == \"1\":\n            self.AddInput(inp, Print=True)\n            return None\n        elif \". :|:\" in inp and \"{\" in inp and \"}\" in inp and \"[\" in inp and \"]\" in inp and \" * \" not in inp:\n            self.AddInput(inp, Print=True)\n            return None\n        else:\n            return inp\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR_Nalifier.py",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/process"
      ],
      "reference_who": []
    },
    "__init__": {
      "type": "FunctionDef",
      "name": "__init__",
      "md_content": [
        "**__init__**: The function of __init__ is to initialize the object of the Nalifier class.\n\n**parameters**:\n- AIKR_Limit: An optional parameter that specifies the limit for the AIKR (Artificial Intelligence Knowledge Representation) system. The default value is 10.\n\n**Code Description**:\nThe __init__ function is a special method in Python classes that is automatically called when a new object of the class is created. It is used to initialize the attributes of the object.\n\nIn this specific code, the __init__ function takes one parameter, AIKR_Limit, which represents the limit for the AIKR system. The AIKR system is responsible for representing and processing knowledge in the artificial intelligence system.\n\nInside the __init__ function, the AIKR_Limit parameter is assigned to the self.AIKR_Limit attribute of the object. The self keyword refers to the current instance of the class, and by assigning the AIKR_Limit parameter to self.AIKR_Limit, we are initializing the attribute with the provided value.\n\n**Note**:\n- The __init__ function is called automatically when creating a new object of the Nalifier class.\n- The AIKR_Limit parameter is optional and has a default value of 10. If no value is provided, the AIKR_Limit attribute will be initialized with the default value."
      ],
      "code_start_line": 139,
      "code_end_line": 140,
      "parent": "Nalifier",
      "params": [
        "self",
        "AIKR_Limit"
      ],
      "have_return": false,
      "code_content": "    def __init__(self, AIKR_Limit = 10):\n      self.AIKR_Limit = AIKR_Limit\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "removeInstanceProperties": {
      "type": "FunctionDef",
      "name": "removeInstanceProperties",
      "md_content": [
        "**removeInstanceProperties**: The function of removeInstanceProperties is to remove instance properties from the conceptValueReporters dictionary.\n\n**parameters**:\n- self: The current object.\n- worstproto: The worst prototype to remove instance properties for.\n\n**Code Description**:\nThe removeInstanceProperties function takes in the worstproto parameter and removes all instance properties that start with the worstproto value followed by an underscore from the conceptValueReporters dictionary. It does this by iterating over the keys of the conceptValueReporters dictionary and checking if each key starts with the worstproto value followed by an underscore. If a key matches this condition, it is added to the removals list. Finally, the function iterates over the removals list and deletes each key from the conceptValueReporters dictionary.\n\nThis function is called within the AddInput function of the Nalifier class in the Nalifier.py file. In the AddInput function, if the inp parameter is equal to \"1\", the removeInstanceProperties function is called with the last_instance as the worstproto value. This ensures that instance properties are removed for the last_instance when a new input is received.\n\n**Note**:\n- It is important to note that this function only removes instance properties from the conceptValueReporters dictionary and does not remove the entire concept node or prototype associated with the instance."
      ],
      "code_start_line": 142,
      "code_end_line": 148,
      "parent": "Nalifier",
      "params": [
        "self",
        "worstproto"
      ],
      "have_return": false,
      "code_content": "    def removeInstanceProperties(self, worstproto):\n      removals = []\n      for key in self.conceptValueReporters.keys():\n          if key.startswith(worstproto + \"_\"):\n              removals.append(key)\n      for removal in removals:\n          del self.conceptValueReporters[removal]\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Nalifier/AddInput"
      ],
      "reference_who": []
    },
    "differenceEvaluate": {
      "type": "FunctionDef",
      "name": "differenceEvaluate",
      "md_content": [
        "**differenceEvaluate**: The function of differenceEvaluate is to calculate the difference between two truth values and update the biggest difference property, truth, relation, and arguments based on certain conditions.\n\n**parameters**:\n- T1: The first truth value, represented as a tuple (f1, c1), where f1 is the frequency and c1 is the confidence.\n- T2: The second truth value, represented as a tuple (f2, c2), where f2 is the frequency and c2 is the confidence.\n- property: The property associated with the truth values.\n- biggestDifferenceProp: The current biggest difference property.\n- biggestDifferenceTruth: The current biggest difference truth value.\n- term1: The first term associated with the truth values.\n- term2: The second term associated with the truth values.\n- relation: The relation between the terms.\n- biggestDifferenceArg1: The current biggest difference argument 1.\n- biggestDifferenceArg2: The current biggest difference argument 2.\n- relativeDifference (optional): The relative difference between the truth values.\n\n**Code Description**:\nThe differenceEvaluate function takes two truth values, T1 and T2, along with other parameters, and calculates the difference between them. It first checks if the property is in the list of continuous comparison properties. If it is, the function uses the Truth_FrequencyComparison function from the Truth_FrequencyComparison object to calculate the truth difference. Otherwise, it uses the Truth_Difference function from the Truth_Difference object.\n\nIf the relativeDifference parameter is provided, the function updates the truth difference to the relative difference. Then, it checks if the property of interest is None or if the current property is equal to the property of interest. If either condition is true and the expectation value of the truth difference is greater than the expectation value of the current biggest difference truth value, the function updates the biggest difference property, truth value, relation, and arguments.\n\nFinally, the function returns the updated biggest difference property, truth value, relation, and arguments.\n\n**Note**:\n- The function assumes that the input truth values have the correct format and structure.\n- The function relies on the Truth_FrequencyComparison and Truth_Difference functions to calculate the truth difference.\n- The function updates the biggest difference property, truth value, relation, and arguments based on certain conditions.\n- The relativeDifference parameter is optional and can be used to override the calculated truth difference.\n\n**Output Example**:\nIf T1 = (0.8, 0.9), T2 = (0.6, 0.7), property = \"example\", biggestDifferenceProp = None, biggestDifferenceTruth = (0.0, 1.0), term1 = \"term1\", term2 = \"term2\", relation = \"+\", biggestDifferenceArg1 = None, biggestDifferenceArg2 = None, and relativeDifference = None, the function will return (\"example\", (0.16, 0.63), \"-\", \"term1\", \"term2\")."
      ],
      "code_start_line": 150,
      "code_end_line": 165,
      "parent": "Nalifier",
      "params": [
        "self",
        "T1",
        "T2",
        "property",
        "biggestDifferenceProp",
        "biggestDifferenceTruth",
        "term1",
        "term2",
        "relation",
        "biggestDifferenceArg1",
        "biggestDifferenceArg2",
        "relativeDifference"
      ],
      "have_return": true,
      "code_content": "    def differenceEvaluate(self, T1, T2, property, biggestDifferenceProp, biggestDifferenceTruth, term1, term2, relation, biggestDifferenceArg1, biggestDifferenceArg2, relativeDifference = None):\n      continuous = property in self.continuous_comparison_properties\n      truthDifference = Truth_Negation(Truth_FrequencyComparison(T1, T2)) if continuous else Truth_Difference(T1, T2)\n      if relativeDifference is not None:\n          truthDifference = relativeDifference\n      #print(\"DIFFERENCE EVAL\", property, T1,T2,Truth_Expectation(truthDifference))\n      if (self.propertyOfInterest is None or property == self.propertyOfInterest) and Truth_Expectation(truthDifference) > Truth_Expectation(biggestDifferenceTruth):\n        if T1[0] < T2[0]:\n          relation = \"-\"\n        else:\n          relation = \"+\"\n        biggestDifferenceProp = property\n        biggestDifferenceTruth = truthDifference\n        biggestDifferenceArg1 = term1\n        biggestDifferenceArg2 = term2\n      return biggestDifferenceProp, biggestDifferenceTruth, relation, biggestDifferenceArg1, biggestDifferenceArg2\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Nalifier/inheritances"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Truth_FrequencyComparison",
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Truth_Negation",
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Truth_Difference",
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Truth_Expectation"
      ]
    },
    "inheritances": {
      "type": "FunctionDef",
      "name": "inheritances",
      "md_content": [
        "**inheritances**: The function of inheritances is to calculate the inheritance relationships between two terms based on their associated truth values and properties. It determines the common properties between the terms, calculates the truth values for inheritance relationships, and updates the biggest difference property, truth value, relation, and arguments based on certain conditions.\n\n**parameters**:\n- term1: The first term for which the inheritance relationships are calculated.\n- terms_term1: The associated truth values and properties of term1, represented as a tuple of two sets: (extension1, intension1). extension1 contains the extensional properties of term1, while intension1 contains the intensional properties of term1.\n- term2: The second term for which the inheritance relationships are calculated.\n- terms_term2: The associated truth values and properties of term2, represented as a tuple of two sets: (extension2, intension2). extension2 contains the extensional properties of term2, while intension2 contains the intensional properties of term2.\n- requireSameProperties (optional): A boolean value indicating whether the terms must have the same properties for inheritance. Default is False.\n- asymmetricComparison (optional): A boolean value indicating whether the comparison between terms is asymmetric. Default is True.\n\n**Code Description**:\nThe inheritances function takes two terms, term1 and term2, along with their associated truth values and properties, and calculates the inheritance relationships between them. It first initializes variables to store the biggest difference property, truth value, relation, and arguments. It also initializes other variables for further calculations.\n\nThe function then proceeds to iterate over the intensional properties of term1 and term2. For each matching property, it updates the truth values based on the type of comparison (induction or frequency comparison) and checks if the property meets the common property expectation. If it does, the property is added to the set of common properties.\n\nNext, the function iterates over the extensional properties of term1 and term2. For each matching property, it updates the truth values based on the type of comparison (abduction or frequency comparison).\n\nAfter that, the function checks for missing properties in term2 when requireSameProperties is True. If a missing property is found, the hadMissingProp variable is set to True.\n\nThe function then iterates over the intensional properties of term2. For each property, it checks if term1 has the same property. If not, it sets AHasProperty to False. If requireSameProperties is True and AHasProperty is False, hadMissingProp is set to True.\n\nNext, the function iterates over the extensional properties of term1. For each property, it checks if term2 has the same instance. If not, it sets BHasInstance to False. If BHasInstance is False and applyCWA is True, hadMissingProp is set to True.\n\nIf hadMissingProp is False or requireSameProperties is False, the function adds the inheritance relationships to the Inheritances dictionary.\n\nFinally, the function removes any incomparable terms from the Inheritances dictionary and returns the Inheritances dictionary, the biggest difference property, truth value, relation, and arguments, and the set of common properties.\n\n**Note**:\n- The function assumes that the input terms and their associated truth values and properties are in the correct format.\n- The function uses other helper functions, such as differenceEvaluate and Truth_Expectation, to calculate the truth differences and expectations.\n- The function handles different types of comparisons based on the properties and settings.\n- The function updates the biggest difference property, truth value, relation, and arguments based on certain conditions.\n- The relativeDifference parameter is used to override the calculated truth difference, if provided.\n- The function returns the Inheritances dictionary, the biggest difference property, truth value, relation, and arguments, and the set of common properties.\n\n**Output Example**:\nIf term1 is \"term1\", terms_term1 is (({(\"prop1\", (0.8, 0.9))}, {(\"prop2\", (0.6, 0.7))}), ({}, {})), term2 is \"term2\", terms_term2 is (({(\"prop1\", (0.7, 0.9))}, {(\"prop2\", (0.5, 0.7))}), ({}, {})), requireSameProperties is False, and asymmetricComparison is True, the function will return ({'term2': (0.4, 0.63)}, ('prop1', (0.16, 0.63), '-', 'term1', 'term2'), {('prop2', (0.5, 0.7))})."
      ],
      "code_start_line": 167,
      "code_end_line": 243,
      "parent": "Nalifier",
      "params": [
        "self",
        "term1",
        "terms_term1",
        "term2",
        "terms_term2",
        "requireSameProperties",
        "asymmetricComparison"
      ],
      "have_return": true,
      "code_content": "    def inheritances(self, term1, terms_term1, term2, terms_term2, requireSameProperties=False, asymmetricComparison=True):\n        Inheritances = dict([])\n        biggestDifferenceProp = None\n        biggestDifferenceTruth = (0.0, 1.0)\n        biggestDifferenceArg1 = None\n        biggestDifferenceArg2 = None\n        rel = \"+\"\n        commonProperties = set([])\n        incomparable = []\n        ((extension1, intension1), (extension2, intension2)) = (terms_term1, terms_term2)\n        if term2 in self.conceptnames and not asymmetricComparison:\n          return None, None, None\n        if term2 not in self.conceptnames and asymmetricComparison:\n          return None, None, None\n        hadMissingProp = False\n        w_plus = 0\n        w_minus = 0\n        truth2 = (0.5, 0.0)\n        truth3 = (0.5, 0.0)\n        f_Induction = Truth_Induction if asymmetricComparison else Truth_Comparison\n        f_Abduction = Truth_Abduction if asymmetricComparison else Truth_Comparison\n        for prop1, T1 in intension1:\n            for prop2, T2 in intension2:\n                if prop1 == prop2:\n                    w_plus+=1\n                    truthPlus = (1.0, 0.5)\n                    truth2 = Truth_Revision(truth2, truthPlus)\n                    truthIntermediate = f_Induction(T1, T2) if prop1 not in self.continuous_comparison_properties else Truth_FrequencyComparison(T1, T2)\n                    if Truth_Expectation(truthIntermediate) > self.COMMON_PROPERTY_EXP:\n                        commonProperties.add((prop2, Truth_Revision(T1, T2)))\n                    truth3 = Truth_Revision(truth3, truthIntermediate)\n                    instance_property = term2 + \"_\" + prop1\n                    nodeRelativeDifference = None\n                    if prop1 in self.continuous_comparison_properties and self.RelativeComparison and instance_property in self.conceptValueReporters:\n                        #get the second truth value from the value reporter of term1_prop1\n                        nodeRelativeDifference = Truth_Negation(Truth_FrequencyComparison((0.5, 0.9), self.conceptValueReporters[instance_property].reportValue(T1[0], Sensation_Reliance=T1[1], RangeUpdate=False, Print=False)))\n                        #print(\"//RELATIVE VALUE GET\", instance_property, T1, nodeRelativeDifference, self.conceptValueReporters[instance_property].values)\n                    biggestDifferenceProp, biggestDifferenceTruth, rel, biggestDifferenceArg1, biggestDifferenceArg2 = self.differenceEvaluate(T1, T2, prop1, biggestDifferenceProp, biggestDifferenceTruth, term1, term2, rel, biggestDifferenceArg1, biggestDifferenceArg2, relativeDifference=nodeRelativeDifference)\n        for prop1, T1 in extension1:\n            for prop2, T2 in extension2:\n                if prop1 == prop2:\n                    w_plus+=1\n                    truthPlus = (1.0, 0.5)\n                    truth2 = Truth_Revision(truth2, truthPlus)\n                    truth3 = Truth_Revision(truth3, f_Abduction(T1, T2))\n        for prop2, T2 in intension2:\n            AHasProperty = False\n            for prop1, T1 in intension1:\n                if prop1 == prop2:\n                    AHasProperty = True\n            if not AHasProperty and requireSameProperties:\n                hadMissingProp = True\n            if not AHasProperty and self.ClosedWorldAssumption and prop2 not in self.continuous_comparison_properties:\n                w_minus+=1\n                truthMinus = (0.0, 0.5)\n                truth2 = Truth_Revision(truth2, truthMinus)\n                T1 = (0.0, 1.0) #fabricated truth since the property does not appear in T1\n                truth3 = Truth_Revision(truth3, f_Induction(T1, T2))\n                #biggestDifferenceProp, biggestDifferenceTruth, rel, biggestDifferenceArg1, biggestDifferenceArg2 = differenceEvaluate(T1, T2, prop2, biggestDifferenceProp, biggestDifferenceTruth, term1, term2, rel, biggestDifferenceArg1, biggestDifferenceArg2)\n                if prop2 in self.label_properties:\n                    incomparable.append(term2)\n        for inst1, T1 in extension1:\n            BHasInstance = False\n            for inst2, T2 in extension2:\n                if inst1 == inst2:\n                    BHasInstance = True\n            if not BHasInstance and applyCWA:\n                w_minus+=1\n                truthMinus = (0.0, 0.5)\n                truth2 = Truth_Revision(truth2, truthMinus)\n                T2 = (0.0, 1.0) #fabricated truth since the property does not appear in T1\n                truth3 = Truth_Revision(truth3, f_Abduction(T1, T2))\n        if not (hadMissingProp and requireSameProperties):\n            Inheritances[term2] = truth3\n        for bad_term in incomparable:\n            Inheritances.pop(bad_term, None)\n        return Inheritances, (biggestDifferenceProp, biggestDifferenceTruth, rel, biggestDifferenceArg1, biggestDifferenceArg2), commonProperties\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Nalifier/AddInput"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Truth_Abduction",
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Truth_Induction",
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Truth_Comparison",
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Truth_FrequencyComparison",
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Truth_Negation",
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Truth_Revision",
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Truth_Expectation",
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Nalifier/differenceEvaluate"
      ]
    },
    "AddInput": {
      "type": "FunctionDef",
      "name": "AddInput",
      "md_content": [
        "**AddInput**: The AddInput function is responsible for processing input and performing various operations based on the input received.\n\n**parameters**:\n- `self`: The current object.\n- `inp`: The input string to be processed.\n- `inverted` (optional): A boolean value indicating whether the input should be inverted. Default is False.\n- `Print` (optional): A boolean value indicating whether the processed input should be printed. Default is False.\n- `Sensation_Reliance` (optional): A float value indicating the reliance on sensation. Default is 0.9.\n\n**Code Description**:\nThe AddInput function takes an input string `inp` and performs operations based on the input. It first checks if the input starts with \"//\". If it does, the input is printed and the function returns.\n\nNext, the function checks if the input is equal to \"1\". If it is, the function performs several operations. It determines the best match in the current prototypes based on the last winner and its truth expectation. If a best match is found and its truth expectation is greater than the sufficient match expectation, the function updates the use count for the best match and determines the biggest difference property, truth, relation, and arguments based on the last winner's relation data. It also updates the last label and last label frequency if the property starts with \"label_\". If the input is not inverted and the property is in the binary extreme comparison properties, the function adds a new input with an anti-property to the NAL_AddInput function.\n\nIf the input is equal to \"1\" or the instance is different from the last instance and the last instance is not None, the function performs additional operations. It checks if the last winner is not None and its truth expectation is greater than the sufficient match expectation. If it is, the function updates the use count for the last winner and determines the biggest difference property, truth, relation, and arguments based on the last winner's relation data. It also updates the best match and biggest difference based on the relation and arguments. If the relative comparison is enabled, the function updates the concept value reporters with the frequency and sensation reliance of the instance property. It then creates an evidence statement based on the last label and last label frequency. If the position properties are present, the function creates additional evidence statements based on the position values. The evidence statements are added to the events list.\n\nIf the input is equal to \"1\", the function updates the property of interest and removes instance properties for the last instance if it is not present in the prototypes.\n\nThe function then updates the last instance with the current instance and prints the input if the Print parameter is True.\n\nFinally, the function performs additional operations based on the instance and property values. It checks if the instance is not in the current prototypes and adds the instance properties to the current prototypes. It also updates the concept value reporters with the frequency and sensation reliance of the instance property. The function then calculates the truth expectation for the last winner and performs inheritance calculations between the current instance and the prototypes. The function updates the biggest difference property, truth, relation, and arguments based on the inheritance calculations. It also updates the last winner and last winner truth expectation. If the capacity limit is exceeded, the function removes the prototype with the lowest use count.\n\n**Note**:\n- The AddInput function is a key function in the Nalifier class that processes input and performs various operations based on the input received.\n- The function handles different types of input, including \"//\" comments, \"1\" input, and other input strings.\n- The function updates the prototypes, current prototypes, concept value reporters, position properties, and other attributes based on the input and current state.\n- The function calculates truth expectations, performs inheritance calculations, and updates the biggest difference property, truth, relation, and arguments based on certain conditions.\n- The function handles capacity limits and removes prototypes with the lowest use count when necessary.\n- The function uses other helper functions, such as NAL_AddInput, Truth_Revision, Truth_Expectation, and removeInstanceProperties, to perform specific operations.\n- The function updates the last instance, last label, last label frequency, last winner, and other attributes based on the input and current state.\n\n**Output Example**:\nIf the input is \"1\" and the best match is found, the function may add evidence statements to the events list and print the evidence statements to the console:\n```\n(<{inst1} * {inst2}> --> (+ {property})). :|: %{frequency};{0.9}%\n```\nThe evidence statements represent the best match between two instances and the associated property with the given frequency and confidence values."
      ],
      "code_start_line": 245,
      "code_end_line": 425,
      "parent": "Nalifier",
      "params": [
        "self",
        "inp",
        "inverted",
        "Print",
        "Sensation_Reliance"
      ],
      "have_return": true,
      "code_content": "    def AddInput(self, inp, inverted=False, Print=False, Sensation_Reliance=0.9): #<{instance} --> [property]>. :|: %frequency%\n        if inp.startswith(\"//\"):\n            print(inp)\n            return\n        if inp != \"1\":\n            instance = inp.split(\"{\")[1].split(\"}\")[0]\n            property = inp.split(\"[\")[1].split(\"]\")[0]\n            if \"|->\" in inp:\n                if property not in self.sensorValueReporters:\n                  self.sensorValueReporters[property] = ValueReporter()\n                self.continuous_comparison_properties.add(property)\n            frequency = float(inp.split(\"%\")[1].split(\"%\")[0].split(\";\")[0]) if \"%\" in inp else 1.0\n            if property == \"position0\":\n              position0[instance] = frequency\n              return\n            if property == \"position1\":\n              position1[instance] = frequency\n              return\n            if property.startswith(\"label_\"):\n              self.last_label = property.split(\"label_\")[1]\n              self.last_label_frequency = frequency\n            if not inverted and property in self.binary_extreme_comparison_properties:\n                NAL_AddInput(\"<{\" + instance + \"}\" + \" --> [\" + \"anti_\" +  property + \"]>. :|: %\" + str(1-frequency) + \"%\", True, Print=Print)\n        if inp == \"1\": # or (instance != self.last_instance and self.last_instance is not None):\n            #DETERMINE BEST MATCH IN CURRENT PROTOTYPES:\n            if self.last_winner is not None and self.last_winner_truth_exp > self.SUFFICIENT_MATCH_EXP:\n                for k,v in self.last_winner.items(): #just 1\n                    if k not in self.usecounts:\n                      self.usecounts[k] = 1\n                    else:\n                      self.usecounts[k] = self.usecounts[k] + 1\n                    (biggestDifferenceProp, biggestDifferenceTruth, rel, biggestDifferenceArg1, biggestDifferenceArg2) = self.last_winner_reldata\n                    if Truth_Expectation(biggestDifferenceTruth) > self.SUFFICIENT_DIFFERENCE_EXP:\n                      reduced_instance_representation = self.last_instance\n                      #USE VARIABLE INSTEAD OF 2 STATEMENTS!!!!\n                      termname = lambda T: \"{\" + T + \"}\" if T not in self.conceptnames else T\n                      inst1 = termname(reduced_instance_representation) #\"#1\"\n                      inst2 = termname(k)\n                      inst1forRel = termname(biggestDifferenceArg1) if rel == \"+\" else termname(biggestDifferenceArg2)\n                      inst2forRel = termname(biggestDifferenceArg2) if rel == \"+\" else termname(biggestDifferenceArg1)\n                      evP = None\n                      self.BiggestDifference = (rel, biggestDifferenceProp)\n                      rel = \"--> \" if self.winner_match_asymmetric else \"<->\"\n                      self.BestMatch = (rel, k)\n                      #print(\"//BEST MATCH!!!\", self.BestMatch, self.BiggestDifference)\n                      if self.RelativeComparison:\n                          for props in self.current_prototypes[list(self.current_prototypes.keys())[0]]:\n                              for prop in props:\n                                instance_property = k + \"_\" + prop[0]\n                                frequency = prop[1][0]\n                                if instance_property not in self.conceptValueReporters:\n                                    self.conceptValueReporters[instance_property] = ValueReporter()\n                                self.conceptValueReporters[instance_property].reportValue(frequency, Print=False, Sensation_Reliance=prop[1][1])\n                                #print(\"//RELATIVE VALUE SET\", instance_property, self.conceptValueReporters[instance_property].reportValue(frequency, RangeUpdate=False, Print=False, Sensation_Reliance=prop[1][1]))\n                      relStatement = f\"<({inst1forRel} * {inst2forRel}) --> (+ {biggestDifferenceProp})>\"\n                      if self.UseIntensionalDifference and biggestDifferenceProp not in self.continuous_comparison_properties:\n                          relStatement = f\"<({inst1forRel} ~ {inst2forRel}) --> [{biggestDifferenceProp}]>\"\n                      if self.last_label is not None: \n                        #ev1 = f\"((<{{{inst2}}} <-> {inst1}> && {relStatement}) && <{{{inst2}}} --> {self.last_label}>). :|: %{self.last_label_frequency};{0.9}%\"\n                        ev1 = f\"(<{inst1forRel} {rel} {inst2forRel}> && {relStatement}). :|: %{self.last_label_frequency};{0.9}%\"\n                      else:\n                        ev1 = f\"(<{inst1forRel} {rel} {inst2forRel}> && {relStatement}). :|:\"\n                      inst1 = inst1.replace(\"{\",\"\").replace(\"}\",\"\") #not elegant\n                      inst2 = inst2.replace(\"{\",\"\").replace(\"}\",\"\") #todo improve\n                      if inst1 in self.position0 and inst2 in self.position0 and inst1 in self.position1 and inst2 in self.position1 and not self.winner_match_asymmetric:\n                          if self.position0[inst1] > self.position0[inst2]:\n                            if position1[inst1] > position1[inst2]:\n                              evP = f\"(<({{{inst1}}} * {{{inst2}}}) --> (+ position0)> && <({{{inst1}}} * {{{inst2}}}) --> (+ position1)>). :|: %1.0;0.6%\"\n                            else:\n                              evP = f\"(<({{{inst1}}} * {{{inst2}}}) --> (+ position0)> && <({{{inst2}}} * {{{inst1}}}) --> (+ position1)>). :|: %1.0;0.6%\"\n                          else:\n                            if self.position1[inst1] > self.position1[inst2]:\n                              evP = f\"(<({{{inst2}}} * {{{inst1}}}) --> (+ position0)> && <({{{inst1}}} * {{{inst2}}}) --> (+ position1)>). :|: %1.0;0.6%\"\n                            else:\n                              evP = f\"(<({{{inst2}}} * {{{inst1}}}) --> (+ position0)> && <({{{inst2}}} * {{{inst1}}}) --> (+ position1)>). :|: %1.0;0.6%\"\n                      self.Events.append(ev1)\n                      if evP is not None:\n                        if Print:\n                          print(evP)\n                        self.Events.append(evP)\n                      if Print:\n                        print(ev1)\n                    else:\n                      if self.last_label is not None:\n                        ev2 = f\"<{{{k}}} --> {self.last_label}>. :|: %{self.last_label_frequency};{0.9}%\"\n                      else:\n                        ev2 = f\"<{{{k}}} --> [see]>. :|:\"\n                      self.Events.append(ev2)\n                      if Print:\n                        print(ev2)\n                      break\n            if self.last_winner is not None:\n                #ADD NEW CONCEPT NODE IF THE MATCH WAS BASED ON INSTANCE (symmetric) COMPARISON\n                names = sorted([k for (k,v) in self.last_winner_common_properties])\n                conceptname = \"_\".join(names)\n                #print(conceptname); exit(0);\n                if self.ConceptCreation and conceptname != \"\" and not self.winner_match_asymmetric:\n                    conceptname += \"_\" + str(self.concept_id)\n                    self.concept_id += 1\n                    self.conceptnames.add(conceptname)\n                    print(\"//CONCEPT CREATION\", conceptname, self.last_winner_common_properties)\n                    self.prototypes[conceptname] = (set([]), self.last_winner_common_properties)\n            #else:\n            if self.winner_match_asymmetric or not (self.last_winner is not None and self.last_winner_truth_exp > self.SUFFICIENT_MATCH_EXP):\n              if self.last_winner is None:\n                if self.last_label is not None:\n                  ev3 = f\"<{{{self.last_instance}}} --> {self.last_label}>. :|: %{self.last_label_frequency};{0.9}%\"\n                else:\n                  ev3 = f\"<{{{self.last_instance}}} --> [see]>. :|:\"\n                self.Events.append(ev3)\n                if Print:\n                  print(ev3)\n              if self.InstanceCreation:\n                self.prototypes.update(self.current_prototypes)\n            self.current_prototypes = {}\n        if inp == \"1\":\n            self.propertyOfInterest = None\n            if self.last_instance not in self.prototypes:\n                self.removeInstanceProperties(self.last_instance)\n            return\n        self.last_instance = instance\n        if Print:\n          print(\"//\" + inp)\n        if instance not in self.current_prototypes:\n            self.current_prototypes[instance] = (set(),set())\n        #check if instance is in prototypes, in which case the truth value is the revised one:\n        RevisedInstanceProperty = False\n        if instance in self.prototypes:\n            for (prop, TV) in self.prototypes[instance][1]:\n                if prop == property:\n                    self.current_prototypes[instance][1].add((property, Truth_Revision((frequency, 0.9), TV)))\n                    RevisedInstanceProperty = True\n                    break\n        if not RevisedInstanceProperty:\n            self.current_prototypes[instance][1].add((property, (frequency, 0.9)))\n        if self.RelativeComparison:\n            instance_property = instance+\"_\"+property\n            if instance_property not in self.conceptValueReporters:\n                self.conceptValueReporters[instance_property] = ValueReporter()\n            self.conceptValueReporters[instance_property].reportValue(frequency, Print=False, Sensation_Reliance=Sensation_Reliance)\n            #print(\"//RELATIVE VALUE INIT\", instance_property, self.conceptValueReporters[instance_property].reportValue(frequency, RangeUpdate=False, Print=False, Sensation_Reliance=Sensation_Reliance))\n        winner = None\n        winner_truth_exp = 0.0\n        for (key, value) in self.prototypes.items():\n            candidate, reldata, commonProperties = self.inheritances(instance, self.current_prototypes[instance], key, value, asymmetricComparison=False)\n            if candidate is not None and list(candidate.values()):\n              candidate_truth_exp = Truth_Expectation(list(candidate.values())[0])\n              if candidate_truth_exp > winner_truth_exp:\n                  winner = candidate\n                  winner_truth_exp = candidate_truth_exp\n                  self.last_winner_reldata = reldata\n                  self.last_winner_common_properties = commonProperties\n                  self.winner_match_asymmetric = False\n        if winner_truth_exp <= self.SUFFICIENT_MATCH_EXP:\n          for (key, value) in self.prototypes.items():\n            candidate, reldata, commonProperties = self.inheritances(instance, self.current_prototypes[instance], key, value, asymmetricComparison=True)\n            if candidate is not None and list(candidate.values()):\n              candidate_truth_exp = Truth_Expectation(list(candidate.values())[0])\n              if candidate_truth_exp > winner_truth_exp:\n                  winner = candidate\n                  winner_truth_exp = candidate_truth_exp\n                  self.last_winner_reldata = reldata\n                  self.last_winner_common_properties = commonProperties\n                  self.winner_match_asymmetric = True\n        self.last_winner_truth_exp = winner_truth_exp\n        self.last_winner = winner\n        #capacity limit exceeded\n        if len(self.prototypes) > self.AIKR_Limit:\n          minuse = 99999999\n          worstproto = None\n          for proto in self.prototypes:\n            usecount = self.usecounts[proto] if proto in self.usecounts else 0\n            if usecount < minuse:\n              minuse = usecount\n              worstproto = proto\n          self.usecounts.pop(worstproto, None)\n          self.prototypes.pop(worstproto, None)\n          self.position0.pop(worstproto, None)\n          self.position1.pop(worstproto, None)\n          self.conceptnames.discard(worstproto)\n          self.removeInstanceProperties(worstproto)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Nalifier/AddInputVector",
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Nalifier/ShellInput",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/process"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/ValueReporter",
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Truth_Revision",
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Truth_Expectation",
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Nalifier/removeInstanceProperties",
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Nalifier/inheritances"
      ]
    },
    "AddInputVector": {
      "type": "FunctionDef",
      "name": "AddInputVector",
      "md_content": [
        "**AddInputVector**: The AddInputVector function is responsible for adding an input vector to the current object. It takes several parameters, including the name of the vector, the values of the vector, the dimension name (optional), a Print flag (optional), and a Sensation_Reliance value (optional).\n\n**parameters**:\n- `self`: The current object.\n- `name`: The name of the input vector.\n- `values`: The values of the input vector.\n- `dimname` (optional): The dimension name of the input vector. If not provided, it defaults to the name of the vector.\n- `Print` (optional): A boolean value indicating whether the input should be printed. Default is False.\n- `UseHistogram` (optional): A boolean value indicating whether to use a histogram for comparison. Default is True.\n- `Sensation_Reliance` (optional): A float value indicating the reliance on sensation. Default is 0.9.\n\n**Code Description**:\nThe AddInputVector function first checks if the dimension name is None. If it is, the dimension name is set to the name of the vector.\n\nNext, the function iterates over the values in the input vector. For each value, it creates a property name based on the dimension name and the index of the value. If UseHistogram is True and the property name is not in the sensorValueReporters dictionary, a new ValueReporter object is created and added to the dictionary. The continuous_comparison_properties set is also updated with the property name.\n\nThe function then calls the reportValue method of the ValueReporter object to calculate the frequency and confidence of the sensed value. The method returns a tuple (f, c) representing the frequency and confidence.\n\nIf UseHistogram is False, the frequency and confidence are set to the value and Sensation_Reliance, respectively.\n\nFinally, the function calls the AddInput method of the current object to add the input with the appropriate format, including the name, property name, frequency, and Sensation_Reliance.\n\n**Note**:\n- The AddInputVector function is used to add an input vector to the current object.\n- The function calculates the frequency and confidence of the sensed value based on the values in the input vector.\n- The UseHistogram parameter determines whether to use a histogram for comparison.\n- The Sensation_Reliance parameter determines the reliance on sensation.\n- The function uses the ValueReporter class to track and analyze the frequency and confidence of sensed values.\n- The AddInput method is called to add the input with the appropriate format.\n- The Print parameter determines whether the input should be printed.\n- The continuous_comparison_properties set is updated with the property names.\n- The AddInputVector function is called within the Nalifier.py/Nalifier/AddInput method.\n\n**Output Example**:\nIf the Print parameter is set to True, the following output may be printed to the console:\n```\n<{name} |-> [propertyName]>. :|: %{frequency}%\n```\nThe sensed value truth is returned as a tuple `(frequency, confidence * Sensation_Reliance)`."
      ],
      "code_start_line": 427,
      "code_end_line": 441,
      "parent": "Nalifier",
      "params": [
        "self",
        "name",
        "values",
        "dimname",
        "Print",
        "UseHistogram",
        "Sensation_Reliance"
      ],
      "have_return": false,
      "code_content": "    def AddInputVector(self, name, values, dimname=None, Print=False, UseHistogram=True, Sensation_Reliance = 0.9):\n        global sensorValueReporters\n        if dimname is None:\n          dimname = name\n        for i, value in enumerate(values):\n            propertyName = dimname + str(i)\n            if UseHistogram:\n                if propertyName not in self.sensorValueReporters:\n                  self.sensorValueReporters[propertyName] = ValueReporter()\n                #binary_extreme_comparison_properties.add(propertyName)\n                self.continuous_comparison_properties.add(propertyName)\n                (f,c) = self.sensorValueReporters[propertyName].reportValue(value, Print=False, RangeUpdate=self.InstanceCreation, Sensation_Reliance = Sensation_Reliance)\n            else:\n                (f,c) = (value, Sensation_Reliance)\n            self.AddInput(\"<{\" + name + \"} |-> [\" + propertyName + \"]>. :|: %\" + str(f) + \"%\", Print=Print, Sensation_Reliance=Sensation_Reliance) # + str(c) + \"%\")\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/process"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/ValueReporter",
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Nalifier/AddInput"
      ]
    },
    "ShellInput": {
      "type": "FunctionDef",
      "name": "ShellInput",
      "md_content": [
        "**ShellInput**: The ShellInput function is responsible for processing input and performing various operations based on the input received.\n\n**Parameters**:\n- `self`: The current object.\n- `inp`: The input string to be processed.\n\n**Code Description**:\nThe ShellInput function takes an input string `inp` and performs operations based on the input. It first checks if the input starts with \"*SET_CONTINUOUS=\". If it does, the function extracts the property name from the input and adds it to the `sensorValueReporters` dictionary if it is not already present. It also adds the property name to the `continuous_comparison_properties` set. The function returns None.\n\nIf the input starts with \"*PROTOTYPES\", the function prints the current prototypes to the console and returns None.\n\nIf the input starts with \"*PROPERTY_OF_INTEREST=\", the function extracts the property name from the input and assigns it to the `propertyOfInterest` attribute. If the property name is an empty string, the `propertyOfInterest` attribute is set to None. The function returns None.\n\nIf the input starts with \"*RESET_PROTOTYPES=\", the function creates a new instance of the Nalifier class with the specified capacity limit and assigns it to the `self` object. The function returns None.\n\nIf the input starts with \"*SUFFICIENT_MATCH_EXP=\", the function extracts the float value for the sufficient match expectation from the input and assigns it to the `SUFFICIENT_MATCH_EXP` attribute. The function returns None.\n\nIf the input starts with \"*SUFFICIENT_DIFFERENCE_EXP=\", the function extracts the float value for the sufficient difference expectation from the input and assigns it to the `SUFFICIENT_DIFFERENCE_EXP` attribute. The function returns None.\n\nIf the input starts with \"*COMMON_PROPERTY_EXP=\", the function extracts the float value for the common property expectation from the input and assigns it to the `COMMON_PROPERTY_EXP` attribute. The function returns None.\n\nIf the input starts with \"*CONCEPT_CREATION=\", the function extracts the boolean value for the concept creation from the input and assigns it to the `ConceptCreation` attribute. The function returns None.\n\nIf the input starts with \"*INSTANCE_CREATION=\", the function extracts the boolean value for the instance creation from the input and assigns it to the `InstanceCreation` attribute. The function returns None.\n\nIf the input starts with \"*RELATIVE_COMPARISON=\", the function extracts the boolean value for the relative comparison from the input and assigns it to the `RelativeComparison` attribute. The function returns None.\n\nIf the input starts with \"*CLOSED_WORLD_ASSUMPTION=\", the function extracts the boolean value for the closed world assumption from the input and assigns it to the `ClosedWorldAssumption` attribute. The function returns None.\n\nIf the input starts with \"*USE_INTENSIONAL_DIFFERENCE=\", the function extracts the boolean value for the use intensional difference from the input and assigns it to the `UseIntensionalDifference` attribute. The function returns None.\n\nIf none of the above conditions are met, the function performs additional operations based on the input. It splits the input string into two parts: `lhs` and `rhs` using the \". :|:\" separator. If the input is equal to \"1\", the function calls the AddInput function with the input and the Print parameter set to True. If the input contains \"{\" and \"}\" and \"[\" and \"]\" and does not contain \" * \", the function calls the AddInput function with the input and the Print parameter set to True. Otherwise, the function returns the input string.\n\n**Note**:\n- The ShellInput function is a key function in the Nalifier class that processes input and performs various operations based on the input received.\n- The function handles different types of input, including setting continuous properties, printing prototypes, setting the property of interest, resetting prototypes, and setting various attributes.\n- The function calls the AddInput function to process input strings that meet certain conditions.\n- The function updates various attributes of the Nalifier object based on the input and current state.\n- The function returns None for most input strings, except for specific conditions where the AddInput function is called or the input string is returned.\n\n**Output Example**:\nIf the input is \"*SET_CONTINUOUS=temperature\", the function returns None.\nIf the input is \"*PROTOTYPES\", the function prints the current prototypes to the console and returns None.\nIf the input is \"*PROPERTY_OF_INTEREST=humidity\", the function returns None.\nIf the input is \"*RESET_PROTOTYPES=1000\", the function creates a new instance of the Nalifier class with a capacity limit of 1000 and returns None.\nIf the input is \"*SUFFICIENT_MATCH_EXP=0.8\", the function returns None.\nIf the input is \"*SUFFICIENT_DIFFERENCE_EXP=0.5\", the function returns None.\nIf the input is \"*COMMON_PROPERTY_EXP=0.7\", the function returns None.\nIf the input is \"*CONCEPT_CREATION=true\", the function returns None.\nIf"
      ],
      "code_start_line": 443,
      "code_end_line": 493,
      "parent": "Nalifier",
      "params": [
        "self",
        "inp"
      ],
      "have_return": true,
      "code_content": "    def ShellInput(self, inp):\n        if inp.startswith(\"*SET_CONTINUOUS=\"):\n            propertyName = inp.split(\"*SET_CONTINUOUS=\")[1]\n            if propertyName not in self.sensorValueReporters:\n              self.sensorValueReporters[propertyName] = ValueReporter()\n            self.continuous_comparison_properties.add(propertyName)\n            return None\n        if inp.startswith(\"*PROTOTYPES\"):\n            print(\"//\"+str(self.prototypes))\n            return None\n        if inp.startswith(\"*PROPERTY_OF_INTEREST=\"):\n            self.propertyOfInterest = inp.split(\"*PROPERTY_OF_INTEREST=\")[1]\n            if self.propertyOfInterest == \"\":\n                self.propertyOfInterest = None\n            return None\n        if inp.startswith(\"*RESET_PROTOTYPES=\"):\n            self = Nalifier(int(inp.split(\"*RESET_PROTOTYPES=\")[1]))\n            return None\n        if inp.startswith(\"*SUFFICIENT_MATCH_EXP=\"):\n            self.SUFFICIENT_MATCH_EXP = float(inp.split(\"*SUFFICIENT_MATCH_EXP=\")[1])\n            return None\n        if inp.startswith(\"*SUFFICIENT_DIFFERENCE_EXP=\"):\n            self.SUFFICIENT_DIFFERENCE_EXP = float(inp.split(\"*SUFFICIENT_DIFFERENCE_EXP=\")[1])\n            return None\n        if inp.startswith(\"*COMMON_PROPERTY_EXP=\"):\n            self.COMMON_PROPERTY_EXP = float(inp.split(\"*COMMON_PROPERTY_EXP=\")[1])\n            return None\n        if inp.startswith(\"*CONCEPT_CREATION=\"):\n            self.ConceptCreation = True if inp.split(\"*CONCEPT_CREATION=\")[1].lower() == \"true\" else False\n            return None\n        if inp.startswith(\"*INSTANCE_CREATION=\"):\n            self.InstanceCreation = True if inp.split(\"*INSTANCE_CREATION=\")[1].lower() == \"true\" else False\n            return None\n        if inp.startswith(\"*RELATIVE_COMPARISON=\"):\n            self.RelativeComparison = True if inp.split(\"*RELATIVE_COMPARISON=\")[1].lower() == \"true\" else False\n            return None\n        if inp.startswith(\"*CLOSED_WORLD_ASSUMPTION=\"):\n            self.ClosedWorldAssumption = True if inp.split(\"*CLOSED_WORLD_ASSUMPTION=\")[1].lower() == \"true\" else False\n            return None\n        if inp.startswith(\"*USE_INTENSIONAL_DIFFERENCE=\"): #will be used for non-continuous properties only even when true\n            self.UseIntensionalDifference = True if inp.split(\"*USE_INTENSIONAL_DIFFERENCE=\")[1].lower() == \"true\" else False\n            return None\n        lhs = inp.split(\". :|:\")[0]\n        if inp == \"1\":\n            self.AddInput(inp, Print=True)\n            return None\n        elif \". :|:\" in inp and \"{\" in inp and \"}\" in inp and \"[\" in inp and \"]\" in inp and \" * \" not in inp:\n            self.AddInput(inp, Print=True)\n            return None\n        else:\n            return inp\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR_Nalifier.py/ProcessNARret",
        "OpenNARS-for-Applications\\misc\\Python\\NAR_Nalifier.py"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/ValueReporter",
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Nalifier/AddInput"
      ]
    }
  },
  "OpenNARS-for-Applications\\misc\\Python\\NAR.py": {
    "spawnNAR": {
      "type": "FunctionDef",
      "name": "spawnNAR",
      "md_content": [
        "**spawnNAR**: The function of spawnNAR is to spawn a new NAR (Non-Axiomatic Reasoning) process.\n\n**parameters**:\n- None\n\n**Code Description**:\nThe `spawnNAR` function is responsible for creating a new NAR process. It uses the `subprocess.Popen` method to execute the NAR program with the specified arguments. The arguments passed to the `Popen` method are `[\"./../../NAR\", \"shell\"]`, which represent the command to run the NAR program with the \"shell\" argument.\n\nThe `subprocess.Popen` method is a Python built-in function that allows the execution of external programs. It creates a new process and returns a `Popen` object that represents the running process. In this case, the `Popen` object is configured with the following parameters:\n- `stdin=subprocess.PIPE`: This parameter specifies that the standard input of the new process should be redirected to a pipe. This allows communication between the parent process and the spawned NAR process.\n- `stdout=subprocess.PIPE`: This parameter specifies that the standard output of the new process should be redirected to a pipe. This allows capturing the output of the NAR process.\n- `universal_newlines=True`: This parameter ensures that the input and output streams are treated as text streams, allowing for easier handling of text-based communication.\n\nThe `spawnNAR` function returns the `Popen` object representing the spawned NAR process.\n\n**Note**:\n- The `spawnNAR` function assumes that the NAR program is located at the relative path `\"./../../NAR\"`. Make sure the correct path is provided to the NAR program.\n- The `spawnNAR` function relies on the availability of the `subprocess` module in Python. Ensure that the module is installed or accessible in the Python environment where this code is executed.\n\n**Output Example**:\nA possible appearance of the return value of the `spawnNAR` function is a `Popen` object representing the spawned NAR process. This object can be used to interact with the NAR process, such as sending input and reading output."
      ],
      "code_start_line": 7,
      "code_end_line": 8,
      "parent": null,
      "params": [],
      "have_return": true,
      "code_content": "def spawnNAR():\n    return subprocess.Popen([\"./../../NAR\", \"shell\"], stdin=subprocess.PIPE, stdout=subprocess.PIPE, universal_newlines=True)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\distributedNAR.py"
      ],
      "reference_who": []
    },
    "getNAR": {
      "type": "FunctionDef",
      "name": "getNAR",
      "md_content": [
        "**getNAR**: The function of getNAR is to return the NARproc object.\n\n**parameters**:\n- This function does not take any parameters.\n\n**Code Description**:\nThe getNAR function is a simple function that returns the NARproc object. The NARproc object is likely defined elsewhere in the codebase and is being accessed through this function.\n\nFrom the code snippet provided, it can be inferred that the NARproc object is a global variable or an object that is accessible from the current scope. The purpose of encapsulating the access to the NARproc object in this function is to provide a standardized way of obtaining it.\n\nThis function does not perform any complex operations or modifications to the NARproc object. It simply returns it as is.\n\n**Note**:\n- It is important to ensure that the NARproc object is defined and accessible before calling this function. Otherwise, it may result in an error.\n\n**Output Example**:\nA possible appearance of the code's return value:\nNARproc"
      ],
      "code_start_line": 10,
      "code_end_line": 11,
      "parent": null,
      "params": [],
      "have_return": true,
      "code_content": "def getNAR():\n    return NARproc\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\distributedNAR.py"
      ],
      "reference_who": []
    },
    "setNAR": {
      "type": "FunctionDef",
      "name": "setNAR",
      "md_content": [
        "**setNAR**: The function of setNAR is to assign a value to the global variable NARproc.\n\n**parameters**:\n- proc: This parameter represents the value that will be assigned to the global variable NARproc.\n\n**Code Description**:\nThe setNAR function is a simple function that takes a single parameter, proc, and assigns its value to the global variable NARproc. By using the \"global\" keyword, the function ensures that the assignment is made to the global variable and not a local variable with the same name.\n\nThis function is useful when there is a need to update the value of the NARproc variable from within a different scope or module. By calling setNAR and passing the desired value as the proc parameter, the global variable NARproc can be easily updated.\n\n**Note**:\n- It is important to note that the setNAR function does not return any value. Its purpose is solely to update the value of the global variable NARproc.\n- The global keyword is used to indicate that the variable being assigned is a global variable and not a local variable. This ensures that the assignment is made to the intended variable in the global scope."
      ],
      "code_start_line": 12,
      "code_end_line": 14,
      "parent": null,
      "params": [
        "proc"
      ],
      "have_return": false,
      "code_content": "def setNAR(proc):\n    global NARproc\n    NARproc = proc\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "terminateNAR": {
      "type": "FunctionDef",
      "name": "terminateNAR",
      "md_content": [
        "**terminateNAR**: The function of terminateNAR is to terminate the NAR process.\n\n**parameters**:\n- usedNAR: This parameter is optional and represents the NAR process. It is set to the default value of NARproc.\n\n**Code Description**:\nThe `terminateNAR` function is responsible for terminating the NAR process. It uses the `os.killpg` function to send a termination signal (SIGTERM) to the process group ID (PGID) of the specified NAR process.\n\nThe `os.killpg` function is used to send a signal to a process group. In this case, it is used to send the SIGTERM signal, which is the termination signal, to the process group ID of the NAR process. The process group ID is obtained using the `os.getpgid` function, which returns the process group ID of the specified process.\n\nBy terminating the NAR process, any ongoing computations or tasks performed by the NAR system will be stopped.\n\n**Note**:\n- It is important to ensure that the `usedNAR` parameter is correctly set to the NAR process that needs to be terminated. If not specified, the default value of NARproc will be used, which may not be the desired process.\n- The termination of the NAR process may result in the loss of any unsaved data or incomplete computations. It is recommended to save any necessary data before calling this function."
      ],
      "code_start_line": 15,
      "code_end_line": 16,
      "parent": null,
      "params": [
        "usedNAR"
      ],
      "have_return": false,
      "code_content": "def terminateNAR(usedNAR=NARproc):\n    os.killpg(os.getpgid(usedNAR.pid), signal.SIGTERM)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "parseTruth": {
      "type": "FunctionDef",
      "name": "parseTruth",
      "md_content": [
        "**parseTruth**: The function of parseTruth is to extract the frequency and confidence values from a given string.\n\n**parameters**:\n- T: A string containing the truth value in the format \"frequency=<value> confidence=<value> dt=<value> occurrenceTime=<value>\"\n\n**Code Description**:\nThe parseTruth function takes a string as input and returns a dictionary containing the extracted frequency and confidence values. \n\nThe function first splits the input string using the \"frequency=\" substring as the delimiter. The second element of the resulting list is then split using the \" confidence\" substring as the delimiter. The first element of this new list is the extracted frequency value. The function removes any commas from the frequency value using the replace method.\n\nNext, the input string is split using the \" confidence=\" substring as the delimiter. The second element of the resulting list is then split using the \" dt=\" substring as the delimiter. The first element of this new list is the extracted confidence value.\n\nThe extracted frequency and confidence values are then stored in a dictionary with the keys \"frequency\" and \"confidence\" respectively. The dictionary is returned as the output of the function.\n\nThe parseTruth function is called by the parseTask function in the OpenNARS-for-Applications\\misc\\Python\\NAR.py/parseTask object. The parseTask function extracts various properties from a given string, including the truth value. If the input string contains the substring \"Truth: \", the parseTruth function is called to extract the frequency and confidence values from the truth value.\n\n**Note**:\n- The input string must be in the format \"frequency=<value> confidence=<value> dt=<value> occurrenceTime=<value>\" for the function to extract the frequency and confidence values correctly.\n\n**Output Example**:\nIf the input string is \"frequency=0.8 confidence=0.9 dt=0.5 occurrenceTime=now\", the parseTruth function will return the following dictionary:\n{\"frequency\": \"0.8\", \"confidence\": \"0.9\"}"
      ],
      "code_start_line": 18,
      "code_end_line": 19,
      "parent": null,
      "params": [
        "T"
      ],
      "have_return": true,
      "code_content": "def parseTruth(T):\n    return {\"frequency\": T.split(\"frequency=\")[1].split(\" confidence\")[0].replace(\",\",\"\"), \"confidence\": T.split(\" confidence=\")[1].split(\" dt=\")[0].split(\" occurrenceTime=\")[0]}\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR.py/parseTask"
      ],
      "reference_who": []
    },
    "parseTask": {
      "type": "FunctionDef",
      "name": "parseTask",
      "md_content": [
        "**parseTask**: The function of parseTask is to extract various properties from a given string and store them in a dictionary.\n\n**parameters**:\n- s: A string containing the properties to be extracted.\n\n**Code Description**:\nThe parseTask function takes a string as input and returns a dictionary containing the extracted properties. \n\nThe function first initializes a dictionary called M with a default value for the \"occurrenceTime\" property set to \"eternal\".\n\nNext, the function checks if the input string contains the substring \" :|:\". If it does, it updates the value of the \"occurrenceTime\" property in the M dictionary to \"now\" and removes the \" :|:\" substring from the input string.\n\nIf the input string also contains the substring \"occurrenceTime=\", the function extracts the value of the \"occurrenceTime\" property from the input string and updates the value of the \"occurrenceTime\" property in the M dictionary accordingly.\n\nThe function then checks if the input string contains the substring \"Stamp\". If it does, it extracts the value of the \"Stamp\" property from the input string using the ast.literal_eval function, which evaluates the string as a Python expression and returns the corresponding object.\n\nNext, the function extracts the sentence from the input string. If the input string contains the substring \" occurrenceTime=\", the sentence is extracted up to that substring. Otherwise, the sentence is extracted up to the first occurrence of any of the substrings \" Stamp=\", \" Priority=\", or \" creationTime=\".\n\nThe function then extracts the value of the \"punctuation\" property from the sentence. If the sentence contains the substring \":|:\", the value of the \"punctuation\" property is set to the character at the fourth-to-last position of the sentence. Otherwise, it is set to the last character of the sentence.\n\nThe function further extracts the value of the \"term\" property from the sentence. It removes any occurrences of the substrings \" creationTime\", \" occurrenceTime\", \" Truth\", and \" Stamp=\" from the sentence, and removes the last character from the resulting string.\n\nIf the input string contains the substring \"Truth\", the function calls the parseTruth function to extract the frequency and confidence values from the input string and stores them in the M dictionary with the keys \"frequency\" and \"confidence\" respectively.\n\nIf the input string contains the substring \"Priority\", the function extracts the value of the \"Priority\" property from the input string and stores it in the M dictionary.\n\nFinally, the function returns the M dictionary containing the extracted properties.\n\nThe parseTask function is called by the parseReason and GetOutput objects in the OpenNARS-for-Applications\\misc\\Python\\NAR.py module. It is used to extract properties from strings representing reasons and outputs respectively.\n\n**Note**:\n- The input string must be in a specific format for the function to extract the properties correctly.\n- The parseTruth function is called to extract the frequency and confidence values from the input string if it contains the substring \"Truth: \".\n\n**Output Example**:\nIf the input string is \"occurrenceTime=now Stamp=[1, 2, 3] Priority=high\", the parseTask function will return the following dictionary:\n{\"occurrenceTime\": \"now\", \"Stamp\": [1, 2, 3], \"punctuation\": \"=\", \"term\": \"occurrenceTime\", \"Priority\": \"high\"}"
      ],
      "code_start_line": 21,
      "code_end_line": 37,
      "parent": null,
      "params": [
        "s"
      ],
      "have_return": true,
      "code_content": "def parseTask(s):\n    M = {\"occurrenceTime\" : \"eternal\"}\n    if \" :|:\" in s:\n        M[\"occurrenceTime\"] = \"now\"\n        s = s.replace(\" :|:\",\"\")\n        if \"occurrenceTime\" in s:\n            M[\"occurrenceTime\"] = s.split(\"occurrenceTime=\")[1].split(\" \")[0]\n    if \"Stamp\" in s:\n        M[\"Stamp\"] = ast.literal_eval(s.split(\"Stamp=\")[1].split(\"]\")[0]+\"]\")\n    sentence = s.split(\" occurrenceTime=\")[0] if \" occurrenceTime=\" in s else s.split(\" Stamp=\")[0].split(\" Priority=\")[0].split(\" creationTime=\")[0]\n    M[\"punctuation\"] = sentence[-4] if \":|:\" in sentence else sentence[-1]\n    M[\"term\"] = sentence.split(\" creationTime\")[0].split(\" occurrenceTime\")[0].split(\" Truth\")[0].split(\" Stamp=\")[0][:-1]\n    if \"Truth\" in s:\n        M[\"truth\"] = parseTruth(s.split(\"Truth: \")[1])\n    if \"Priority\" in s:\n        M[\"Priority\"] = s.split(\"Priority=\")[1].split(\" \")[0]\n    return M\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR.py/parseReason",
        "OpenNARS-for-Applications\\misc\\Python\\NAR.py/GetOutput"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR.py/parseTruth"
      ]
    },
    "parseReason": {
      "type": "FunctionDef",
      "name": "parseReason",
      "md_content": [
        "**parseReason**: The function of parseReason is to extract various properties from a given string representing a reason and store them in a dictionary.\n\n**parameters**:\n- sraw: A string representing a reason.\n\n**Code Description**:\nThe parseReason function takes a string representing a reason as input and returns a dictionary containing the extracted properties.\n\nThe function first checks if the input string contains the substring \"implication: \". If it does not, the function returns None.\n\nIf the input string contains the substring \"implication: \", the function extracts the value of the \"Implication\" property from the input string using the parseTask function. The parseTask function is called with the substring after \"implication: \" and before \"precondition: \" as the input. The resulting dictionary is assigned to the variable Implication.\n\nNext, the function extracts the value of the \"Precondition\" property from the input string using the parseTask function. The parseTask function is called with the substring after \"precondition: \" and before the first occurrence of a newline character as the input. The resulting dictionary is assigned to the variable Precondition.\n\nThe function then sets the \"occurrenceTime\" property of the Implication dictionary to \"eternal\".\n\nThe function further sets the \"punctuation\" property of both the Implication and Precondition dictionaries to \".\".\n\nFinally, the function creates a dictionary called Reason and assigns the value of the \"decision expectation\" property from the input string to the \"desire\" property of the Reason dictionary. The value of the Implication dictionary is assigned to the \"hypothesis\" property of the Reason dictionary, and the value of the Precondition dictionary is assigned to the \"precondition\" property of the Reason dictionary. The Reason dictionary is then returned.\n\n**Note**:\n- The input string must be in a specific format for the function to extract the properties correctly.\n- The parseTask function is called to extract the Implication and Precondition properties from the input string.\n\n**Output Example**:\nIf the input string is \"implication: occurrenceTime=now\\nprecondition: occurrenceTime=eternal\\ndecision expectation=high\", the parseReason function will return the following dictionary:\n{\"desire\": \"high\", \"hypothesis\": {\"occurrenceTime\": \"now\"}, \"precondition\": {\"occurrenceTime\": \"eternal\"}}"
      ],
      "code_start_line": 39,
      "code_end_line": 50,
      "parent": null,
      "params": [
        "sraw"
      ],
      "have_return": true,
      "code_content": "def parseReason(sraw):\n    if \"implication: \" not in sraw:\n        return None\n    Implication = parseTask(sraw.split(\"implication: \")[-1].split(\"precondition: \")[0]) #last reason only (others couldn't be associated currently)\n    Precondition = parseTask(sraw.split(\"precondition: \")[-1].split(\"\\n\")[0])\n    Implication[\"occurrenceTime\"] = \"eternal\"\n    Precondition[\"punctuation\"] = Implication[\"punctuation\"] = \".\"\n    Reason = {}\n    Reason[\"desire\"] = sraw.split(\"decision expectation=\")[-1].split(\" \")[0]\n    Reason[\"hypothesis\"] = Implication\n    Reason[\"precondition\"] = Precondition\n    return Reason\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR.py/GetOutput"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR.py/parseTask"
      ]
    },
    "parseExecution": {
      "type": "FunctionDef",
      "name": "parseExecution",
      "md_content": [
        "**parseExecution**: The function of parseExecution is to parse the execution information from a given string.\n\n**parameters**:\n- e: A string representing the execution information.\n\n**Code Description**:\nThe parseExecution function takes a string as input and parses the execution information from it. It first checks if the string contains the substring \"args \". If not, it returns a dictionary with the \"operator\" key set to the first word in the string and the \"arguments\" key set to an empty list.\n\nIf the string contains the substring \"args \", it splits the string by spaces and retrieves the first word as the \"operator\". It then splits the string by the substring \"args \" and retrieves the second part. This second part is further split by the substring \"{SELF} * \" to remove the leading \"{SELF} * \" and the trailing character, which is assumed to be a closing bracket. The resulting string is assigned to the \"arguments\" key in the dictionary.\n\nThe function finally returns the dictionary with the \"operator\" and \"arguments\" keys set according to the parsed information.\n\nThis function is called within the GetOutput function in the NAR.py file. In the GetOutput function, the parseExecution function is used to parse the execution information from each line in a list of strings. The lines are filtered based on a specific condition, and the parseExecution function is applied to each filtered line using a list comprehension. The parsed execution information is then stored in a list.\n\n**Note**:\n- The parseExecution function assumes that the input string follows a specific format where the operator and arguments are separated by spaces and the arguments are enclosed in curly braces.\n- The function expects the input string to contain the substring \"args \" if it contains any arguments.\n- The function does not handle cases where the input string does not follow the expected format. In such cases, the behavior of the function is undefined.\n\n**Output Example**:\nIf the input string is \"add args {SELF} * {a, b}\", the function will return the following dictionary:\n{\n  \"operator\": \"add\",\n  \"arguments\": \"a, b\"\n}"
      ],
      "code_start_line": 52,
      "code_end_line": 55,
      "parent": null,
      "params": [
        "e"
      ],
      "have_return": true,
      "code_content": "def parseExecution(e):\n    if \"args \" not in e:\n        return {\"operator\" : e.split(\" \")[0], \"arguments\" : []}\n    return {\"operator\" : e.split(\" \")[0], \"arguments\" : e.split(\"args \")[1].split(\"{SELF} * \")[1][:-1]}\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR.py/GetOutput"
      ],
      "reference_who": []
    },
    "GetRawOutput": {
      "type": "FunctionDef",
      "name": "GetRawOutput",
      "md_content": [
        "**GetRawOutput**: The function of GetRawOutput is to retrieve the raw output from the NAR (Non-Axiomatic Reasoning) system.\n\n**parameters**:\n- usedNAR: An instance of the NAR system.\n\n**Code Description**:\nThe GetRawOutput function takes an instance of the NAR system as input and retrieves the raw output generated by the system. It communicates with the NAR system through its standard input and output streams.\n\nThe function starts by writing \"0\\n\" to the standard input of the NAR system, which represents a command to retrieve the raw output. It then flushes the standard input to ensure the command is sent immediately.\n\nA variable named \"ret\" is initialized as an empty string to store the output received from the NAR system. Another variable named \"before\" is initialized as an empty list to store the lines of output before the expected output is reached. A boolean variable named \"requestOutputArgs\" is set to False initially.\n\nThe function enters a while loop that continues until the string \"done with 0 additional inference steps.\" is received from the NAR system. Within the loop, the function checks if the received output is not empty and appends it to the \"before\" list. It also checks if the received output is equal to \"//Operation result product expected:\". If this condition is met, it sets the \"requestOutputArgs\" variable to True and breaks out of the loop.\n\nThe function reads the next line of output from the NAR system using the stdout.readline() method and assigns it to the \"ret\" variable.\n\nFinally, the function returns the \"before\" list excluding the last element (which is the expected output) and the value of the \"requestOutputArgs\" variable.\n\nFrom a functional perspective, the GetRawOutput function is called by multiple objects in the project. The GetOutput function calls GetRawOutput to retrieve the raw output and then parses the output to extract different types of information such as executions, inputs, derivations, answers, selections, and reason. The GetStats function also calls GetRawOutput to retrieve the raw output and then extracts statistical information from the output. The AddInput function calls GetRawOutput to retrieve the raw output and then either prints it or returns it along with other parsed information.\n\n**Note**: \n- The GetRawOutput function assumes that the NAR system is already running and its standard input and output streams are accessible.\n- The function expects the NAR system to generate the output in a specific format, where \"//Operation result product expected:\" is used as a marker to indicate that the expected output is about to be generated.\n- The function assumes that the NAR system will eventually generate the string \"done with 0 additional inference steps.\" to indicate the completion of the output generation process.\n\n**Output Example**:\n```python\nbefore = [\n    \"Some line of output 1\",\n    \"Some line of output 2\",\n    \"Some line of output 3\"\n]\nrequestOutputArgs = True\n```"
      ],
      "code_start_line": 57,
      "code_end_line": 70,
      "parent": null,
      "params": [
        "usedNAR"
      ],
      "have_return": true,
      "code_content": "def GetRawOutput(usedNAR):\n    usedNAR.stdin.write(\"0\\n\")\n    usedNAR.stdin.flush()\n    ret = \"\"\n    before = []\n    requestOutputArgs = False\n    while \"done with 0 additional inference steps.\" != ret.strip():\n        if ret != \"\":\n            before.append(ret.strip())\n        if ret.strip() == \"//Operation result product expected:\":\n            requestOutputArgs = True\n            break\n        ret = usedNAR.stdout.readline()\n    return before[:-1], requestOutputArgs\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR.py/GetOutput",
        "OpenNARS-for-Applications\\misc\\Python\\NAR.py/GetStats",
        "OpenNARS-for-Applications\\misc\\Python\\NAR.py/AddInput"
      ],
      "reference_who": []
    },
    "GetOutput": {
      "type": "FunctionDef",
      "name": "GetOutput",
      "md_content": [
        "**GetOutput**: The function of GetOutput is to parse the raw output generated by the NAR (Non-Axiomatic Reasoning) system and extract different types of information such as executions, inputs, derivations, answers, selections, and reason.\n\n**parameters**:\n- usedNAR: An instance of the NAR system.\n\n**Code Description**:\nThe GetOutput function takes an instance of the NAR system as input and retrieves the raw output generated by the system. It then parses the output to extract various types of information and returns them in a dictionary.\n\nThe function first calls the GetRawOutput function, passing the usedNAR instance as an argument. The GetRawOutput function communicates with the NAR system to retrieve the raw output and returns it as a list of strings. The function also returns a boolean value, requestOutputArgs, indicating whether the output contains arguments for the requested operation.\n\nThe function then proceeds to parse the raw output to extract different types of information. It initializes several empty lists, including lines, requestOutputArgs, executions, inputs, derivations, answers, and selections. \n\nThe function iterates over each line in the raw output and performs specific parsing operations based on the line's content. For lines starting with '^', the function calls the parseExecution function to parse the execution information and appends the parsed information to the executions list. For lines starting with 'Input:', the function calls the parseTask function to parse the input information and appends the parsed information to the inputs list. For lines starting with 'Derived:' or 'Revised:', the function calls the parseTask function to parse the derivation information and appends the parsed information to the derivations list. For lines starting with 'Answer:', the function calls the parseTask function to parse the answer information and appends the parsed information to the answers list. For lines starting with 'Selected:', the function calls the parseTask function to parse the selection information and appends the parsed information to the selections list.\n\nThe function also calls the parseReason function, passing the entire raw output as a string, to parse the reason information. The parsed reason information is stored in the reason variable.\n\nFinally, the function constructs a dictionary containing all the parsed information, including inputs, derivations, answers, executions, reason, selections, raw (the entire raw output as a string), and requestOutputArgs. The dictionary is then returned as the output of the GetOutput function.\n\n**Note**:\n- The GetOutput function relies on the GetRawOutput, parseExecution, parseTask, and parseReason functions to parse the raw output and extract the desired information.\n- The function assumes that the raw output follows a specific format where different types of information are marked by specific prefixes (e.g., '^' for executions, 'Input:' for inputs, etc.).\n- The function assumes that the parseExecution, parseTask, and parseReason functions are able to correctly parse the respective types of information from the raw output.\n- The function assumes that the parseTask and parseReason functions are defined and accessible within the same module as the GetOutput function.\n\n**Output Example**:\nIf the raw output contains the following lines:\n```\n^execution1\nInput: input1\nDerived: derived1\nAnswer: answer1\nSelected: selected1\n^execution2\nInput: input2\nDerived: derived2\nAnswer: answer2\nSelected: selected2\n```\nThe GetOutput function will return the following dictionary:\n```\n{\n  \"input\": [\"input1\", \"input2\"],\n  \"derivations\": [\"derived1\", \"derived2\"],\n  \"answers\": [\"answer1\", \"answer2\"],\n  \"executions\": [\"execution1\", \"execution2\"],\n  \"reason\": {\"reason_info\": \"reason_info_value\"},\n  \"selections\": [\"selected1\", \"selected2\"],\n  \"raw\": \"^execution1\\nInput: input1\\nDerived: derived1\\nAnswer: answer1\\nSelected: selected1\\n^execution2\\nInput: input2\\nDerived: derived2\\nAnswer: answer2\\nSelected: selected2\\n\",\n  \"requestOutputArgs\": True\n}\n```"
      ],
      "code_start_line": 72,
      "code_end_line": 80,
      "parent": null,
      "params": [
        "usedNAR"
      ],
      "have_return": true,
      "code_content": "def GetOutput(usedNAR):\n    lines, requestOutputArgs = GetRawOutput(usedNAR)\n    executions = [parseExecution(l) for l in lines if l.startswith('^')]\n    inputs = [parseTask(l.split(\"Input: \")[1]) for l in lines if l.startswith('Input:')]\n    derivations = [parseTask(l.split(\"Derived: \" if l.startswith('Derived:') else \"Revised: \")[1]) for l in lines if l.startswith('Derived:') or l.startswith('Revised:')]\n    answers = [parseTask(l.split(\"Answer: \")[1]) for l in lines if l.startswith('Answer:')]\n    selections = [parseTask(l.split(\"Selected: \")[1]) for l in lines if l.startswith('Selected:')]\n    reason = parseReason(\"\\n\".join(lines))\n    return {\"input\": inputs, \"derivations\": derivations, \"answers\": answers, \"executions\": executions, \"reason\": reason, \"selections\": selections, \"raw\": \"\\n\".join(lines), \"requestOutputArgs\" : requestOutputArgs}\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR.py/AddInput"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR.py/parseTask",
        "OpenNARS-for-Applications\\misc\\Python\\NAR.py/parseReason",
        "OpenNARS-for-Applications\\misc\\Python\\NAR.py/parseExecution",
        "OpenNARS-for-Applications\\misc\\Python\\NAR.py/GetRawOutput"
      ]
    },
    "GetStats": {
      "type": "FunctionDef",
      "name": "GetStats",
      "md_content": [
        "**GetStats**: The function of GetStats is to extract statistical information from the raw output generated by the NAR (Non-Axiomatic Reasoning) system.\n\n**parameters**:\n- usedNAR: An instance of the NAR system.\n\n**Code Description**:\nThe GetStats function takes an instance of the NAR system as input and retrieves the raw output using the GetRawOutput function. It then parses the raw output to extract statistical information and stores it in a dictionary named \"Stats\".\n\nThe function starts by initializing an empty dictionary named \"Stats\" to store the extracted statistical information. It calls the GetRawOutput function and assigns the returned value to two variables: \"lines\" and an underscore variable.\n\nThe function enters a for loop that iterates over each line in the \"lines\" list. It checks if the line contains a colon \":\" using the \"in\" operator. If the condition is true, it splits the line at the colon \":\" using the split() method and assigns the left side of the split to a variable named \"leftside\". It replaces any spaces in the \"leftside\" string with underscores \"_\" using the replace() method and removes any leading or trailing whitespace using the strip() method. It also splits the right side of the split at the colon \":\" using the split() method and assigns the stripped value to a variable named \"rightside\". The \"rightside\" value is then converted to a float using the float() function.\n\nThe function adds an entry to the \"Stats\" dictionary with the \"leftside\" as the key and the \"rightside\" as the value.\n\nFinally, the function returns the \"Stats\" dictionary containing the extracted statistical information.\n\n**Note**: \n- The GetStats function assumes that the NAR system is already running and its standard input and output streams are accessible.\n- The function relies on the GetRawOutput function to retrieve the raw output from the NAR system.\n- The function expects the raw output to be in a specific format where statistical information is represented as key-value pairs separated by a colon \":\".\n- The function converts the extracted statistical values to floats for numerical calculations or comparisons.\n\n**Output Example**:\n```python\nStats = {\n    \"Execution_Time\": 0.123,\n    \"Inference_Steps\": 10,\n    \"Memory_Usage\": 123.45\n}\n```"
      ],
      "code_start_line": 82,
      "code_end_line": 90,
      "parent": null,
      "params": [
        "usedNAR"
      ],
      "have_return": true,
      "code_content": "def GetStats(usedNAR):\n    Stats = {}\n    lines, _ = GetRawOutput(usedNAR)\n    for l in lines:\n        if \":\" in l:\n            leftside = l.split(\":\")[0].replace(\" \", \"_\").strip()\n            rightside = float(l.split(\":\")[1].strip())\n            Stats[leftside] = rightside\n    return Stats\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR.py/AddInput"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR.py/GetRawOutput"
      ]
    },
    "AddInput": {
      "type": "FunctionDef",
      "name": "AddInput",
      "md_content": [
        "**AddInput**: The function of AddInput is to send a Narsese input to the NAR (Non-Axiomatic Reasoning) system and process the output.\n\n**parameters**:\n- narsese: A string representing the Narsese input to be added.\n- Print (optional): A boolean value indicating whether to print the raw output. Default is True.\n- usedNAR (optional): An instance of the NAR system. Default is NARproc.\n\n**Code Description**:\nThe AddInput function takes a Narsese input as a string and sends it to the NAR system for processing. It communicates with the NAR system through its standard input and output streams.\n\nThe function starts by writing the Narsese input followed by a newline character to the standard input of the NAR system using the stdin.write() method. It then flushes the standard input to ensure the input is sent immediately using the stdin.flush() method.\n\nThe function checks if the Narsese input is equal to \"*stats\" to determine if the user wants to retrieve statistical information from the NAR system. If this condition is true, the function calls the GetStats function to retrieve the statistical information and returns it. If the Print parameter is True, the function also prints the raw output using the print() function.\n\nIf the Narsese input is not equal to \"*stats\", the function calls the GetOutput function to retrieve the parsed output from the NAR system. The parsed output contains different types of information such as executions, inputs, derivations, answers, selections, and reason. If the Print parameter is True, the function prints the \"raw\" key of the parsed output, which represents the entire raw output as a string. The sys.stdout.flush() function is used to ensure the printed output is immediately visible.\n\nFinally, the function returns the parsed output, which includes the inputs, derivations, answers, executions, reason, selections, raw (the entire raw output as a string), and requestOutputArgs (a boolean value indicating whether the output contains arguments for the requested operation).\n\n**Note**:\n- The AddInput function assumes that the NAR system is already running and its standard input and output streams are accessible.\n- The function relies on the GetStats and GetOutput functions to retrieve the statistical and parsed output from the NAR system, respectively.\n- The function allows the user to specify whether to print the raw output and which NAR instance to use through the Print and usedNAR parameters, respectively.\n- The function assumes that the GetStats and GetOutput functions are defined and accessible within the same module as the AddInput function.\n\n**Output Example**:\nIf the Narsese input is \"*stats\" and the Print parameter is True, the function will print the following raw output:\n```\nExecution_Time: 0.123\nInference_Steps: 10\nMemory_Usage: 123.45\n```\nThe function will also return the following parsed output:\n```python\n{\n  \"input\": [],\n  \"derivations\": [],\n  \"answers\": [],\n  \"executions\": [],\n  \"reason\": {},\n  \"selections\": [],\n  \"raw\": \"Execution_Time: 0.123\\nInference_Steps: 10\\nMemory_Usage: 123.45\\n\",\n  \"requestOutputArgs\": False\n}\n```"
      ],
      "code_start_line": 92,
      "code_end_line": 104,
      "parent": null,
      "params": [
        "narsese",
        "Print",
        "usedNAR"
      ],
      "have_return": true,
      "code_content": "def AddInput(narsese, Print=True, usedNAR=NARproc):\n    usedNAR.stdin.write(narsese + '\\n')\n    usedNAR.stdin.flush()\n    ReturnStats = narsese == \"*stats\"\n    if ReturnStats:\n        if Print:\n            print(\"\\n\".join(GetRawOutput(usedNAR)[0]))\n        return GetStats(usedNAR)\n    ret = GetOutput(usedNAR)\n    if Print:\n        print(ret[\"raw\"])\n        sys.stdout.flush()\n    return ret\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR.py/Reset",
        "OpenNARS-for-Applications\\misc\\Python\\NAR.py/Shell",
        "OpenNARS-for-Applications\\misc\\Python\\NAR_Nalifier.py",
        "OpenNARS-for-Applications\\misc\\Python\\NAR_json.py",
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py",
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/produceSentenceNarsese",
        "OpenNARS-for-Applications\\misc\\Python\\blocks.py",
        "OpenNARS-for-Applications\\misc\\Python\\blocks.py/sim_step",
        "OpenNARS-for-Applications\\misc\\Python\\conditioning.py",
        "OpenNARS-for-Applications\\misc\\Python\\count_sheep.py",
        "OpenNARS-for-Applications\\misc\\Python\\discriminativefunction.py",
        "OpenNARS-for-Applications\\misc\\Python\\distributedNAR.py/Trickle",
        "OpenNARS-for-Applications\\misc\\Python\\distributedNAR.py/PerformIndependentSteps",
        "OpenNARS-for-Applications\\misc\\Python\\distributedNAR.py/AddInput",
        "OpenNARS-for-Applications\\misc\\Python\\gridlearn.py",
        "OpenNARS-for-Applications\\misc\\Python\\gridplan.py",
        "OpenNARS-for-Applications\\misc\\Python\\identitymatching.py",
        "OpenNARS-for-Applications\\misc\\Python\\matchtosample_handeye.py",
        "OpenNARS-for-Applications\\misc\\Python\\matchtosample_handeye.py/op_left",
        "OpenNARS-for-Applications\\misc\\Python\\matchtosample_handeye.py/op_right",
        "OpenNARS-for-Applications\\misc\\Python\\matchtosample_handeye.py/op_up",
        "OpenNARS-for-Applications\\misc\\Python\\matchtosample_handeye.py/create_new_match_to_sample_scenario",
        "OpenNARS-for-Applications\\misc\\Python\\matchtosample_handeye.py/op_pick",
        "OpenNARS-for-Applications\\misc\\Python\\matchtosample_handeye.py/step",
        "OpenNARS-for-Applications\\misc\\Python\\minigrid_ona.py",
        "OpenNARS-for-Applications\\misc\\Python\\persistentNAR.py",
        "OpenNARS-for-Applications\\misc\\Python\\persistentNAR.py/Allow_requery_if_not_in_ONA",
        "OpenNARS-for-Applications\\misc\\Python\\persistentNAR.py/query",
        "OpenNARS-for-Applications\\misc\\Python\\robot_collect_mission.py/NAR_Invoke",
        "OpenNARS-for-Applications\\misc\\Python\\robot_collect_mission.py",
        "OpenNARS-for-Applications\\misc\\Python\\sortingtask.py",
        "OpenNARS-for-Applications\\misc\\Python\\trafficpredict.py",
        "OpenNARS-for-Applications\\misc\\Python\\trafficpredict.py/InformPredictionNar/Input",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/TransbotExecute",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/TransbotPerceiveAt",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/TransbotPerceiveVisual",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/reset_ona",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/process"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR.py/GetRawOutput",
        "OpenNARS-for-Applications\\misc\\Python\\NAR.py/GetOutput",
        "OpenNARS-for-Applications\\misc\\Python\\NAR.py/GetStats"
      ]
    },
    "Exit": {
      "type": "FunctionDef",
      "name": "Exit",
      "md_content": [
        "**Exit**: The function of Exit is to send a \"quit\" command to the usedNAR process.\n\n**parameters**:\n- usedNAR: This parameter is optional and represents the NAR process to which the \"quit\" command will be sent. If not provided, the default value is NARproc.\n\n**Code Description**:\nThe Exit function is a simple function that sends a \"quit\" command to the usedNAR process. It takes an optional parameter, usedNAR, which represents the NAR process to which the command will be sent. If the usedNAR parameter is not provided, the function uses the default value NARproc.\n\nThe function uses the sendline method of the usedNAR process to send the \"quit\" command. The sendline method sends a line of text to the process, followed by a newline character. In this case, the \"quit\" command is sent as a line of text to the usedNAR process.\n\nThe purpose of sending the \"quit\" command is to terminate the NAR process. This can be useful when the NAR process is no longer needed and should be stopped.\n\n**Note**:\n- It is important to ensure that the usedNAR process is running and accessible before calling the Exit function. Otherwise, an error may occur.\n- If the usedNAR parameter is not provided, the function will use the default value NARproc. Make sure that NARproc is a valid NAR process before calling the Exit function."
      ],
      "code_start_line": 106,
      "code_end_line": 107,
      "parent": null,
      "params": [
        "usedNAR"
      ],
      "have_return": false,
      "code_content": "def Exit(usedNAR=NARproc):\n    usedNAR.sendline(\"quit\")\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "Reset": {
      "type": "FunctionDef",
      "name": "Reset",
      "md_content": [
        "**Reset**: The function of Reset is to reset the NAR (Non-Axiomatic Reasoning) system by adding a \"*reset\" Narsese input.\n\n**parameters**:\n- usedNAR (optional): An instance of the NAR system. Default is NARproc.\n\n**Code Description**:\nThe Reset function is a simple wrapper function that calls the AddInput function with the \"*reset\" Narsese input. The AddInput function is responsible for sending the Narsese input to the NAR system and processing the output.\n\nThe Reset function takes an optional parameter usedNAR, which represents an instance of the NAR system. If no instance is provided, the default instance NARproc is used.\n\nWhen called, the Reset function passes the \"*reset\" Narsese input to the AddInput function along with the usedNAR parameter. The AddInput function then sends the Narsese input to the NAR system for processing.\n\n**Note**:\n- The Reset function assumes that the NAR system is already running and its standard input and output streams are accessible.\n- The function relies on the AddInput function to send the Narsese input to the NAR system and process the output.\n- The function allows the user to specify which NAR instance to use through the usedNAR parameter. If no instance is provided, the default instance NARproc is used.\n- The function assumes that the AddInput function is defined and accessible within the same module as the Reset function."
      ],
      "code_start_line": 109,
      "code_end_line": 110,
      "parent": null,
      "params": [
        "usedNAR"
      ],
      "have_return": false,
      "code_content": "def Reset(usedNAR=NARproc):\n    AddInput(\"*reset\", usedNAR=usedNAR)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR.py/AddInput"
      ]
    },
    "PrintedTask": {
      "type": "FunctionDef",
      "name": "PrintedTask",
      "md_content": [
        "**PrintedTask**: The function of PrintedTask is to generate a string representation of a task based on the provided task object.\n\n**Parameters**:\n- task: A dictionary object representing a task. It should have the following keys:\n  - \"term\": A string representing the term of the task.\n  - \"punctuation\": A string representing the punctuation of the task.\n  - \"occurrenceTime\": A string representing the occurrence time of the task.\n  - \"Priority\" (optional): An integer representing the priority of the task.\n  - \"truth\" (optional): A dictionary object representing the truth value of the task. It should have the following keys:\n    - \"frequency\": A string representing the frequency of the truth value.\n    - \"confidence\": A string representing the confidence of the truth value.\n\n**Code Description**:\nThe PrintedTask function takes a task object as input and generates a string representation of the task. It first initializes the string variable \"st\" with the concatenation of the \"term\" and \"punctuation\" values from the task object.\n\nNext, it checks if the \"occurrenceTime\" value is a digit. If it is, it appends the string \" :|: occurrenceTime=\" followed by the \"occurrenceTime\" value to the \"st\" variable.\n\nThen, it checks if the \"Priority\" key is present in the task object. If it is, it appends the string \" Priority=\" followed by the value of the \"Priority\" key converted to a string.\n\nFinally, it checks if the \"truth\" key is present in the task object. If it is, it appends the string \" Truth: frequency=\" followed by the \"frequency\" value from the \"truth\" dictionary, and then appends the string \" confidence=\" followed by the \"confidence\" value from the \"truth\" dictionary.\n\nThe function then returns the generated string representation of the task.\n\n**Note**: \n- The \"occurrenceTime\" value is only included in the generated string if it is a digit.\n- The \"Priority\" value is only included in the generated string if the \"Priority\" key is present in the task object.\n- The \"truth\" value is only included in the generated string if the \"truth\" key is present in the task object.\n\n**Output Example**:\nIf the task object is:\n```python\ntask = {\n    \"term\": \"Buy groceries\",\n    \"punctuation\": \".\",\n    \"occurrenceTime\": \"123456\",\n    \"Priority\": 3,\n    \"truth\": {\n        \"frequency\": \"high\",\n        \"confidence\": \"0.8\"\n    }\n}\n```\nThe output of PrintedTask(task) would be:\n```\n\"Buy groceries. :|: occurrenceTime=123456 Priority=3 Truth: frequency=high confidence=0.8\"\n```"
      ],
      "code_start_line": 114,
      "code_end_line": 119,
      "parent": null,
      "params": [
        "task"
      ],
      "have_return": true,
      "code_content": "def PrintedTask(task):\n    st = task[\"term\"] + task[\"punctuation\"]\n    st += (\" :|: occurrenceTime=\"+task[\"occurrenceTime\"] if task[\"occurrenceTime\"].isdigit() else \"\")\n    if \"Priority\" in task: st += \" Priority=\" + str(task[\"Priority\"])\n    if \"truth\" in task: st += \" Truth: frequency=\"+task[\"truth\"][\"frequency\"] + \" confidence=\"+task[\"truth\"][\"confidence\"]\n    return st\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/produceSentenceNarsese",
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py"
      ],
      "reference_who": []
    },
    "Shell": {
      "type": "FunctionDef",
      "name": "Shell",
      "md_content": [
        "**Shell**: The function of Shell is to create a shell-like interface that continuously prompts the user for input, sends the input to the NAR (Non-Axiomatic Reasoning) system for processing, and calls the AddInput function to handle the input.\n\n**parameters**:\n- None\n\n**Code Description**:\nThe Shell function creates an infinite loop using the while True statement. Within the loop, it prompts the user for input using the input() function and stores the input in the variable 'inp'. The rstrip(\"\\n\") method is used to remove any trailing newline characters from the input.\n\nThe function then attempts to execute the following code block using the try-except statement. If an exception occurs, the exit(0) function is called to terminate the program.\n\nInside the try block, the function calls the AddInput function and passes the user input as an argument. This function is responsible for sending the Narsese input to the NAR system for processing.\n\n**Note**:\n- The Shell function assumes that the NAR system is already running and accessible.\n- The function relies on the AddInput function to handle the user input and communicate with the NAR system.\n- The function creates an infinite loop, so it will continue prompting the user for input until the program is terminated externally.\n\n**Relationship with other objects**:\n- The Shell function calls the AddInput function to handle the user input and communicate with the NAR system. The AddInput function is defined in the NAR.py module.\n\n**Note**:\n- The AddInput function is responsible for sending the Narsese input to the NAR system and processing the output.\n- The Shell function creates a shell-like interface that continuously prompts the user for input and calls the AddInput function to handle the input."
      ],
      "code_start_line": 121,
      "code_end_line": 127,
      "parent": null,
      "params": [],
      "have_return": false,
      "code_content": "def Shell():\n    while True:\n        try:\n            inp = input().rstrip(\"\\n\")\n        except:\n            exit(0)\n        AddInput(inp)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR.py/AddInput"
      ]
    }
  },
  "OpenNARS-for-Applications\\misc\\Python\\NAR_json.py": {},
  "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py": {
    "Truth_w2c": {
      "type": "FunctionDef",
      "name": "Truth_w2c",
      "md_content": [
        "**Truth_w2c**: The function of Truth_w2c is to calculate the truth value of a concept given its confidence value.\n\n**parameters**:\n- w: A float value representing the confidence value of a concept.\n\n**Code Description**:\nThe `Truth_w2c` function takes a confidence value `w` as input and calculates the truth value of a concept using the formula `w / (w + 1.0)`. It returns the calculated truth value.\n\nThis function is called by the `Truth_Revision` function in the `NAR_language.py` module. In the `Truth_Revision` function, the `Truth_w2c` function is used to calculate the maximum of the truth value of the concept and the confidence values of two concepts, `c1` and `c2`. The calculated truth value is then used in further calculations.\n\n**Note**:\n- The input `w` should be a float value.\n- The output of this function is a float value representing the truth value of a concept.\n\n**Output Example**:\nIf the input `w` is 0.5, the function will return 0.3333333333333333."
      ],
      "code_start_line": 32,
      "code_end_line": 33,
      "parent": null,
      "params": [
        "w"
      ],
      "have_return": true,
      "code_content": "def Truth_w2c(w):\n    return w / (w + 1.0)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/Truth_Revision"
      ],
      "reference_who": []
    },
    "Truth_c2w": {
      "type": "FunctionDef",
      "name": "Truth_c2w",
      "md_content": [
        "**Truth_c2w**: The function of Truth_c2w is to calculate the complementary value of a given confidence value.\n\n**parameters**:\n- c: A float value representing the confidence value. It should be between 0 and 1, where 0 indicates complete uncertainty and 1 indicates complete certainty.\n\n**Code Description**:\nThe `Truth_c2w` function takes a confidence value `c` as input and calculates its complementary value using the formula `c / (1.0 - c)`. The complementary value represents the degree of uncertainty associated with the confidence value.\n\nThis function is called by the `Truth_Revision` function in the `NAR_language.py` file. In the `Truth_Revision` function, the `Truth_c2w` function is used to calculate the complementary values of two confidence values `c1` and `c2` before performing further calculations.\n\n**Note**:\n- The input confidence value `c` should be a float between 0 and 1. Values outside this range may result in unexpected behavior.\n- The function assumes that the input confidence value is valid and does not perform any error checking or validation.\n\n**Output Example**:\nIf the input confidence value `c` is 0.8, the function will return the complementary value `4.0` (i.e., `0.8 / (1.0 - 0.8)`)."
      ],
      "code_start_line": 35,
      "code_end_line": 36,
      "parent": null,
      "params": [
        "c"
      ],
      "have_return": true,
      "code_content": "def Truth_c2w(c):\n    return c / (1.0 - c)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/Truth_Revision"
      ],
      "reference_who": []
    },
    "Truth_Expectation": {
      "type": "FunctionDef",
      "name": "Truth_Expectation",
      "md_content": [
        "**Truth_Expectation**: The function of Truth_Expectation is to calculate the truth expectation value based on a given input.\n\n**parameters**:\n- v: A list containing two elements. The first element represents the frequency of an event, and the second element represents the confidence level of the event.\n\n**Code Description**:\nThe Truth_Expectation function takes a list as input and calculates the truth expectation value using the formula: (v[1] * (v[0] - 0.5) + 0.5). It multiplies the confidence level (v[1]) by the difference between the frequency (v[0]) and 0.5, and then adds 0.5 to the result.\n\nThis function is used in the OpenNARS-for-Applications project within the NAR_language.py file. It is called by multiple objects within the project, including the Query, resolveViaChoice, getNounRelNoun, and produceSentenceNarsese functions.\n\nIn the Query function, the Truth_Expectation function is used to compare the truth expectation values of different terms and select the term with the highest value. It is also used to determine whether a word refers to a relational concept or not, based on its truth expectation value.\n\nIn the resolveViaChoice function, the Truth_Expectation function is used to compare the truth expectation values of different terms and decide whether to resolve a word via choice or not.\n\nIn the getNounRelNoun function, the Truth_Expectation function is used to evaluate the truth expectation values of different queries and determine the most suitable relation.\n\nIn the produceSentenceNarsese function, the Truth_Expectation function is used to check the truth expectation value of a flipped relation and determine the order of the subject and object in the sentence.\n\n**Note**: The Truth_Expectation function is a crucial component in the OpenNARS-for-Applications project, as it plays a significant role in evaluating the truth expectation values of different terms and making decisions based on these values.\n\n**Output Example**: \nIf the input to the Truth_Expectation function is [0.6, 0.8], the function will return the truth expectation value calculated as (0.8 * (0.6 - 0.5) + 0.5) = 0.68."
      ],
      "code_start_line": 38,
      "code_end_line": 39,
      "parent": null,
      "params": [
        "v"
      ],
      "have_return": true,
      "code_content": "def Truth_Expectation(v):\n    return (v[1] * (v[0] - 0.5) + 0.5)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/Query",
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/resolveViaChoice",
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/getNounRelNoun",
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/produceSentenceNarsese"
      ],
      "reference_who": []
    },
    "Truth_Negation": {
      "type": "FunctionDef",
      "name": "Truth_Negation",
      "md_content": [
        "**Truth_Negation**: The function of Truth_Negation is to negate the truth value of a given proposition.\n\n**parameters**:\n- v: A tuple representing the truth value of a proposition. The tuple should have two elements, where the first element represents the frequency of the proposition being true, and the second element represents the confidence in the truth value.\n\n**Code Description**:\nThe Truth_Negation function takes a tuple representing the truth value of a proposition as input. It negates the truth value by subtracting the first element of the tuple from 1 and returns a new tuple with the negated truth value.\n\nThe function first extracts the first element of the input tuple, which represents the frequency of the proposition being true. It then subtracts this value from 1 to obtain the negated frequency. The second element of the input tuple, representing the confidence in the truth value, remains unchanged in the output tuple.\n\nThe function returns the negated truth value as a tuple, where the first element represents the negated frequency and the second element represents the confidence in the negated truth value.\n\nThis function is called by the Query function in the NAR_language.py module. In the Query function, the Truth_Negation function is used to negate the truth value of a relational concept if specified by the isRelation parameter. The negated truth value is then used to determine whether to continue processing the query or not.\n\n**Note**:\n- The input tuple should have two elements representing the truth value of a proposition.\n- The function assumes that the input tuple is in the correct format, otherwise, it may raise an error.\n- The function only negates the frequency of the truth value and leaves the confidence unchanged.\n\n**Output Example**:\nIf the input tuple is (0.8, 0.6), the function will return the tuple (0.2, 0.6), representing the negated truth value of the proposition."
      ],
      "code_start_line": 41,
      "code_end_line": 42,
      "parent": null,
      "params": [
        "v"
      ],
      "have_return": true,
      "code_content": "def Truth_Negation(v):\n    return (1-v[0], v[1])\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/Query"
      ],
      "reference_who": []
    },
    "Truth_Revision": {
      "type": "FunctionDef",
      "name": "Truth_Revision",
      "md_content": [
        "**Truth_Revision**: The function of Truth_Revision is to perform truth revision on two input values, v1 and v2, and return the revised truth value and confidence value.\n\n**parameters**:\n- v1: A tuple representing the first input value, containing a float value f1 representing the truth value and a float value c1 representing the confidence value.\n- v2: A tuple representing the second input value, containing a float value f2 representing the truth value and a float value c2 representing the confidence value.\n\n**Code Description**:\nThe `Truth_Revision` function takes two input values, v1 and v2, and performs truth revision on them. It first extracts the truth value and confidence value from each input value. Then, it calculates the complementary values, w1 and w2, using the `Truth_c2w` function. The complementary values represent the degree of uncertainty associated with the confidence values.\n\nNext, the function calculates the sum of the complementary values, w, by adding w1 and w2. This sum is used to determine the revised truth value and confidence value. The revised truth value is calculated using the formula `(w1 * f1 + w2 * f2) / w`, where f1 and f2 are the original truth values. The revised confidence value is calculated using the formula `min(0.99, max(max(Truth_w2c(w), c1), c2))`, where Truth_w2c is a function that calculates the truth value of a concept given its confidence value.\n\nThe function returns a tuple containing the revised truth value and confidence value.\n\n**Note**:\n- The input values v1 and v2 should be tuples containing two float values each.\n- The function assumes that the input values are valid and does not perform any error checking or validation.\n- The output truth value is limited to a maximum of 1.0 and the output confidence value is limited to a maximum of 0.99.\n\n**Output Example**:\nIf v1 is (0.8, 0.9) and v2 is (0.6, 0.7), the function will return the revised values (0.6666666666666666, 0.9)."
      ],
      "code_start_line": 44,
      "code_end_line": 51,
      "parent": null,
      "params": [
        "v1",
        "v2"
      ],
      "have_return": true,
      "code_content": "def Truth_Revision(v1, v2):\n    (f1, c1) = v1\n    (f2, c2) = v2\n    w1 = Truth_c2w(c1)\n    w2 = Truth_c2w(c2)\n    w = w1 + w2\n    return (min(1.0, (w1 * f1 + w2 * f2) / w), \n            min(0.99, max(max(Truth_w2c(w), c1), c2)))\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/AddBelief"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/Truth_w2c",
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/Truth_c2w"
      ]
    },
    "AddBelief": {
      "type": "FunctionDef",
      "name": "AddBelief",
      "md_content": [
        "**AddBelief**: The function of AddBelief is to add a belief to the memory.\n\n**parameters**:\n- belief: The belief to be added to the memory.\n- Truth: Optional parameter representing the truth value and confidence value of the belief. It is a tuple containing two float values. The first value represents the truth value and the second value represents the confidence value. The default value is (1.0, 0.9).\n\n**Code Description**:\nThe `AddBelief` function is responsible for adding a belief to the memory. It first checks if the belief already exists in the memory. If it does, the function calls the `Truth_Revision` function to perform truth revision on the existing belief and the new belief. The `Truth_Revision` function calculates the revised truth value and confidence value based on the input values. The revised belief is then stored in the memory.\n\nIf the belief does not exist in the memory, the function simply adds the belief to the memory with the provided truth value and confidence value.\n\n**Note**:\n- The `memory` variable is assumed to be a global variable that represents the memory storage.\n- The `Truth_Revision` function is used to perform truth revision on the beliefs. It is assumed to be defined elsewhere in the code.\n- The default truth value and confidence value for a belief are (1.0, 0.9).\n- The function assumes that the input belief is valid and does not perform any error checking or validation.\n\nNow, let's take a look at how the `AddBelief` function is called in the project:\n\nThe `AddBelief` function is called in the following objects:\n- `getNounRelNoun`: This function is responsible for extracting noun-relation-noun patterns from a list of words. It calls the `AddBelief` function to add beliefs related to the words being processed.\n- `newConcept`: This function is responsible for creating new concepts based on a given term. It calls the `AddBelief` function to add beliefs related to the new concept.\n- `correlate`: This function is responsible for cross-correlating the subject, relation, and object with a list of words. It calls the `AddBelief` function to add beliefs based on the cross-correlation results.\n\n**Note**:\n- The `AddBelief` function is used in different contexts within the project, depending on the specific requirements of each object.\n- The specific usage and behavior of the `AddBelief` function may vary depending on the calling object and the input parameters provided."
      ],
      "code_start_line": 56,
      "code_end_line": 61,
      "parent": null,
      "params": [
        "belief",
        "Truth"
      ],
      "have_return": false,
      "code_content": "def AddBelief(belief, Truth=(1.0, 0.9)):\n    global memory\n    if belief in memory:\n        memory[belief] = Truth_Revision(memory[belief], Truth)\n    else:\n        memory[belief] = Truth\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/getNounRelNoun",
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/newConcept",
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/correlate"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/Truth_Revision"
      ]
    },
    "Query": {
      "type": "FunctionDef",
      "name": "Query",
      "md_content": [
        "**Query**: The function of Query is to perform a query matching operation on a given term.\n\n**parameters**:\n- term: A string representing the term to be queried.\n- isRelation: An optional boolean parameter indicating whether the word refers to a relational concept or not. Default value is None.\n\n**Code Description**:\nThe Query function is used to perform a query matching operation on a given term. It first checks if the term contains the special character \"?1\". If it does, the function splits the term into two parts using \"?1\" as the delimiter. It then proceeds to find the best matching term in the memory based on the given parts. The best matching term is determined by comparing the truth expectation values of different terms.\n\nThe function initializes variables such as bestTerm, bestTruth, and bestAssignment to keep track of the best matching term and its associated truth value. It then iterates through the memory to find terms that start with the first part of the input term and end with the second part. For each matching term, the function calculates the assignment by removing the first and last parts from the term. If the isRelation parameter is specified, the function checks whether the word refers to a relational concept or not based on the truth expectation value of the assignment. If the isRelation parameter is False and the truth expectation value is less than or equal to 0.5, the function skips the current iteration. Otherwise, it calculates the truth expectation value of the current term using the truth_expectation function and compares it with the truth expectation value of the best matching term. If the current term has a higher truth expectation value, it updates the bestTerm, bestTruth, and bestAssignment variables.\n\nAfter iterating through all the terms in the memory, the function checks if a best matching term has been found. If it has, it returns the bestTerm, bestTruth, and bestAssignment as the result. If no best matching term is found, the function checks if the input term itself exists in the memory. If it does, it returns the term and its associated truth value. Otherwise, it returns the input term, a default truth value of (0.5, 0.0), and an empty list as the result.\n\n**Note**: The Query function is an important component in the OpenNARS-for-Applications project, as it is used to perform query matching operations and retrieve relevant information from the memory. It utilizes the Truth_Expectation function to calculate the truth expectation values and the Truth_Negation function to negate the truth values of relational concepts if specified by the isRelation parameter.\n\n**Output Example**:\nIf the input term is \"apple?1fruit\" and there is a matching term in the memory \"redapplefruit\" with a truth value of (0.8, 0.6), the function will return the following result:\n- bestTerm: \"redapplefruit\"\n- bestTruth: (0.8, 0.6)\n- bestAssignment: [(\"apple?1\", \"red\")]\n\nPlease note that this is just a mock-up example and the actual output may vary depending on the content of the memory."
      ],
      "code_start_line": 63,
      "code_end_line": 89,
      "parent": null,
      "params": [
        "term",
        "isRelation"
      ],
      "have_return": true,
      "code_content": "def Query(term, isRelation=None):\n    if \"?1\" in term: #simple query matching\n            parts = term.split(\"?1\")\n            truth_expectation = lambda f,c: (c * (f - 0.5) + 0.5)\n            bestTerm, bestTruth = (None, (0.0, 0.5))\n            bestAssignment = \"\"\n            for term2 in memory:\n                if term2.startswith(parts[0]) and term2.endswith(parts[1]):\n                    assignment = term2[len(parts[0]):-len(parts[1])]\n                    if isRelation is not None:\n                        #whether the word refers to a relational concept or not and if we want it so\n                        _, truthRel, _ = Query(f\"<{assignment} --> RELATION>\")\n                        if not isRelation:\n                            truthRel = Truth_Negation(truthRel)\n                        if Truth_Expectation(truthRel) <= 0.5:\n                            continue\n                    (f2, c2) = memory[term2]\n                    if truth_expectation(f2, c2) > truth_expectation(bestTruth[0], bestTruth[1]):\n                        bestAssignment = (\"?1\", assignment)\n                        bestTerm = term2\n                        bestTruth = (f2, c2)\n            if bestTerm is not None:\n                return bestTerm, bestTruth, [bestAssignment]\n    else:\n        if term in memory:\n            return term, memory[term], []\n    return term, (0.5, 0.0), []\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/resolveViaChoice",
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/getNounRelNoun",
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/produceSentenceNarsese",
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language_test.py/Test1",
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language_test.py/Test2"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/Truth_Expectation",
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/Truth_Negation"
      ]
    },
    "resolveViaChoice": {
      "type": "FunctionDef",
      "name": "resolveViaChoice",
      "md_content": [
        "**resolveViaChoice**: The function of resolveViaChoice is to resolve a word via choice based on its truth expectation value and other parameters.\n\n**parameters**:\n- word: A string representing the word to be resolved.\n- i: An integer representing the index of the word in a list.\n- ITEM: A tuple containing information about the best matching term found so far. It consists of four elements: the term itself, the index of the term, the truth value of the term, and the word associated with the term.\n- isRelation: A boolean value indicating whether the word refers to a relational concept or not.\n\n**Code Description**:\nThe resolveViaChoice function is used to resolve a word via choice based on its truth expectation value and other parameters. It first calls the Query function to find the best matching term for the given word. The Query function returns a tuple containing the term, its truth value, and an assignment if applicable. The resolveViaChoice function then compares the truth expectation value of the best matching term with the truth expectation value of the ITEM tuple. If the truth expectation value of the best matching term is greater than or equal to the truth expectation value of the ITEM tuple, the function returns a new tuple consisting of the assignment, the index of the word, the truth value of the best matching term, and the word itself. Otherwise, it returns the ITEM tuple as it is.\n\n**Note**: The resolveViaChoice function is an important part of the OpenNARS-for-Applications project, as it is used to make decisions on resolving words based on their truth expectation values. It utilizes the Query function to find the best matching term for a given word and compares the truth expectation values to determine whether to resolve the word via choice or not.\n\n**Output Example**:\nIf the word is \"apple\", the index is 0, the ITEM tuple is (\"redapplefruit\", 0, (0.8, 0.6), \"apple\"), and the isRelation parameter is True, the function will compare the truth expectation value of the best matching term with the truth expectation value of the ITEM tuple. If the truth expectation value of the best matching term is greater than or equal to (0.8 * (0.6 - 0.5) + 0.5), the function will return a new tuple as the result:\n- (\"redapplefruit\", 0, (0.8, 0.6), \"apple\")\n\nPlease note that this is just a mock-up example and the actual output may vary depending on the input and the content of the memory."
      ],
      "code_start_line": 92,
      "code_end_line": 97,
      "parent": null,
      "params": [
        "word",
        "i",
        "ITEM",
        "isRelation"
      ],
      "have_return": true,
      "code_content": "def resolveViaChoice(word, i, ITEM, isRelation):\n    term, truth, unifier = Query(f\"<({word} * ?1) --> R>\", isRelation)\n    if unifier:\n        if Truth_Expectation(truth) >= Truth_Expectation(ITEM[2]):\n            return (unifier[0][1], i, truth, word)\n    return ITEM\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/getNounRelNoun"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/Truth_Expectation",
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/Query"
      ]
    },
    "getNounRelNoun": {
      "type": "FunctionDef",
      "name": "getNounRelNoun",
      "md_content": [
        "**getNounRelNoun**: The function of getNounRelNoun is to extract noun-relation-noun patterns from a list of words and determine the most suitable relation based on the truth expectation values of different queries.\n\n**parameters**:\n- words: A list of words from which the noun-relation-noun patterns are extracted.\n\n**Code Description**:\nThe getNounRelNoun function takes a list of words as input and performs the following steps:\n\n1. Initialize variables: The function initializes several variables, including EMPTY, RELATION, RELATIONS, and REL_FOUND, which are used to store information about the best matching relation and related concepts found during the extraction process.\n\n2. Iterate through the words: The function iterates through each word in the input list and performs the following operations:\n\n   a. Query assignment: The function queries the truth expectation value of the word using the Query function. If the truth expectation value is below a certain threshold (0.1), the word is considered unassigned and skipped. Otherwise, the function proceeds to the next step.\n\n   b. Resolve relation: The function calls the resolveViaChoice function to resolve the word via choice and obtain a temporary relation. The resolveViaChoice function compares the truth expectation value of the temporary relation with the truth expectation value of the current best matching relation and updates the best matching relation if necessary.\n\n   c. Query concepts: The function queries the truth expectation values of the word as a relation and as a concept using the Query function. If the truth expectation value as a relation is higher than the truth expectation value as a concept, the function adds the relation to the RELATIONS list.\n\n   d. Update best matching relation: If a best matching relation has not been found yet, the function compares the truth expectation value of the relation obtained from the Query function with the truth expectation value of the temporary relation obtained from the resolveViaChoice function. If the truth expectation value of the relation is higher, it becomes the new best matching relation.\n\n3. Update RELATIONS list: If the best matching relation is not already in the RELATIONS list, it is added to the beginning of the list.\n\n4. Check for empty relation: If the best matching relation is None, indicating that no suitable relation was found, the function returns a list containing a single tuple with None values for the relation, concept, and modifier.\n\n5. Extract concepts and modifiers: The function iterates through the words again and extracts concepts and modifiers based on the RELATIONS list. Concepts are added to the Cs list, and modifiers are added to the Ms list. The function also keeps track of the next modifier and next modifier modifier using the nextmod and nextmodmod variables.\n\n6. Handle single concept and modifier: If there is only one concept and one modifier, the function checks the order of the concept and modifier and adjusts it if necessary.\n\n7. Add beliefs: If the ASSIGN variable is True, the function adds beliefs to the memory for each concept, modifier, and relation using the AddBelief function.\n\n8. Check for assigned words: The function iterates through the words again and checks if each word has been assigned as a concept, modifier, or relation. If a word has not been assigned, it is added to the memory as an assigned belief using the AddBelief function.\n\n9. Modify function: The function defines a modify function that combines two terms based on their assignment. This function is used to generate the SROs (Subject-Relation-Object) tuples.\n\n10. Check for minimum number of concepts: If the ASSIGN variable is False or there are fewer than two concepts, the function returns a list containing a single tuple with None values for the relation, concept, and modifier.\n\n11. Generate SROs: The function generates the SROs tuples by combining the concepts and modifiers based on the RELATIONS list.\n\n12. Return SROs: The function returns the SROs tuples as the result.\n\n**Note**: The getNounRelNoun function is a crucial part of the OpenNARS-for-Applications project, as it is responsible for extracting noun-relation-noun patterns and determining the most suitable relation based on the truth expectation values. It utilizes the Query, resolveViaChoice, and AddBelief functions to perform queries, resolve words via choice, and add beliefs to the memory.\n\n**Output Example**: \nIf the input list of words is [\"red\", \"apple\", \"fruit\"], and the best matching relation is \"IS\" with a truth expectation value of (0.8, 0.6), the function will return the following result:\n- [(\"red\", \"IS\", \"apple\"), (\"red\", \"IS\", \"fruit\")]\n\nPlease note that this is just a mock-up example and the actual output may vary depending on the content of the memory and the input words."
      ],
      "code_start_line": 99,
      "code_end_line": 191,
      "parent": null,
      "params": [
        "words"
      ],
      "have_return": true,
      "code_content": "def getNounRelNoun(words):\n    EMPTY = (None, -1, (0.5,0.0), \"\")\n    RELATION = (None, -1, (0.5,0.0), \"\")\n    RELATIONS = []\n    REL_FOUND = False\n    for i, word in enumerate(words):\n        _, truthAssigned, _ = Query(f\"<{word} --> [ASSIGNED]>\")\n        if Truth_Expectation(truthAssigned) < 0.1:\n            #whether this word was used to refer to a concept, else we don't consider it\n            print(\"//Unassigned1:\", word, Truth_Expectation(truthAssigned))\n            continue\n        RELATION_TEMP = resolveViaChoice(word, i, RELATION, isRelation=True)\n        quRelation = Query(f\"<({word} * ?1) --> R>\", isRelation=True)\n        quConcept = Query(f\"<({word} * ?1) --> R>\", isRelation=False)\n        if Truth_Expectation(quRelation[1]) > Truth_Expectation(quConcept[1]):\n            RELATIONS.append((quRelation[2][0][1], i, quRelation[1], word))\n        if not REL_FOUND:\n            if Truth_Expectation(quRelation[1]) > Truth_Expectation(quConcept[1]):\n                RELATION = (quRelation[2][0][1], i, quRelation[1], word)\n                REL_FOUND = True\n            else:\n                RELATION = RELATION_TEMP\n    if RELATION not in RELATIONS:\n        RELATIONS = [RELATION] + RELATIONS\n    if RELATION[0] is None:\n        return [(None, None, None)]\n    VALUES = []\n    for j, word in enumerate(words):\n        Continue = False\n        for R in RELATIONS:\n            if j == R[1]:\n                Continue = True\n        if Continue:\n            continue\n        _, truthAssigned, _ = Query(f\"<{word} --> [ASSIGNED]>\")\n        if Truth_Expectation(truthAssigned) < 0.1:\n            #whether this word was used to refer to a concept, else we don't consider it\n            print(\"//Unassigned2:\", word, Truth_Expectation(truthAssigned))\n            continue\n        VALUE = resolveViaChoice(word, j, (None, -1, (0.5,0.0), \"\"), isRelation=False)\n        if VALUE[0] is not None:\n            VALUES.append(VALUE)\n    Cs = [] #concepts\n    Ms = [] #modifiers (same len)\n    nextmod = EMPTY\n    nextmodmod = EMPTY\n    ASSIGN = True\n    for i,x in enumerate(VALUES + [None]):\n        if x is None:\n            if nextmod != EMPTY:\n                Cs.append(nextmod)\n                Ms.append(nextmodmod)\n        elif x[0][0] == '[' or (i+1 < len(VALUES) and VALUES[i+1][1] - x[1] == 1 and x[3] + \" \" + VALUES[i+1][3] in sentence):\n            if nextmod != EMPTY and x[0][0] == '[':\n                nextmodmod = nextmod\n                nextmod = x\n            else:\n                nextmod = x\n        else:\n            Cs.append(x)\n            Ms.append(nextmod)\n            nextmod = EMPTY\n            nextmodmod = EMPTY\n    if len(Cs) == 1 and len([x for x in Ms if x != EMPTY]) == 1: #just one concept and 1 modifier, so the concept being modified is the sentence\n        if Ms[0][1] < Cs[0][1]:\n            Cs = [Ms[0], Cs[0]]\n        else:\n            Cs = [Cs[0], Ms[0]]\n        Ms = [EMPTY for i in range(2)]\n    if ASSIGN:\n        for x in Cs + Ms + [RELATION]:\n            if x != EMPTY:\n                AddBelief(f\"<{x[3]} --> [ASSIGNED]>\")\n    for x in words:\n        Break = False\n        for y in Cs + Ms + [RELATION]:\n            if x == y[3] and ASSIGN:\n                Break = True\n                break\n        if Break:\n            break\n        AddBelief(f\"<{x} --> [ASSIGNED]>\", (0.0, 0.9))\n    modify = lambda a,b: a[0] if b[0] is None else (f\"({b[0]} & {a[0]})\" if b[0][0] == '[' else f\"({b[0]} * {a[0]})\")\n    if not ASSIGN or len(Cs) < 2:\n        return [(None, None, None)]\n    SROs = []\n    print(\"//R,C,M: \", RELATIONS, Cs, Ms)\n    for i in range(0, len(Cs)-1, 2):\n        if int(i/2) >= len(RELATIONS):\n            break\n        S, R, O = (modify(Cs[i], Ms[i]), RELATIONS[int(i/2)][0], modify(Cs[i+1], Ms[i+1]))\n        SROs.append((S, R, O))\n    return SROs\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/produceSentenceNarsese",
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/correlate"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/Truth_Expectation",
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/AddBelief",
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/Query",
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/resolveViaChoice"
      ]
    },
    "produceSentenceNarsese": {
      "type": "FunctionDef",
      "name": "produceSentenceNarsese",
      "md_content": [
        "**produceSentenceNarsese**: The function of produceSentenceNarsese is to generate a Narsese sentence based on a given list of words. The function analyzes the words and constructs a Narsese sentence by applying certain rules and conditions.\n\n**parameters**:\n- words: A list of words representing the input sentence.\n\n**Code Description**:\nThe produceSentenceNarsese function takes a list of words as input and performs the following steps to generate a Narsese sentence:\n\n1. Get Noun-Relation-Noun Patterns: The function calls the getNounRelNoun function to extract noun-relation-noun patterns from the list of words. This function analyzes the words and determines the most suitable relation based on the truth expectation values of different queries.\n\n2. Iterate through SROs: The function iterates through each Subject-Relation-Object (SRO) tuple obtained from the getNounRelNoun function. For each SRO tuple, the function performs the following operations:\n\n   a. Check for None values: The function checks if any of the SRO tuple values are None. If any value is None, the function skips the current iteration.\n\n   b. Handle IS Relation: If the relation in the SRO tuple is \"IS\", the function constructs a Narsese sentence using the subject and object values. The sentence is constructed in the format \"<subject --> object>.\".\n\n   c. Handle LIKE Relation: If the relation in the SRO tuple is \"LIKE\", the function constructs a Narsese sentence using the subject and object values. The sentence is constructed in the format \"<subject <-> object>.\".\n\n   d. Handle Other Relations: If the relation in the SRO tuple is neither \"IS\" nor \"LIKE\", the function constructs a Narsese sentence using the subject, object, and relation values. The sentence is constructed in the format \"<(subject * object) --> relation>.\".\n\n3. Print Narsese Sentence: The function prints the generated Narsese sentence using the print() function.\n\n**Note**: The produceSentenceNarsese function is a key component in the OpenNARS-for-Applications project, as it is responsible for generating Narsese sentences based on input words. It utilizes the getNounRelNoun function to extract noun-relation-noun patterns and constructs Narsese sentences based on the extracted patterns.\n\n**Output Example**:\nIf the input list of words is [\"red\", \"apple\", \"fruit\"], the function will generate the following Narsese sentence:\n```\nInput: <(red * apple) --> fruit>.\n```\nPlease note that this is just a mock-up example and the actual output may vary depending on the content of the input words and the extracted patterns."
      ],
      "code_start_line": 193,
      "code_end_line": 207,
      "parent": null,
      "params": [
        "words"
      ],
      "have_return": true,
      "code_content": "def produceSentenceNarsese(words):\n    SROs = getNounRelNoun(words)\n    for (S,R,O) in SROs:\n        if S is None or R is None or O is None:\n            return\n        if Truth_Expectation(Query(f\"<{R} --> [FLIPPED]>\")[1]) > 0.5:\n            temp = O\n            O = S\n            S = temp\n        if R == \"IS\":\n            print(\"Input:\", NAR.PrintedTask(NAR.AddInput(f\"<{S} --> {O}>. :|:\", Print=False)[\"input\"][0]))\n        elif R == \"LIKE\":\n            print(\"Input:\", NAR.PrintedTask(NAR.AddInput(f\"<{S} <-> {O}>. :|:\", Print=False)[\"input\"][0]))\n        else:\n            print(\"Input:\", NAR.PrintedTask(NAR.AddInput(f\"<({S} * {O}) --> {R}>. :|:\", Print=False)[\"input\"][0]))\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/newSentence"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR.py/AddInput",
        "OpenNARS-for-Applications\\misc\\Python\\NAR.py/PrintedTask",
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/Truth_Expectation",
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/Query",
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/getNounRelNoun"
      ]
    },
    "sub_lists": {
      "type": "FunctionDef",
      "name": "sub_lists",
      "md_content": [
        "**sub_lists**: The function of sub_lists is to generate all possible sublists of a given list.\n\n**parameters**:\n- l: A list for which sublists need to be generated.\n\n**Code Description**:\nThe sub_lists function takes a list as input and generates all possible sublists of that list. It does this by iterating over the indices of the list and creating sublists starting from each index up to the end of the list. Each generated sublist is then appended to a new list called \"lists\". \n\nThe function uses two nested for loops to iterate over the indices. The outer loop iterates from 0 to the length of the list plus 1, while the inner loop iterates from 0 to the current index of the outer loop. This ensures that all possible sublists are generated.\n\nInside the inner loop, a sublist is created using list slicing. The sublist is created by taking a slice of the original list starting from the inner loop index and ending at the outer loop index. This creates a sublist that spans from the inner loop index to the current outer loop index.\n\nEach generated sublist is then appended to the \"lists\" list along with additional information. The additional information includes the length of the sublist, the sublist itself, and the current outer loop index. This information is appended as a tuple to the \"lists\" list.\n\nAfter all sublists have been generated, the \"lists\" list is sorted based on the length of the sublists. This is done using the \"sort\" method and a lambda function as the key. The lambda function extracts the length of the sublist from each tuple in the \"lists\" list and uses it as the sorting key.\n\nFinally, the sorted \"lists\" list is returned as the output of the function.\n\n**Note**: \n- The input list can be of any length, including an empty list.\n- The function does not modify the original list, it only generates sublists.\n- The sublists are sorted based on their length in ascending order.\n\n**Output Example**:\nIf the input list is [1, 2, 3], the function will return the following list of sublists:\n[(0, [], 0), (1, [1], 1), (1, [2], 1), (2, [1, 2], 2), (1, [3], 1), (2, [1, 3], 2), (2, [2, 3], 2), (3, [1, 2, 3], 3)]"
      ],
      "code_start_line": 209,
      "code_end_line": 216,
      "parent": null,
      "params": [
        "l"
      ],
      "have_return": true,
      "code_content": "def sub_lists(l):\n    lists = []\n    for i in range(len(l) + 1):\n        for j in range(i):\n            subseq = l[j: i]\n            lists.append((i-len(subseq), subseq, i))\n    lists.sort(key=lambda x: x[0])\n    return lists\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/findSequences"
      ],
      "reference_who": []
    },
    "findSequences": {
      "type": "FunctionDef",
      "name": "findSequences",
      "md_content": [
        "**findSequences**: The function of findSequences is to find sequences of words within a given sentence that exist in a global memory and return them as a list.\n\n**parameters**:\n- st: A string representing the sentence in which sequences need to be found.\n\n**Code Description**:\nThe findSequences function takes a sentence as input and searches for sequences of words within that sentence. It does this by splitting the sentence into individual words and generating all possible sublists of these words using the sub_lists function.\n\nFirst, the function adds the input sentence to a global memory called \"sequenceMem\". This memory is used to store previously encountered sequences.\n\nNext, the function calls the sub_lists function to generate all possible sublists of the words in the sentence. Each sublist represents a potential sequence of words.\n\nThe function then iterates over the generated subsequences and checks if each subsequence exists in the sequenceMem. If a subsequence is found in the memory, it is added to a list called \"sequences\". Additionally, the function keeps track of the minimum start index of the subsequences that have been added to the \"sequences\" list.\n\nFinally, the function returns the list of sequences found in the sentence.\n\n**Note**:\n- The input sentence should be a string.\n- The function relies on the sub_lists function to generate all possible sublists of the words in the sentence.\n- The function uses a global memory called \"sequenceMem\" to store previously encountered sequences.\n- The function replaces spaces in the found sequences with underscores.\n\n**Output Example**:\nIf the input sentence is \"I love coding\", and the sequenceMem contains the sequence \"love coding\", the function will return the following list:\n[\"love_coding\"]"
      ],
      "code_start_line": 219,
      "code_end_line": 232,
      "parent": null,
      "params": [
        "st"
      ],
      "have_return": true,
      "code_content": "def findSequences(st):\n    global sequenceMem\n    sequenceMem.add(st)\n    subsequences = sub_lists(st.split(\" \"))\n    words = [\" \".join(x[1]) for x in subsequences]\n    startIndices = [x[0] for x in subsequences]\n    endIndices = [x[2] for x in subsequences]\n    sequences=[]\n    minStartIndex=0\n    for j,x in enumerate(words):\n        if x in sequenceMem and startIndices[j] >= minStartIndex:\n            sequences.append(x.replace(\" \",\"_\"))\n            minStartIndex = endIndices[j]\n    return sequences\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/newSentence"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/sub_lists"
      ]
    },
    "newSentence": {
      "type": "FunctionDef",
      "name": "newSentence",
      "md_content": [
        "**newSentence**: The function of newSentence is to process a given sentence and generate a Narsese sentence based on the input.\n\n**parameters**:\n- s: A string representing the input sentence.\n\n**Code Description**:\nThe newSentence function takes a sentence as input and performs the following steps to generate a Narsese sentence:\n\n1. Set the global variables: The function sets the global variables `sentence`, `words`, and `localist_tokens` to their initial values.\n\n2. Assign the input sentence: The function assigns the input sentence to the `sentence` variable.\n\n3. Check for localist tokens: The function checks if the input sentence contains a space character. If there is no space character, it sets the `localist_tokens` variable to True.\n\n4. Tokenize the sentence: If `localist_tokens` is True and the command line argument \"genericTokenization\" is not present, the function splits the sentence into individual words using the space character as the delimiter and assigns the result to the `words` variable. Otherwise, it calls the `findSequences` function to find sequences of words within the sentence and assigns the result to the `words` variable.\n\n5. Generate Narsese sentence: If the global variable `Training` is False, the function calls the `produceSentenceNarsese` function, passing the `words` variable as the input.\n\n**Note**: The newSentence function is a key component in the OpenNARS-for-Applications project. It is responsible for processing input sentences and generating Narsese sentences based on the input. The function first checks if the input sentence contains localist tokens and tokenizes the sentence accordingly. It then calls the `produceSentenceNarsese` function to generate the Narsese sentence.\n\nThe `produceSentenceNarsese` function, which is called by the `newSentence` function, is responsible for generating the Narsese sentence based on a given list of words. It analyzes the words and constructs a Narsese sentence by applying certain rules and conditions.\n\nThe `findSequences` function, which is also called by the `newSentence` function, is responsible for finding sequences of words within a given sentence that exist in a global memory. It returns these sequences as a list.\n\n**Output Example**:\nIf the input sentence is \"The cat is on the mat\" and the `localist_tokens` variable is True, the function will generate the following Narsese sentence:\n```\nInput: <The_cat --> is_on_the_mat>.\n```\nPlease note that this is just a mock-up example and the actual output may vary depending on the content of the input sentence and the value of the `localist_tokens` variable.\n\n**Note**: It is important to note that the `newSentence` function relies on the `produceSentenceNarsese` and `findSequences` functions to generate the Narsese sentence. The `produceSentenceNarsese` function analyzes the words and constructs the Narsese sentence based on certain rules and conditions. The `findSequences` function searches for sequences of words within the sentence and returns them as a list."
      ],
      "code_start_line": 236,
      "code_end_line": 246,
      "parent": null,
      "params": [
        "s"
      ],
      "have_return": false,
      "code_content": "def newSentence(s):\n    global sentence, words, localist_tokens\n    sentence = s\n    if \" \" not in sentence:\n        localist_tokens = True\n    if localist_tokens and not \"genericTokenization\" in sys.argv:\n        words = sentence.split(\" \")\n    else:\n        words = findSequences(sentence)\n    if not Training:\n        produceSentenceNarsese(words)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/processInput"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/produceSentenceNarsese",
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/findSequences"
      ]
    },
    "newConcept": {
      "type": "FunctionDef",
      "name": "newConcept",
      "md_content": [
        "**newConcept**: The function of newConcept is to create a new concept based on a given term.\n\n**parameters**:\n- term: A string representing the term from which the new concept will be created.\n\n**Code Description**:\nThe `newConcept` function is responsible for creating a new concept based on the provided term. It first checks if the term contains the \"->\" or \"<->\" copula and does not contain \"&&\" or \"==>\" in order to ensure that it is a valid term. If the term does not meet these conditions, the function simply returns without performing any further actions.\n\nIf the term contains the \"<->\" copula, it is assigned to the `copula` variable. Otherwise, the `copula` variable is set to \"->\". The subject and predicate of the term are extracted using string manipulation. The subject is obtained by splitting the term at the `copula` and removing the first character. The predicate is obtained by splitting the term at the `copula` and removing the last character.\n\nIf the subject contains \"*\", it means that the term represents a relation between two objects. In this case, the `RELATION`, `SUBJECT`, and `OBJECT` global variables are assigned accordingly. The `SUBJECT` is obtained by splitting the subject at \" * \" and removing the first character. The `RELATION` is set to the predicate. The `OBJECT` is obtained by splitting the subject at \" * \" and removing the last character.\n\nIf the subject does not contain \"*\", it means that the term represents a single object. In this case, the `SUBJECT` is assigned the value of the subject. The `RELATION` is set to \"IS\" if the `copula` is \"->\", otherwise it is set to \"LIKE\". The `OBJECT` is assigned the value of the predicate.\n\nThe `AddBelief` function is then called to add beliefs related to the new concept. The function adds beliefs in the form of \"<SUBJECT --> RELATION>\", \"<OBJECT --> RELATION>\", and \"<RELATION --> RELATION>\". The truth values and confidence values for the beliefs are not specified in the code.\n\nFinally, the function prints the SRO (Subject-Relation-Object) tuple.\n\n**Note**:\n- The `SUBJECT`, `RELATION`, `OBJECT`, and `Training` global variables are assumed to be defined elsewhere in the code.\n- The `AddBelief` function is assumed to be defined elsewhere in the code and is responsible for adding beliefs to the memory.\n- The specific behavior and usage of the `AddBelief` function may vary depending on the calling object and the input parameters provided.\n\n**Output Example**:\n//SRO: (SUBJECT, RELATION, OBJECT)"
      ],
      "code_start_line": 248,
      "code_end_line": 268,
      "parent": null,
      "params": [
        "term"
      ],
      "have_return": true,
      "code_content": "def newConcept(term):\n    global SUBJECT, RELATION, OBJECT, Training\n    if \"-->\" not in term and \"<->\" not in term or \"&&\" in term or \"==>\" in term:\n        return\n    copula = \"-->\"\n    if \"<->\" in term:\n        copula = \"<->\"\n    subject = term.split(f\" {copula}\")[0][1:]\n    predicate = term.split(f\"{copula} \")[1].replace(\" :|:\",\"\")[:-1]\n    if \"*\" in subject:\n        RELATION = predicate\n        SUBJECT = subject.split(\" * \")[0][1:]\n        OBJECT = subject.split(\" * \")[1][:-1]\n    else:\n        SUBJECT = subject\n        RELATION = \"IS\" if copula == \"-->\" else \"LIKE\"\n        OBJECT = predicate\n    AddBelief(\"<\" + SUBJECT + \" --> RELATION>\", (0.0, 0.9))\n    AddBelief(\"<\" + OBJECT + \" --> RELATION>\", (0.0, 0.9))\n    AddBelief(\"<\" + RELATION + \" --> RELATION>\")\n    print(\"//SRO:\", (SUBJECT, RELATION, OBJECT))\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/processInput"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/AddBelief"
      ]
    },
    "correlate": {
      "type": "FunctionDef",
      "name": "correlate",
      "md_content": [
        "**correlate**: The function of correlate is to cross-correlate the subject, relation, and object with a list of words and add corresponding beliefs to the memory.\n\n**parameters**:\n- None\n\n**Code Description**:\nThe `correlate` function performs the following steps:\n\n1. Print cross-correlation information: The function prints the subject, relation, object, and the list of words being cross-correlated.\n\n2. Add beliefs: The function iterates through each word in the list of words and each of the subject, relation, and object. For each word and each of the subject, relation, and object, the function calls the `AddBelief` function to add a belief of the form `(<word> * <subject/relation/object>) --> R>` to the memory.\n\n3. Get noun-relation-noun patterns: The function calls the `getNounRelNoun` function to extract noun-relation-noun patterns from the list of words.\n\n4. Check for grammatical relation flip: The function checks if the subject is equal to the object and the object is equal to the subject. If this condition is met, it prints a message indicating a grammatical relation flip and calls the `AddBelief` function to add a belief of the form `<relation> --> [FLIPPED]>` to the memory.\n\n5. Check for grammatical relation order: The function checks if the subject is equal to the subject and the object is equal to the object. If this condition is met, it prints a message indicating a grammatical relation order and calls the `AddBelief` function to add a belief of the form `<relation> --> [FLIPPED]>` to the memory.\n\n6. Reset variables: The function resets the subject, relation, object, and words variables to None.\n\n**Note**:\n- The `correlate` function is called in the `processInput` function to perform cross-correlation based on user input.\n- The specific usage and behavior of the `correlate` function may vary depending on the calling object and the input parameters provided.\n- The `AddBelief` and `getNounRelNoun` functions are used within the `correlate` function to add beliefs to the memory and extract noun-relation-noun patterns, respectively.\n- The `AddBelief` function is assumed to be defined elsewhere in the code and is responsible for adding beliefs to the memory.\n- The `getNounRelNoun` function is assumed to be defined elsewhere in the code and is responsible for extracting noun-relation-noun patterns from a list of words.\n\nNow, let's take a look at how the `correlate` function is called in the project:\n\nThe `correlate` function is called in the following objects:\n- `processInput`: This function is responsible for processing user input. It calls the `correlate` function to perform cross-correlation based on the user input.\n\n**Note**:\n- The `correlate` function is used in the `processInput` function to perform cross-correlation based on user input.\n- The specific usage and behavior of the `correlate` function may vary depending on the calling object and the input parameters provided."
      ],
      "code_start_line": 270,
      "code_end_line": 285,
      "parent": null,
      "params": [],
      "have_return": false,
      "code_content": "def correlate():\n    global SUBJECT, RELATION, OBJECT, words\n    print(\"//Cross-correlating: \", [SUBJECT, RELATION, OBJECT], \"with\", words)\n    for x in words:\n        for y in [SUBJECT, RELATION, OBJECT]:\n            AddBelief(f\"<({x} * {y}) --> R>\")\n    SROs = getNounRelNoun(words)\n    for (S,R,O) in SROs:\n        if S is not None and R is not None and O is not None:\n            if S == OBJECT and O == SUBJECT:\n                print(\"//Grammatical relation flip detected\", S, R, O, SUBJECT, RELATION, OBJECT)\n                AddBelief(f\"<{RELATION} --> [FLIPPED]>\", (1.0, 0.9))\n            if S == SUBJECT and O == OBJECT:\n                print(\"//Grammatical relation order detected\", S, R, O, SUBJECT, RELATION, OBJECT)\n                AddBelief(f\"<{RELATION} --> [FLIPPED]>\", (0.0, 0.9))\n    (SUBJECT, RELATION, OBJECT, words) = (None, None, None, None)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/processInput"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/AddBelief",
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/getNounRelNoun"
      ]
    },
    "processInput": {
      "type": "FunctionDef",
      "name": "processInput",
      "md_content": [
        "**processInput**: The function of processInput is to process the input and perform various actions based on the input type.\n\n**parameters**:\n- inp: A string representing the input to be processed.\n- Print: A boolean indicating whether to print the input.\n\n**Code Description**:\nThe processInput function takes an input string and performs the following steps:\n\n1. Print input: If the Print parameter is True, the function prints the input string.\n\n2. Check if input is a number: The function checks if the input string is a digit using the isdigit() method. If it is a number, the function checks if certain global variables (`words`, `SUBJECT`, `words`, and `SUBJECT`) are defined and not None. If these conditions are met, the function checks if the first element of the `words` list is not None. If it is not None, the function calls the `correlate` function.\n\n3. Check if input starts with \"<\" or \"(\": If the input string starts with \"<\" or \"(\", the function calls the `newConcept` function, passing the input string without the last character as the parameter.\n\n4. Process input as a sentence: If none of the above conditions are met, the function calls the `newSentence` function, passing the input string as the parameter. It then calls the `processInput` function recursively with the input string \"1\" and the Print parameter set to False.\n\n**Note**: The processInput function is a key component in the OpenNARS-for-Applications project. It is responsible for processing user input and performing various actions based on the input type. The function first checks if the input is a number and if certain global variables are defined. If the input is a number and the global variables are defined, the function calls the `correlate` function. If the input starts with \"<\" or \"(\", the function calls the `newConcept` function. Otherwise, the function treats the input as a sentence and calls the `newSentence` function.\n\nThe `newConcept` function is responsible for creating a new concept based on a given term. It extracts the subject, relation, and object from the term and adds beliefs to the memory based on these components. The `correlate` function performs cross-correlation between the subject, relation, and object with a list of words and adds corresponding beliefs to the memory.\n\nThe `newSentence` function processes a given sentence and generates a Narsese sentence based on the input. It tokenizes the sentence and calls the `produceSentenceNarsese` function to generate the Narsese sentence.\n\nThe `correlate` function is responsible for cross-correlating the subject, relation, and object with a list of words and adding corresponding beliefs to the memory.\n\nThe specific behavior and usage of the `newConcept`, `newSentence`, and `correlate` functions may vary depending on the calling object and the input parameters provided.\n\n**Output Example**:\nIf the input is \"The cat is on the mat\" and the Print parameter is True, the function will print the following:\n```\n//Input: The cat is on the mat\n```\nIf the input is \"123\" and the conditions for calling the `correlate` function are met, the function will call the `correlate` function.\n\nIf the input is \"<HUMAN --> [LEFT]>\" or \"(HUMAN --> [LEFT])\", the function will call the `newConcept` function with the parameter \"HUMAN --> [LEFT]\".\n\nIf the input is any other sentence, the function will call the `newSentence` function with the input as the parameter. It will then call the `processInput` function recursively with the input \"1\" and the Print parameter set to False."
      ],
      "code_start_line": 287,
      "code_end_line": 298,
      "parent": null,
      "params": [
        "inp",
        "Print"
      ],
      "have_return": true,
      "code_content": "def processInput(inp, Print=True):\n    if Print: print(\"//Input: \" + inp)\n    if inp.isdigit():\n        if \"words\" in globals() and \"SUBJECT\" in globals() and words is not None and SUBJECT is not None:\n            if words[0] is not None:\n                correlate()\n        return\n    if inp.startswith(\"<\") or inp.startswith(\"(\"):\n        newConcept(inp[:-1])\n    else:\n        newSentence(inp)\n        processInput(\"1\", Print=False)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language_test.py/Test1",
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language_test.py/Test2",
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language_test.py"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/newSentence",
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/newConcept",
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/correlate"
      ]
    },
    "TrainStart": {
      "type": "FunctionDef",
      "name": "TrainStart",
      "md_content": [
        "**TrainStart**: The function of TrainStart is to initiate the training process.\n\n**parameters**:\n- None\n\n**Code Description**:\nThe TrainStart function is responsible for starting the training process. It sets the global variable \"Training\" to True and prints a message indicating that the training has started.\n\nThe function begins by declaring the global variable \"Training\" using the \"global\" keyword. This allows the function to modify the value of the variable outside of its local scope.\n\nNext, the function prints the message \"//Training Start\" to indicate that the training process has begun.\n\nFinally, the function sets the value of the \"Training\" variable to True, indicating that the training is in progress.\n\nFrom a functional perspective, the TrainStart function is called by other objects in the project to initiate the training process. For example, it is called by the Test1 and Test2 functions in the NAR_language_test.py file. These functions execute a series of test cases and then call the TrainStart function to start the training process before performing the tests.\n\n**Note**:\n- The TrainStart function does not take any parameters.\n- It is important to call the TrainStart function before executing any training-related tasks to ensure that the training process is properly initialized."
      ],
      "code_start_line": 300,
      "code_end_line": 303,
      "parent": null,
      "params": [],
      "have_return": false,
      "code_content": "def TrainStart():\n    global Training\n    print(\"//Training Start\")\n    Training = True\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language_test.py/Test1",
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language_test.py/Test2"
      ],
      "reference_who": []
    },
    "TrainEnd": {
      "type": "FunctionDef",
      "name": "TrainEnd",
      "md_content": [
        "**TrainEnd**: The function of TrainEnd is to mark the end of the training process.\n\n**parameters**:\n- None\n\n**Code Description**:\nThe TrainEnd function is a simple function that marks the end of the training process. It sets the global variable \"Training\" to False and prints a message indicating that the training has ended.\n\nThe code first declares the global variable \"Training\" using the \"global\" keyword. This allows the function to access and modify the global variable.\n\nNext, the function prints the message \"//Training End\" using the print() function. This message serves as a notification that the training process has ended.\n\nFinally, the function sets the value of the global variable \"Training\" to False, indicating that the training process is no longer active.\n\nFrom a functional perspective, the TrainEnd function is called at the end of the training process in the project. It is called by two objects: Test1 and Test2. Both objects perform a series of actions and then call the TrainEnd function to mark the end of the training. The TrainEnd function is an essential part of the training process, as it allows the project to transition from the training phase to the testing or application phase.\n\n**Note**:\n- The TrainEnd function does not take any parameters.\n- The global variable \"Training\" is assumed to be defined and accessible from within the function."
      ],
      "code_start_line": 305,
      "code_end_line": 308,
      "parent": null,
      "params": [],
      "have_return": false,
      "code_content": "def TrainEnd():\n    global Training\n    print(\"//Training End\")\n    Training = False\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language_test.py/Test1",
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language_test.py/Test2"
      ],
      "reference_who": []
    }
  },
  "OpenNARS-for-Applications\\misc\\Python\\NAR_language_test.py": {
    "Test1": {
      "type": "FunctionDef",
      "name": "Test1",
      "md_content": [
        "**Test1**: The function of Test1 is to perform a series of actions and tests in the OpenNARS-for-Applications project.\n\n**parameters**: None\n\n**Code Description**:\nThe Test1 function is a key component in the OpenNARS-for-Applications project. It performs a series of actions and tests to demonstrate the functionality of the project. \n\nThe function starts by printing the message \"//Test1:\" to indicate the start of the Test1 function.\n\nNext, it calls the TrainStart function to initiate the training process. This function sets the global variable \"Training\" to True and prints the message \"//Training Start\" to indicate that the training process has begun.\n\nThe Test1 function then proceeds to call the processInput function multiple times with different input strings. The processInput function is responsible for processing user input and performing various actions based on the input type. The specific behavior and usage of the processInput function may vary depending on the calling object and the input parameters provided.\n\nAfter processing the input strings, the Test1 function calls the TrainEnd function to mark the end of the training process. This function sets the global variable \"Training\" to False and prints the message \"//Training End\" to indicate that the training process has ended.\n\nFinally, the Test1 function performs a series of queries using the Query function. The Query function is used to perform a query matching operation on a given term. It searches the memory for the best matching term based on the given parts and returns the result. The specific behavior and usage of the Query function may vary depending on the input term and the isRelation parameter.\n\nThe Test1 function prints the results of the queries using the print() function. The output examples provided in the code comments demonstrate the expected output of the queries.\n\nFrom a functional perspective, the Test1 function serves as a test case for the OpenNARS-for-Applications project. It demonstrates the usage of various functions and their interactions to perform actions and retrieve information from the memory.\n\n**Note**: \n- The Test1 function does not take any parameters.\n- The TrainStart, processInput, TrainEnd, and Query functions are assumed to be defined and accessible from within the Test1 function.\n- The specific behavior and output of the Test1 function may vary depending on the content of the memory and the implementation of the project.\n- The Test1 function can be modified or extended to include additional actions or tests as needed for the project."
      ],
      "code_start_line": 3,
      "code_end_line": 39,
      "parent": null,
      "params": [],
      "have_return": false,
      "code_content": "def Test1():\n    print(\"//Test1:\")\n    TrainStart()\n    processInput(\"<HUMAN --> [LEFT]>.\")\n    processInput(\"human is left\")\n    processInput(\"1\")\n    processInput(\"<HUMAN --> [RIGHT]>.\")\n    processInput(\"human is right\")\n    processInput(\"1\")\n    processInput(\"<HUMAN --> [FRONT]>.\")\n    processInput(\"human is front\")\n    processInput(\"1\")\n    processInput(\"<BOX --> [RIGHT]>.\")\n    processInput(\"box is right\")\n    processInput(\"1\")\n    processInput(\"<BALL --> [RIGHT]>.\")\n    processInput(\"ball is right\")\n    processInput(\"1\")\n    processInput(\"<BOX --> [LEFT]>.\")\n    processInput(\"box is left\")\n    processInput(\"1\")\n    processInput(\"<CAT --> [LEFT]>.\")\n    processInput(\"cat is to the left\")\n    processInput(\"1\")\n    processInput(\"<dog --> [RIGHT]>.\")\n    processInput(\"dog is to the right\")\n    processInput(\"1\")\n    TrainEnd()\n    print(Query(f\"<(human * ?1) --> R>\", isRelation=False))\n    #Output: ('<(human * HUMAN) --> R>', (1.0, 0.9642857142857143), [('?1', 'HUMAN')])\n    print(Query(f\"<(right * ?1) --> R>\", isRelation=False))\n    #Output: ('<(right * [RIGHT]) --> R>', (1.0, 0.9642857142857143), [('?1', '[RIGHT]')])\n    print(Query(f\"<(left * ?1) --> R>\", isRelation=False))\n    #Output: ('<(left * [LEFT]) --> R>', (1.0, 0.9473684210526316), [('?1', '[LEFT]')])\n    processInput(\"the human is to the left\")\n    #Output: <HUMAN --> [LEFT]>. :|:\n    processInput(\"the human is to the right\")\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/Query",
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/processInput",
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/TrainStart",
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/TrainEnd"
      ]
    },
    "Test2": {
      "type": "FunctionDef",
      "name": "Test2",
      "md_content": [
        "**Test2**: The function of Test2 is to execute a series of predefined actions and perform queries on the memory.\n\n**parameters**:\n- None\n\n**Code Description**:\nThe Test2 function is a high-level function that executes a series of predefined actions and performs queries on the memory. It serves as a test case for the OpenNARS-for-Applications project.\n\nThe function starts by printing the message \"//Test2:\" to indicate the start of the Test2 function.\n\nNext, it calls the TrainStart function to initiate the training process.\n\nThe function then proceeds to execute a series of processInput function calls with predefined input strings. These input strings represent various actions and statements that are processed by the NAR_language module.\n\nAfter executing the processInput function calls, the function calls the TrainEnd function to mark the end of the training process.\n\nFollowing the training phase, the function performs three queries on the memory using the Query function. Each query is constructed as a string and passed as an argument to the Query function. The results of the queries are printed using the print() function.\n\nFinally, the function calls the processInput function twice with additional input strings.\n\nFrom a functional perspective, the Test2 function serves as a test case for the NAR_language module. It demonstrates the usage of the TrainStart, TrainEnd, processInput, and Query functions. By executing a series of predefined actions and queries, the Test2 function verifies the functionality and correctness of the NAR_language module.\n\n**Note**: \n- The Test2 function does not take any parameters.\n- It is important to call the TrainStart function before executing any training-related tasks to ensure that the training process is properly initialized.\n- The processInput function is responsible for processing user input and performing various actions based on the input type.\n- The Query function is used to perform a query matching operation on a given term and retrieve relevant information from the memory."
      ],
      "code_start_line": 42,
      "code_end_line": 68,
      "parent": null,
      "params": [],
      "have_return": false,
      "code_content": "def Test2():\n    print(\"//Test2:\")\n    TrainStart()\n    processInput(\"<HUMAN --> [LEFT]>.\")\n    processInput(\"left eser human\")\n    processInput(\"1\")\n    processInput(\"<HUMAN --> [RIGHT]>.\")\n    processInput(\"right eser human\")\n    processInput(\"1\")\n    processInput(\"<STONE --> [RIGHT]>.\")\n    processInput(\"right\")\n    processInput(\"1\")\n    processInput(\"<CAT --> [LEFT]>.\")\n    processInput(\"left eser cat\")\n    processInput(\"1\")\n    processInput(\"<HUMAN --> [RIGHT]>.\")\n    processInput(\"right eser human\")\n    processInput(\"1\")\n    TrainEnd()\n    print(Query(f\"<(human * ?1) --> R>\", isRelation=False))\n    #Output: ('<(human * HUMAN) --> R>', (1.0, 0.9642857142857143), [('?1', 'HUMAN')])\n    print(Query(f\"<(right * ?1) --> R>\", isRelation=False))\n    #Output: ('<(right * [RIGHT]) --> R>', (1.0, 0.9642857142857143), [('?1', '[RIGHT]')])\n    print(Query(f\"<(left * ?1) --> R>\", isRelation=False))\n    #Output: ('<(left * [LEFT]) --> R>', (1.0, 0.9473684210526316), [('?1', '[LEFT]')])\n    processInput(\"left eser cat\")\n    processInput(\"right eser cat\")\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/Query",
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/processInput",
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/TrainStart",
        "OpenNARS-for-Applications\\misc\\Python\\NAR_language.py/TrainEnd"
      ]
    }
  },
  "OpenNARS-for-Applications\\misc\\Python\\NAR_Nalifier.py": {
    "ProcessNARret": {
      "type": "FunctionDef",
      "name": "ProcessNARret",
      "md_content": [
        "**ProcessNARret**: The function of ProcessNARret is to process the NAR (Non-Axiomatic Reasoning) return value and extract relevant information from it.\n\n**Parameters**:\n- `ret`: The NAR return value to be processed.\n\n**Code Description**:\nThe ProcessNARret function takes the NAR return value `ret` as input and performs operations to extract relevant information from it. \n\nThe function first checks if the \"derivations\" key is present in the `ret` dictionary and if it is not empty. If this condition is satisfied, the function iterates over each derivation in the \"derivations\" list.\n\nFor each derivation, the function checks if the \"punctuation\" key is equal to \"!\". If this condition is satisfied, the function further checks if the \"term\" key contains the string \" --> \" and \"[\". If this condition is also satisfied, the function extracts the property of interest from the \"term\" key.\n\nThe property of interest is obtained by splitting the \"term\" string using the \" --> \" separator, and then splitting the second part of the resulting list using \"[\" and \"]\" as separators. The extracted property is assigned to the variable `prop`.\n\nFinally, the function calls the ShellInput function from the Nalifier object, passing the \"*PROPERTY_OF_INTEREST=\" concatenated with the extracted property as the input.\n\n**Note**:\n- The ProcessNARret function is responsible for processing the NAR return value and extracting the property of interest from the derivations.\n- The function checks if the \"derivations\" key is present and not empty in the `ret` dictionary.\n- For each derivation, the function checks if the \"punctuation\" key is equal to \"!\" and if the \"term\" key contains the required separators.\n- The function extracts the property of interest from the \"term\" key and passes it to the ShellInput function for further processing.\n- The function does not return any value.\n\n**Output Example**:\nIf the `ret` dictionary contains the following structure:\n```\n{\n    \"derivations\": [\n        {\n            \"punctuation\": \"!\",\n            \"term\": \"A --> [property]\"\n        },\n        {\n            \"punctuation\": \"?\",\n            \"term\": \"B --> [property]\"\n        }\n    ]\n}\n```\nThe ProcessNARret function will call the ShellInput function with the input \"*PROPERTY_OF_INTEREST=property\"."
      ],
      "code_start_line": 31,
      "code_end_line": 37,
      "parent": null,
      "params": [
        "ret"
      ],
      "have_return": false,
      "code_content": "def ProcessNARret(ret):\n    if \"derivations\" in ret and ret[\"derivations\"]:\n        for derivation in ret[\"derivations\"]:\n            if derivation[\"punctuation\"] == \"!\":\n                if \" --> \" in derivation[\"term\"] and \"[\" in derivation[\"term\"]:\n                    prop = derivation[\"term\"].split(\" --> \")[1].split(\"[\")[1].split(\"]\")[0]\n                    nalifier.ShellInput(\"*PROPERTY_OF_INTEREST=\" + prop)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Nalifier/ShellInput"
      ]
    }
  },
  "OpenNARS-for-Applications\\misc\\Python\\persistentNAR.py": {
    "Allow_requery_if_not_in_ONA": {
      "type": "FunctionDef",
      "name": "Allow_requery_if_not_in_ONA",
      "md_content": [
        "**Allow_requery_if_not_in_ONA**: The function of Allow_requery_if_not_in_ONA is to check if a previously queried item is still present in the ONA (OpenNARS-for-Applications) memory. If the item is no longer in memory, it sets it up for re-query by removing it from the retrieved set.\n\n**parameters**:\n- term: A string representing the item to be checked for re-query.\n\n**Code Description**:\nThe Allow_requery_if_not_in_ONA function first checks if the given term is present in the retrieved set. If it is, it calls the AddInput function from the NAR (Non-Axiomatic Reasoning) system to send a Narsese input for processing. The Narsese input is constructed by appending a question mark to the term. The Print parameter is set to False to prevent printing the raw output.\n\nThe function then checks if the returned output contains answers and if the first answer has a \"truth\" key and a value of \"None\". If both conditions are met, it means that the item is no longer in the ONA memory. In this case, the function removes the term from the retrieved set.\n\n**Note**:\n- The AddInput function is called from the NAR system to send a Narsese input for processing.\n- The retrieved set is used to keep track of previously queried items.\n- The function assumes that the retrieved set, NAR system, and the AddInput function are defined and accessible within the same module.\n\nThe Allow_requery_if_not_in_ONA function is called by the query function in the persistentNAR.py file. The query function first calls the Allow_requery_if_not_in_ONA function to check if the given term is still in the ONA memory. If the term is not in the retrieved set but is present in the memory, it adds the term to the retrieved set and performs additional processing.\n\nIf the term contains \"?1\", the query function performs a simple query matching by splitting the term into two parts. It then iterates over the memory to find the best matching term based on a truth expectation function. If a matching term is found, the Allow_requery_if_not_in_ONA function is called to check if the term is still in the ONA memory. If the term is not in the retrieved set, it adds the term to the retrieved set and performs additional processing.\n\nFinally, the query function adds the term to the retrieved set.\n\n**Note**:\n- The query function relies on the Allow_requery_if_not_in_ONA function to check if a term needs to be re-queried.\n- The function performs additional processing for terms that are not in the retrieved set but are present in the memory.\n- The function assumes that the retrieved set, memory, and the Allow_requery_if_not_in_ONA function are defined and accessible within the same module."
      ],
      "code_start_line": 19,
      "code_end_line": 27,
      "parent": null,
      "params": [
        "term"
      ],
      "have_return": false,
      "code_content": "def Allow_requery_if_not_in_ONA(term):\n    #check if previously queried item is not in ONA memory anymore else we need\n    #to set it up for re-query by removing it from retrieved\n    if term in retrieved:\n        ret = NAR.AddInput(term + \"?\", Print=False)\n        if \"answers\" in ret and ret[\"answers\"]:\n            answer = ret[\"answers\"][0]\n            if \"truth\" not in answer and answer[\"term\"] == \"None\":\n                retrieved.remove(term)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\persistentNAR.py/query"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR.py/AddInput"
      ]
    },
    "query": {
      "type": "FunctionDef",
      "name": "query",
      "md_content": [
        "**query**: The function of query is to perform a query in the OpenNARS-for-Applications (ONA) system based on the given term.\n\n**parameters**:\n- term: A string representing the term to be queried.\n\n**Code Description**:\nThe query function is responsible for executing a query in the ONA system. It first calls the Allow_requery_if_not_in_ONA function to check if the given term needs to be re-queried. If the term is not in the retrieved set but is present in the memory, it adds the term to the retrieved set and performs additional processing.\n\nIf the term contains \"?1\", the function performs a simple query matching by splitting the term into two parts. It then iterates over the memory to find the best matching term based on a truth expectation function. The truth expectation function calculates the truth value of a term based on its frequency and confidence values. If a matching term is found, the Allow_requery_if_not_in_ONA function is called to check if the term is still in the ONA memory. If the term is not in the retrieved set, it adds the term to the retrieved set and performs additional processing.\n\nFinally, the function adds the term to the retrieved set.\n\n**Note**:\n- The Allow_requery_if_not_in_ONA function is called to check if a term needs to be re-queried.\n- The function performs additional processing for terms that are not in the retrieved set but are present in the memory.\n- The function assumes that the retrieved set, memory, and the Allow_requery_if_not_in_ONA function are defined and accessible within the same module.\n\nThe query function is called in the ProcessNAROutput function in the persistentNAR.py file. The ProcessNAROutput function processes the output received from the ONA system and performs further actions based on the derived terms. If a valid derivation is found, the query function is called to execute a query based on the derived term. The frequency and confidence values of the derived term are used to update the memory.\n\n**Note**:\n- The ProcessNAROutput function relies on the query function to execute queries based on derived terms.\n- The function assumes that the memory and query function are defined and accessible within the same module."
      ],
      "code_start_line": 29,
      "code_end_line": 53,
      "parent": null,
      "params": [
        "term"
      ],
      "have_return": false,
      "code_content": "def query(term):\n    Allow_requery_if_not_in_ONA(term)\n    if term not in retrieved and term in memory:\n        retrieved.add(term)\n        (f, c, _, stamp) = memory[term]\n        NAR.AddInput(\"*stampimport=\" + str(stamp), Print=False)\n        ProcessNAROutput(NAR.AddInput(f\"{term}. {{{f} {c}}}\", Print=Print))\n    if \"?1\" in term: #simple query matching\n        parts = term.split(\"?1\")\n        truth_expectation = lambda f,c: (c * (f - 0.5) + 0.5)\n        bestTerm, bestTruth, bestStamp = (None, (0.0, 0.5), [])\n        for term2 in memory:\n            (f2, c2, _, stamp) = memory[term2]\n            if term2.startswith(parts[0]) and term2.endswith(parts[1]):\n                if truth_expectation(f2, c2) > truth_expectation(bestTruth[0], bestTruth[1]):\n                    bestTerm = term2\n                    bestTruth = (f2, c2)\n                    bestStamp = stamp\n        if bestTerm is not None:\n            Allow_requery_if_not_in_ONA(bestTerm)\n        if bestTerm is not None and bestTerm not in retrieved:\n            retrieved.add(bestTerm)\n            NAR.AddInput(\"*stampimport=\" + str(bestStamp), Print=False)\n            ProcessNAROutput(NAR.AddInput(f\"{bestTerm}. {{{bestTruth[0]} {bestTruth[1]}}}\", Print=Print))\n    retrieved.add(term)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\persistentNAR.py/ProcessNAROutput"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR.py/AddInput",
        "OpenNARS-for-Applications\\misc\\Python\\persistentNAR.py/Allow_requery_if_not_in_ONA",
        "OpenNARS-for-Applications\\misc\\Python\\persistentNAR.py/ProcessNAROutput"
      ]
    },
    "ProcessNAROutput": {
      "type": "FunctionDef",
      "name": "ProcessNAROutput",
      "md_content": [
        "**ProcessNAROutput**: The function of ProcessNAROutput is to process the output received from the OpenNARS-for-Applications (ONA) system and update the memory based on the derived terms.\n\n**parameters**:\n- ret: A dictionary representing the output received from the ONA system.\n- backups (optional): A list of strings representing the backup types to be processed. The default value is [\"input\", \"answers\", \"derivations\"].\n\n**Code Description**:\nThe ProcessNAROutput function iterates over the specified backup types in the ret dictionary. For each backup, it further iterates over the derivations in that backup. It checks if a derivation meets certain conditions, including having a punctuation value of \".\", an occurrenceTime value of \"eternal\", and a non-empty term. If a valid derivation is found, the function performs the following steps:\n\n1. Extracts the term from the derivation.\n2. Removes the time delta prefix (\"dt=\") from the term if present.\n3. Calls the query function with the extracted term.\n4. Retrieves the frequency and confidence values from the derivation's truth dictionary.\n5. Retrieves the stamp value from the derivation.\n6. Determines the usefulness addition based on the presence of the \"Priority\" key in the derivation and its value.\n7. Checks if the term is already present in the memory. If so, retrieves the existing frequency, confidence, usefulness, and stamp values.\n8. Compares the confidence value of the current derivation with the existing confidence value in the memory. If the current derivation has a higher confidence value, updates the memory with the new frequency, confidence, usefulness, and stamp values.\n9. If the term is not already present in the memory, adds it to the memory with the new frequency, confidence, usefulness, and stamp values.\n\n**Note**:\n- The query function is called to execute queries based on the derived terms.\n- The memory is assumed to be defined and accessible within the same module.\n\nThe ProcessNAROutput function is called in the OpenNARS-for-Applications\\misc\\Python\\persistentNAR.py file. It is used to process the output received from the ONA system and update the memory based on the derived terms. The function assumes that the query function and memory are defined and accessible within the same module.\n\n**Note**:\n- The ProcessNAROutput function relies on the query function to execute queries based on derived terms.\n- The function assumes that the memory and query function are defined and accessible within the same module."
      ],
      "code_start_line": 55,
      "code_end_line": 72,
      "parent": null,
      "params": [
        "ret",
        "backups"
      ],
      "have_return": false,
      "code_content": "def ProcessNAROutput(ret, backups = [\"input\", \"answers\", \"derivations\"]):\n    for backup in backups:\n        for derivation in ret[backup]:\n            if derivation[\"punctuation\"] == \".\" and derivation[\"occurrenceTime\"] == \"eternal\" and derivation[\"term\"] != \"None\":\n                term = derivation[\"term\"]\n                if term.startswith(\"dt=\"): #we don't need to store time deltas\n                    term = \" \".join(term.split(\" \")[1:])\n                query(term)\n                f2 = float(derivation[\"truth\"][\"frequency\"])\n                c2 = float(derivation[\"truth\"][\"confidence\"])\n                stamp = derivation[\"Stamp\"]\n                usefulnessAddition = 1000000 if \"Priority\" not in derivation or derivation[\"Priority\"] == 1.0 else 1\n                if term in memory:\n                    (f, c, usefulness, _) = memory[term]\n                    if c2 >= c:\n                        memory[term] = (f2, c2, usefulness + usefulnessAddition, stamp)\n                else:\n                    memory[term] = (f2, c2, usefulnessAddition, stamp)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\persistentNAR.py/query"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\persistentNAR.py/query"
      ]
    },
    "SimplisticTermNormalizer": {
      "type": "FunctionDef",
      "name": "SimplisticTermNormalizer",
      "md_content": [
        "**SimplisticTermNormalizer**: The function of SimplisticTermNormalizer is to normalize the input string by handling space variations in involved parentheses.\n\n**parameters**:\n- inp: A string representing the input to be normalized.\n\n**Code Description**:\nThe SimplisticTermNormalizer function takes an input string and performs a series of string replacements to normalize the input. It replaces occurrences of \"-->\", \"<->\", \"==>\", \"<=>\", and \"=/>\" with their corresponding variations followed by a space. It then replaces any consecutive spaces with a single space. Additionally, it removes any leading or trailing spaces. Finally, it replaces occurrences of \"[ \", \" ]\", \"{ \", \" }\", \"< \", \" >\", \" )\", and \"( \" with their corresponding variations without the space. Again, it replaces any consecutive spaces with a single space and removes any leading or trailing spaces.\n\n**Note**:\n- The SimplisticTermNormalizer function only handles space variations in involved parentheses and does not perform any other form of normalization.\n- The function assumes that the input string is well-formed and does not perform any validation or error handling.\n\n**Output Example**:\nIf the input string is \"A-->B<->C==>D<=>E=/>F\", the SimplisticTermNormalizer function will return \"A --> B <-> C ==> D <=> E =/> F\"."
      ],
      "code_start_line": 74,
      "code_end_line": 79,
      "parent": null,
      "params": [
        "inp"
      ],
      "have_return": true,
      "code_content": "def SimplisticTermNormalizer(inp): #at least handle space variations in involved parenthesis in input\n    inp=inp.replace(\"-->\",\"--> \").replace(\"<->\",\" <-> \").replace(\"  \",\" \").replace(\n                    \"==>\",\"==> \").replace(\"<=>\",\" <=> \").replace(\"  \",\" \").replace(\n                    \"=/>\",\"=/> \").strip().replace(\"[ \",\"[\").replace(\" ]\",\"]\").replace(\"{ \",\"{\").replace(\" }\",\"}\").replace(\n                                                  \"< \",\"<\").replace(\" >\",\">\").replace(\" )\",\")\").replace(\"( \",\"(\").replace(\"  \",\" \").strip()\n    return inp\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    }
  },
  "OpenNARS-for-Applications\\misc\\Python\\printed_narsese_to_input.py": {
    "floatPart": {
      "type": "FunctionDef",
      "name": "floatPart",
      "md_content": [
        "**floatPart**: The function of floatPart is to extract the floating-point number from a given string.\n\n**parameters**:\n- s: A string from which the floating-point number needs to be extracted.\n\n**Code Description**:\nThe floatPart function takes a string as input and iterates through each character in the string. It checks if the character is a digit (0-9) or a period (.) using a conditional statement. If the character is a digit or a period, it is appended to the \"number\" string. If the character is neither a digit nor a period, the loop is terminated using the \"break\" statement. Finally, the \"number\" string, which contains the extracted floating-point number, is returned.\n\n**Note**:\n- The function assumes that the floating-point number in the string is a valid representation and does not perform any additional validation.\n- The function only extracts the floating-point number from the beginning of the string. Any characters after the first non-digit/non-period character are ignored.\n\n**Output Example**:\n- Input: \"3.14 is pi\"\n- Output: \"3.14\""
      ],
      "code_start_line": 32,
      "code_end_line": 39,
      "parent": null,
      "params": [
        "s"
      ],
      "have_return": true,
      "code_content": "def floatPart(s):\n    number = \"\"\n    for c in s:\n        if (c>='0' and c<='9') or c=='.':\n            number += c\n        else:\n            break\n    return number\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    }
  },
  "OpenNARS-for-Applications\\misc\\Python\\robot_collect_mission.py": {
    "close": {
      "type": "FunctionDef",
      "name": "close",
      "md_content": [
        "**close**: The function of close is to close the gripper of the robot.\n\n**parameters**:\n- This function does not take any parameters.\n\n**Code Description**:\nThe `close` function is responsible for closing the gripper of the robot. It achieves this by running the `m_gripper.run` method with a power value of -70, which indicates the direction and intensity of the gripper movement. After that, the function pauses for 4 seconds using the `sleep` function.\n\nThis function is called by the `gripper_pick` function in the `robot_collect_mission.py` file. The `gripper_pick` function is responsible for picking up objects using the robot's gripper. Before closing the gripper, the `gripper_pick` function checks if the gripper is already closed. If it is closed, the function returns without performing any action. Otherwise, it moves the robot forward twice, then calls the `close` function to close the gripper. Finally, it sets the `closed_gripper` variable to `True` to indicate that the gripper is now closed.\n\n**Note**:\n- The `power` parameter of the `m_gripper.run` method determines the strength of the gripper movement. A negative value indicates closing the gripper, while a positive value indicates opening it.\n- The `sleep` function is used to introduce a delay of 4 seconds before further actions are taken. This delay allows the gripper to close properly before proceeding with other tasks.\n- The `closed_gripper` variable is a global variable that keeps track of the gripper's state. It is set to `True` after the gripper is closed to prevent unnecessary closing operations."
      ],
      "code_start_line": 46,
      "code_end_line": 48,
      "parent": null,
      "params": [],
      "have_return": false,
      "code_content": "def close():\n    m_gripper.run(power=-70)\n    sleep(4.0)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\robot_collect_mission.py/gripper_pick"
      ],
      "reference_who": []
    },
    "open": {
      "type": "FunctionDef",
      "name": "open",
      "md_content": [
        "**open**: The function of open is to control the gripper of the robot to open.\n\n**parameters**:\n- No parameters are required for this function.\n\n**Code Description**:\nThe `open` function is responsible for opening the gripper of the robot. It performs the following steps:\n\n1. The `m_gripper.run(power=70)` command is used to activate the gripper and set the power to 70. This command starts the motor of the gripper and applies a certain amount of force to open it.\n2. The `sleep(2.0)` command is used to pause the execution of the program for 2 seconds. This allows the gripper to fully open and stabilize before proceeding to the next step.\n3. The `m_gripper.idle()` command is used to stop the motor of the gripper. This command deactivates the gripper and stops applying force, keeping it in an open position.\n\nThe `open` function is typically called in situations where the gripper needs to be opened, such as when the robot needs to release an object it is holding. \n\nIn the project, the `open` function is called by two other functions: `interrupt` and `gripper_drop`.\n\nIn the `interrupt` function, the `open` function is called if the gripper is currently closed. This is done to ensure that the gripper is opened before the program exits. The `interrupt` function is responsible for handling interruptions and stopping the robot's movement.\n\nIn the `gripper_drop` function, the `open` function is called after the robot moves forward three times. This is done to release the object held by the gripper. The `gripper_drop` function is responsible for dropping the object held by the gripper.\n\n**Note**:\n- The `open` function does not require any parameters.\n- It is important to ensure that the gripper is closed before calling the `open` function, as calling it when the gripper is already open may result in unexpected behavior.\n- The duration of the pause in the `sleep` command can be adjusted as needed, depending on the specific requirements of the gripper and the object being held."
      ],
      "code_start_line": 51,
      "code_end_line": 54,
      "parent": null,
      "params": [],
      "have_return": false,
      "code_content": "def open():\n    m_gripper.run(power=70)\n    sleep(2.0)\n    m_gripper.idle()\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\robot_collect_mission.py/interrupt",
        "OpenNARS-for-Applications\\misc\\Python\\robot_collect_mission.py/gripper_drop"
      ],
      "reference_who": []
    },
    "interrupt": {
      "type": "FunctionDef",
      "name": "interrupt",
      "md_content": [
        "**interrupt**: The function of interrupt is to handle interruptions and stop the robot's movement.\n\n**parameters**:\n- No parameters are required for this function.\n\n**Code Description**:\nThe `interrupt` function is responsible for handling interruptions and stopping the robot's movement. It performs the following steps:\n\n1. It checks if the touch sensor connected to port 2 (`Touch(b, PORT_2)`) is being pressed by calling the `get_sample()` method. If the touch sensor is pressed, indicating an interruption, the function proceeds to the next step. Otherwise, it does nothing.\n2. The `m_left.idle()` and `m_right.idle()` commands are used to stop the left and right motors of the robot, respectively. These commands deactivate the motors and stop the robot's movement.\n3. If the gripper is currently closed (`closed_gripper` is True), the `open()` function is called to open the gripper. This is done to ensure that the gripper is opened before the program exits.\n4. The `exit(0)` command is used to exit the program with a status code of 0. This terminates the program execution.\n\nThe `interrupt` function is typically called in situations where the robot needs to handle interruptions and stop its movement. It is commonly used in scenarios where the robot needs to respond to external events or user input.\n\nIn the project, the `interrupt` function is called in several other functions, such as `forward`, `left`, `right`, and `gripper_pick`. These functions call the `interrupt` function to handle interruptions and stop the robot's movement before performing their respective actions.\n\n**Note**:\n- The `interrupt` function does not require any parameters.\n- It is important to ensure that the touch sensor is properly connected to the correct port (`PORT_2`) for the `get_sample()` method to work correctly.\n- The `open()` function is called if the gripper is currently closed to ensure that the gripper is opened before the program exits."
      ],
      "code_start_line": 58,
      "code_end_line": 64,
      "parent": null,
      "params": [],
      "have_return": false,
      "code_content": "def interrupt():\n    if Touch(b, PORT_2).get_sample():\n        m_left.idle()\n        m_right.idle()\n        if closed_gripper:\n            open()\n        exit(0)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\robot_collect_mission.py/forward",
        "OpenNARS-for-Applications\\misc\\Python\\robot_collect_mission.py/left",
        "OpenNARS-for-Applications\\misc\\Python\\robot_collect_mission.py/right",
        "OpenNARS-for-Applications\\misc\\Python\\robot_collect_mission.py/gripper_pick"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\robot_collect_mission.py/open"
      ]
    },
    "forward": {
      "type": "FunctionDef",
      "name": "forward",
      "md_content": [
        "**forward**: The function of forward is to move the robot forward for a specified duration.\n\n**parameters**:\n- mul (optional): A multiplier for the power of the motors. By default, it is set to 1.\n\n**Code Description**:\nThe `forward` function is responsible for moving the robot forward for a specified duration. It performs the following steps:\n\n1. It calls the `interrupt` function to handle interruptions and stop the robot's movement.\n2. It calculates the power (`P`) for the motors based on the state of the gripper. If the gripper is closed (`closed_gripper` is True), the power is set to 70. Otherwise, it is set to 64.\n3. It calls the `run` method of the left and right motors (`m_left.run()` and `m_right.run()`) with the calculated power multiplied by the `mul` parameter. This sets the motors to run at the specified power.\n4. It pauses the execution for 1.3 seconds using the `sleep` function from the `time` module.\n5. It calls the `idle` method of the left and right motors (`m_left.idle()` and `m_right.idle()`) to stop the motors and put them in an idle state.\n6. It returns the string \"forward\" to indicate that the forward action has been completed.\n\nThe `forward` function is typically called when the robot needs to move forward for a certain duration. It is commonly used in scenarios where the robot needs to navigate a specific path or reach a particular location.\n\n**Note**:\n- The `mul` parameter can be used to adjust the power of the motors. A higher value will result in faster movement, while a lower value will result in slower movement.\n- The `interrupt` function is called at the beginning of the `forward` function to handle interruptions and stop the robot's movement if necessary.\n- The duration of the forward movement is fixed at 1.3 seconds in the current implementation.\n- The `forward` function does not return any value other than the string \"forward\" to indicate completion.\n\n**Output Example**:\n\"forward\""
      ],
      "code_start_line": 66,
      "code_end_line": 74,
      "parent": null,
      "params": [
        "mul"
      ],
      "have_return": true,
      "code_content": "def forward(mul=1):\n    interrupt()\n    P = 70 if closed_gripper else 64\n    m_left.run(power=P*mul)\n    m_right.run(power=P*mul)\n    sleep(1.3)\n    m_left.idle()\n    m_right.idle()\n    return \"forward\"\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\robot_collect_mission.py/gripper_pick",
        "OpenNARS-for-Applications\\misc\\Python\\robot_collect_mission.py/gripper_drop",
        "OpenNARS-for-Applications\\misc\\Python\\robot_collect_mission.py/ExecMotorCommands"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\robot_collect_mission.py/interrupt"
      ]
    },
    "left": {
      "type": "FunctionDef",
      "name": "left",
      "md_content": [
        "**left**: The function of left is to make the robot turn left by controlling the left and right motors.\n\n**parameters**:\n- doScan (optional): A boolean parameter that indicates whether the robot should perform a scan while turning left. By default, it is set to False.\n\n**Code Description**:\nThe `left` function is responsible for making the robot turn left by controlling the left and right motors. It performs the following steps:\n\n1. It calls the `interrupt` function to handle interruptions and stop the robot's movement.\n2. It sets the power (`P`) of the left motor based on the state of the gripper. If the gripper is closed (`closed_gripper` is True), the power is set to 70. Otherwise, it is set to 64.\n3. It calls the `run()` method of the `m_left` motor with the calculated power (`P`) to make the left motor rotate.\n4. It calls the `run()` method of the `m_right` motor with the negative value of the calculated power (`-P`) to make the right motor rotate in the opposite direction.\n5. It pauses the execution for a certain duration depending on the value of the `doScan` parameter. If `doScan` is True, the pause duration is set to 0.45 seconds. Otherwise, it is set to 1.0 second.\n6. It calls the `idle()` method of both the `m_left` and `m_right` motors to stop their rotation and put them in an idle state.\n7. Finally, it returns the string \"left\" to indicate that the robot has turned left.\n\nThe `left` function is typically called when the robot needs to turn left. It can be used in various scenarios, such as navigating a maze or following a specific path.\n\n**Note**:\n- The `doScan` parameter is optional and can be omitted when calling the `left` function.\n- The `interrupt` function is called at the beginning of the `left` function to handle interruptions and stop the robot's movement.\n- The power (`P`) of the left motor is determined based on the state of the gripper. If the gripper is closed, a higher power is used to compensate for the additional weight.\n- The pause duration during execution is determined by the value of the `doScan` parameter. If `doScan` is True, a shorter pause duration is used to allow for scanning while turning left.\n- The `left` function returns the string \"left\" to indicate that the robot has turned left.\n\n**Output Example**: \"left\""
      ],
      "code_start_line": 76,
      "code_end_line": 84,
      "parent": null,
      "params": [
        "doScan"
      ],
      "have_return": true,
      "code_content": "def left(doScan=False):\n    interrupt()\n    P = 70 if closed_gripper else 64\n    m_left.run(power=P)\n    m_right.run(power=-P)\n    sleep(0.45 if doScan==True else 1.0)\n    m_left.idle()\n    m_right.idle()\n    return \"left\"\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\robot_collect_mission.py/scan",
        "OpenNARS-for-Applications\\misc\\Python\\robot_collect_mission.py/ExecMotorCommands"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\robot_collect_mission.py/interrupt"
      ]
    },
    "right": {
      "type": "FunctionDef",
      "name": "right",
      "md_content": [
        "**right**: The function of right is to make the robot turn right.\n\n**parameters**:\n- doScan (optional): A boolean parameter indicating whether the robot should perform a scan while turning. By default, it is set to False.\n\n**Code Description**:\nThe `right` function is responsible for making the robot turn right. It performs the following steps:\n\n1. It calls the `interrupt` function to handle interruptions and stop the robot's movement.\n2. It calculates the power value `P` based on the state of the gripper. If the gripper is closed (`closed_gripper` is True), the power value is set to 70. Otherwise, it is set to 64.\n3. It runs the left motor (`m_left`) with a negative power value of `-P`, causing the robot to turn right.\n4. It runs the right motor (`m_right`) with a power value of `P`, causing the robot to turn right.\n5. It pauses the execution for a certain duration. If the `doScan` parameter is True, the pause duration is set to 0.45 seconds. Otherwise, it is set to 1.0 second.\n6. It stops the left and right motors by calling the `idle()` method on both motors.\n7. It returns the string \"right\" to indicate that the function has successfully executed.\n\nThe `right` function is typically called when the robot needs to turn right. It can be used in various scenarios, such as navigating a maze or following a specific path.\n\n**Note**:\n- The `doScan` parameter is optional and defaults to False. If set to True, the robot will perform a scan while turning.\n- The power value `P` determines the speed at which the robot turns. Adjusting this value can affect the turning speed of the robot.\n- The pause duration can also be adjusted based on the specific requirements of the application.\n\n**Output Example**: \"right\""
      ],
      "code_start_line": 86,
      "code_end_line": 94,
      "parent": null,
      "params": [
        "doScan"
      ],
      "have_return": true,
      "code_content": "def right(doScan=False):\n    interrupt()\n    P = 70 if closed_gripper else 64\n    m_left.run(power=-P)\n    m_right.run(power=P)\n    sleep(0.45 if doScan==True else 1.0)\n    m_left.idle()\n    m_right.idle()\n    return \"right\"\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\robot_collect_mission.py/scan",
        "OpenNARS-for-Applications\\misc\\Python\\robot_collect_mission.py/ExecMotorCommands"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\robot_collect_mission.py/interrupt"
      ]
    },
    "gripper_pick": {
      "type": "FunctionDef",
      "name": "gripper_pick",
      "md_content": [
        "**gripper_pick**: The function of gripper_pick is to pick up objects using the robot's gripper.\n\n**parameters**:\n- This function does not take any parameters.\n\n**Code Description**:\nThe `gripper_pick` function is responsible for picking up objects using the robot's gripper. It performs the following steps:\n\n1. It calls the `interrupt` function to handle interruptions and stop the robot's movement.\n2. It checks if the gripper is already closed (`closed_gripper` is True). If it is closed, indicating that an object is already picked up, the function returns without performing any action.\n3. If the gripper is not closed, the function moves the robot forward twice by calling the `forward` function.\n4. It then calls the `close` function to close the gripper.\n5. After closing the gripper, the `closed_gripper` variable is set to `True` to indicate that the gripper is now closed.\n6. Finally, the function returns the string \"gripper_pick\" to indicate that the gripper pick action has been completed.\n\nThe `gripper_pick` function is typically called when the robot needs to pick up objects using its gripper. It is commonly used in scenarios where the robot needs to collect or manipulate objects.\n\n**Note**:\n- The `interrupt` function is called at the beginning of the `gripper_pick` function to handle interruptions and stop the robot's movement if necessary.\n- The `closed_gripper` variable is a global variable that keeps track of the gripper's state. It is set to `True` after the gripper is closed to prevent unnecessary closing operations.\n- The `forward` function is called twice before closing the gripper to position the robot correctly for the pick action.\n- The `close` function is responsible for closing the gripper of the robot. It is called by the `gripper_pick` function to perform the gripper closing action.\n- The `gripper_pick` function does not take any parameters.\n- The return value of the `gripper_pick` function is the string \"gripper_pick\" to indicate completion.\n\n**Output Example**:\n\"gripper_pick\""
      ],
      "code_start_line": 96,
      "code_end_line": 105,
      "parent": null,
      "params": [],
      "have_return": true,
      "code_content": "def gripper_pick():\n    global closed_gripper\n    interrupt()\n    if closed_gripper:\n        return\n    forward()\n    forward()\n    close()\n    closed_gripper = True\n    return \"gripper_pick\"\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\robot_collect_mission.py/ExecMotorCommands"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\robot_collect_mission.py/close",
        "OpenNARS-for-Applications\\misc\\Python\\robot_collect_mission.py/interrupt",
        "OpenNARS-for-Applications\\misc\\Python\\robot_collect_mission.py/forward"
      ]
    },
    "gripper_drop": {
      "type": "FunctionDef",
      "name": "gripper_drop",
      "md_content": [
        "**gripper_drop**: The function of gripper_drop is to drop the object held by the gripper of the robot.\n\n**parameters**:\n- No parameters are required for this function.\n\n**Code Description**:\nThe `gripper_drop` function is responsible for dropping the object held by the gripper of the robot. It performs the following steps:\n\n1. It checks the state of the `closed_gripper` variable. If the gripper is not closed (i.e., `closed_gripper` is False), the function returns without performing any action.\n2. It calls the `forward` function three times to move the robot forward.\n3. It calls the `open` function to open the gripper and release the object.\n4. It calls the `forward` function twice with a negative multiplier (`mul=-1`) to move the robot backward.\n5. It updates the state of the `closed_gripper` variable to indicate that the gripper is now open.\n6. It returns the string \"gripper_drop\" to indicate that the gripper drop action has been completed.\n\nThe `gripper_drop` function is typically called when the robot needs to release an object it is holding. It is commonly used in scenarios where the robot needs to collect and deposit objects.\n\n**Note**:\n- The `gripper_drop` function does not require any parameters.\n- It is important to ensure that the gripper is closed before calling the `gripper_drop` function, as calling it when the gripper is already open may result in unexpected behavior.\n- The `forward` function is called before and after the `open` function to ensure that the gripper is in the correct position for dropping the object.\n- The `forward` function is called three times before the `open` function to move the robot forward and position it correctly for dropping the object.\n- The `forward` function is called twice with a negative multiplier after the `open` function to move the robot backward and return it to its original position.\n- The `open` function is called to open the gripper and release the object.\n- The `closed_gripper` variable is updated to indicate that the gripper is now open.\n- The `gripper_drop` function does not return any value other than the string \"gripper_drop\" to indicate completion.\n\n**Output Example**:\n\"gripper_drop\""
      ],
      "code_start_line": 107,
      "code_end_line": 118,
      "parent": null,
      "params": [],
      "have_return": true,
      "code_content": "def gripper_drop():\n    global closed_gripper\n    if not closed_gripper:\n        return\n    forward()\n    forward()\n    forward()\n    open()\n    forward(mul=-1)\n    forward(mul=-1)\n    closed_gripper = False\n    return \"gripper_drop\"\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\robot_collect_mission.py/ExecMotorCommands"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\robot_collect_mission.py/open",
        "OpenNARS-for-Applications\\misc\\Python\\robot_collect_mission.py/forward"
      ]
    },
    "scan": {
      "type": "FunctionDef",
      "name": "scan",
      "md_content": [
        "**scan**: The function of scan is to perform a scanning operation using an ultrasonic sensor and determine if the proximity to an object is less than 20.\n\n**parameters**:\n- None\n\n**Code Description**:\nThe `scan` function is responsible for performing a scanning operation using an ultrasonic sensor to measure the proximity to an object. It follows the steps below:\n\n1. It initializes the `Proximity` variable with a value of 1000.\n2. It calls the `Ultrasonic` class with the parameters `b` and `PORT_3` to create an instance of the ultrasonic sensor.\n3. It retrieves the sample value from the ultrasonic sensor using the `get_sample()` method and compares it with the current value of `Proximity`. The `min()` function is used to update `Proximity` with the minimum value between the current `Proximity` and the retrieved sample value.\n4. It calls the `left` function with the parameter `doScan` set to `True` to make the robot turn left and potentially perform a scan.\n5. It retrieves another sample value from the ultrasonic sensor and updates `Proximity` with the minimum value between the current `Proximity` and the retrieved sample value.\n6. It calls the `right` function with the parameter `doScan` set to `True` to make the robot turn right and potentially perform a scan.\n7. It retrieves another sample value from the ultrasonic sensor and updates `Proximity` with the minimum value between the current `Proximity` and the retrieved sample value.\n8. It calls the `right` function with the parameter `doScan` set to `True` to make the robot turn right and potentially perform a scan.\n9. It retrieves another sample value from the ultrasonic sensor and updates `Proximity` with the minimum value between the current `Proximity` and the retrieved sample value.\n10. It calls the `left` function with the parameter `doScan` set to `True` to make the robot turn left and potentially perform a scan.\n11. It retrieves another sample value from the ultrasonic sensor and updates `Proximity` with the minimum value between the current `Proximity` and the retrieved sample value.\n12. It checks if the value of `Proximity` is less than 20 and returns `True` if it is, indicating that the proximity to an object is less than 20. Otherwise, it returns `False`.\n\nThe `scan` function is typically used when the robot needs to perform a scanning operation to detect nearby objects. It can be used in various scenarios, such as obstacle avoidance or object detection.\n\n**Note**:\n- The `Proximity` variable is used to store the minimum proximity value detected during the scanning operation.\n- The `Ultrasonic` class is used to interface with the ultrasonic sensor and retrieve sample values.\n- The `left` and `right` functions are called to make the robot turn left and right, respectively, potentially allowing for scanning during the turning operation.\n- The `doScan` parameter of the `left` and `right` functions determines whether a scan should be performed while turning.\n- The `scan` function returns `True` if the proximity to an object is less than 20, and `False` otherwise.\n\n**Output Example**: True"
      ],
      "code_start_line": 120,
      "code_end_line": 131,
      "parent": null,
      "params": [],
      "have_return": true,
      "code_content": "def scan():\n    Proximity = 1000\n    Proximity = min(Proximity, Ultrasonic(b, PORT_3).get_sample())\n    left(doScan=True)\n    Proximity = min(Proximity, Ultrasonic(b, PORT_3).get_sample())\n    right(doScan=True)\n    Proximity = min(Proximity, Ultrasonic(b, PORT_3).get_sample())\n    right(doScan=True)\n    Proximity = min(Proximity, Ultrasonic(b, PORT_3).get_sample())\n    left(doScan=True)\n    Proximity = min(Proximity, Ultrasonic(b, PORT_3).get_sample())\n    return Proximity < 20\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\robot_collect_mission.py/left",
        "OpenNARS-for-Applications\\misc\\Python\\robot_collect_mission.py/right"
      ]
    },
    "ExecMotorCommands": {
      "type": "FunctionDef",
      "name": "ExecMotorCommands",
      "md_content": [
        "**ExecMotorCommands**: The function of ExecMotorCommands is to execute a series of motor commands based on the given list of executions. It determines the appropriate action for each execution based on the \"operator\" value and calls the corresponding functions to perform the desired motor action. The function also has an optional parameter, DisableForward, which can be used to disable the forward action if necessary.\n\n**parameters**:\n- executions: A list of dictionaries representing the motor commands to be executed. Each dictionary should have an \"operator\" key indicating the desired action.\n- DisableForward (optional): A boolean parameter that, when set to True, disables the forward action. By default, it is set to False.\n\n**Code Description**:\nThe `ExecMotorCommands` function iterates over the list of executions and performs the following steps for each execution:\n\n1. It prints the execution for debugging purposes.\n2. It checks the value of the \"operator\" key in the execution dictionary to determine the desired action.\n3. If the \"operator\" value is \"^left\", it calls the `left` function to make the robot turn left.\n4. If the \"operator\" value is \"^right\", it calls the `right` function to make the robot turn right.\n5. If the \"operator\" value is \"^forward\" and the DisableForward parameter is False, it calls the `forward` function to move the robot forward.\n6. If the \"operator\" value is \"^pick\" and the DisableForward parameter is False, it calls the `gripper_pick` function to pick up an object using the gripper.\n7. If the \"operator\" value is \"^drop\" and the DisableForward parameter is False, it calls the `gripper_drop` function to drop the object held by the gripper.\n8. After executing the appropriate action for each execution, it returns the value of the `action` variable.\n\nThe `ExecMotorCommands` function is typically used to execute a sequence of motor commands based on a predefined plan or set of instructions. It allows the robot to perform complex tasks by combining different motor actions.\n\n**Note**:\n- The `DisableForward` parameter can be used to prevent the robot from moving forward if necessary. This can be useful in situations where forward movement is not desired or may cause hardware damage.\n- The function only performs one action for each execution. If multiple actions need to be performed simultaneously, they should be specified as separate executions in the list.\n- The function returns the value of the `action` variable, which represents the last executed action. If no action is executed, the return value will be None.\n\n**Output Example**: The return value of the `ExecMotorCommands` function depends on the executed action. It can be one of the following: \"left\", \"right\", \"forward\", \"gripper_pick\", \"gripper_drop\", or None."
      ],
      "code_start_line": 133,
      "code_end_line": 147,
      "parent": null,
      "params": [
        "executions",
        "DisableForward"
      ],
      "have_return": true,
      "code_content": "def ExecMotorCommands(executions, DisableForward=False):\n    action = None  #DisableForward as an optional reflex to preserve hardware integrity if already too close\n    for execution in executions:\n        print(execution)\n        if execution[\"operator\"] == \"^left\":\n            action = left()\n        elif execution[\"operator\"] == \"^right\":\n            action = right()\n        elif execution[\"operator\"] == \"^forward\" and not DisableForward: #forward or gripper-pick\n            action = forward()\n        elif execution[\"operator\"] == \"^pick\" and not DisableForward:\n            action = gripper_pick()\n        elif execution[\"operator\"] == \"^drop\" and not DisableForward: #currently used for gripper-drop\n            action = gripper_drop()\n    return action\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\robot_collect_mission.py/NAR_Invoke"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\robot_collect_mission.py/forward",
        "OpenNARS-for-Applications\\misc\\Python\\robot_collect_mission.py/left",
        "OpenNARS-for-Applications\\misc\\Python\\robot_collect_mission.py/right",
        "OpenNARS-for-Applications\\misc\\Python\\robot_collect_mission.py/gripper_pick",
        "OpenNARS-for-Applications\\misc\\Python\\robot_collect_mission.py/gripper_drop"
      ]
    },
    "NAR_Invoke": {
      "type": "FunctionDef",
      "name": "NAR_Invoke",
      "md_content": [
        "**NAR_Invoke**: The function of NAR_Invoke is to invoke the NAR (Non-Axiomatic Reasoning) system based on the given proximity and visual events. It processes the inputs and determines the appropriate actions to be taken by the robot.\n\n**parameters**:\n- Proximity: A boolean value indicating whether there is an obstacle in proximity to the robot.\n- VisualEvents: A list of visual events representing the objects observed by the robot.\n\n**Code Description**:\nThe `NAR_Invoke` function starts by initializing the variable `SeenSomethingMissionRelevant` as False. This variable is used to keep track of whether any mission-relevant objects have been observed.\n\nIf there is an obstacle in proximity (`Proximity` is True), the function calls the `AddInput` function from the `NAR.py` module to add a Narsese input \"<obstacle --> [observed]>.\" to the NAR system. This input represents the observation of an obstacle. \n\nIf there is no obstacle in proximity, the function checks the status of the gripper. If the gripper is closed, it adds the Narsese input \"<gripper --> [closed]>.\" to the NAR system. Otherwise, it adds the input \"<gripper --> [open]>.\" to represent the status of the gripper.\n\nNext, the function checks if there are any visual events. If the length of the `VisualEvents` list is greater than 0, it iterates over each object in the `VisibleObjects` list and each visual event in the `VisualEvents` list. It checks if the object is present in any of the visual events. If it is, it adds the visual event as a Narsese input to the NAR system and sets `SeenSomethingMissionRelevant` to True.\n\nIf no mission-relevant objects have been observed (`SeenSomethingMissionRelevant` is still False), the function adds the Narsese input \"(! <obstacle --> [observed]>).\" to the NAR system. This input represents the negation of the observation of an obstacle.\n\nThe function then determines the appropriate action based on the proximity and the observation of mission-relevant objects. If there is an obstacle in proximity and no mission-relevant objects have been observed, it calls the `AddInput` function to add the Narsese input \"(! <obstacle --> [observed]>)!\" to the NAR system. This input represents the negation of the observation of an obstacle and is used to prevent the robot from moving forward as a reflex to avoid damaging the hardware. The function retrieves the executions from the NAR system's output and calls the `ExecMotorCommands` function to execute the motor commands, disabling the forward action.\n\nIf there is no obstacle in proximity or mission-relevant objects have been observed, the function adds the Narsese input \"<mission --> [progressed]>!\" or \"<{SELF} --> [moved]>!\" to the NAR system, depending on whether mission-relevant objects have been observed. It also adds the input \"5\" to represent a predefined action. The function retrieves the executions from the NAR system's output and calls the `ExecMotorCommands` function to execute the motor commands.\n\nFinally, if the executed action is \"forward\", the function adds the Narsese input \"<{SELF} --> [moved]>.\" to the NAR system.\n\n**Note**:\n- The `NAR_Invoke` function relies on the `AddInput` function from the `NAR.py` module to communicate with the NAR system and process the inputs.\n- The function uses the `ExecMotorCommands` function to execute the motor commands based on the output from the NAR system.\n- The function assumes that the `VisibleObjects` list is defined and contains the objects visible to the robot.\n- The function assumes that the `closed_gripper` variable is defined and represents the status of the gripper.\n- The function assumes that the `NAR` module is imported and accessible within the same module as the `NAR_Invoke` function."
      ],
      "code_start_line": 151,
      "code_end_line": 179,
      "parent": null,
      "params": [
        "Proximity",
        "VisualEvents"
      ],
      "have_return": false,
      "code_content": "def NAR_Invoke(Proximity, VisualEvents):\n    SeenSomethingMissionRelevant = False\n    if Proximity:\n        NAR.AddInput(\"<obstacle --> [observed]>. :|:\") #TODO also encode color\n    else:\n        if closed_gripper:\n            NAR.AddInput(\"<gripper --> [closed]>. :|:\")\n        else:\n            NAR.AddInput(\"<gripper --> [open]>. :|:\")\n        if len(VisualEvents) > 0:\n            Observed = False\n            for obj in VisibleObjects:\n                for v in VisualEvents:\n                    print(v)\n                    if obj in v:\n                        NAR.AddInput(v)\n                        SeenSomethingMissionRelevant = True\n        if not SeenSomethingMissionRelevant:\n            NAR.AddInput(\"(! <obstacle --> [observed]>). :|:\") #TODO also encode color\n    action = None\n    if Proximity and not SeenSomethingMissionRelevant: #Don't allow forward as a reflex to not damage hardware\n        executions = NAR.AddInput(\"(! <obstacle --> [observed]>)! :|:\")[\"executions\"]\n        action = ExecMotorCommands(executions, DisableForward=True)\n    else:\n        executions = NAR.AddInput(\"<mission --> [progressed]>! :|:\" if SeenSomethingMissionRelevant else \"<{SELF} --> [moved]>! :|:\")[\"executions\"]\n        executions += NAR.AddInput(\"5\")[\"executions\"]\n        action = ExecMotorCommands(executions)\n    if action == \"forward\":\n        NAR.AddInput(\"<{SELF} --> [moved]>. :|:\")\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR.py/AddInput",
        "OpenNARS-for-Applications\\misc\\Python\\robot_collect_mission.py/ExecMotorCommands"
      ]
    }
  },
  "OpenNARS-for-Applications\\misc\\Python\\sortingtask.py": {
    "printloud": {
      "type": "FunctionDef",
      "name": "printloud",
      "md_content": [
        "**printloud**: The function of printloud is to print the value of the variable 'x' if the variable 'loud' is True.\n\n**parameters**:\n- x: (optional) A string value to be printed. If not provided, the default value is an empty string.\n\n**Code Description**:\nThe 'printloud' function takes an optional parameter 'x' which is a string. It checks if the variable 'loud' is True. If it is, the function prints the value of 'x' using the 'print' function.\n\n**Note**:\n- The 'loud' variable is not defined in the given code snippet. It should be defined elsewhere in the code for the function to work properly.\n- If 'loud' is False, the function will not print anything.\n- If 'x' is not provided, the function will print an empty string."
      ],
      "code_start_line": 8,
      "code_end_line": 10,
      "parent": null,
      "params": [
        "x"
      ],
      "have_return": false,
      "code_content": "def printloud(x=\"\"):\n    if loud:\n        print(x)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    }
  },
  "OpenNARS-for-Applications\\misc\\Python\\trafficpredict.py": {
    "distance": {
      "type": "FunctionDef",
      "name": "distance",
      "md_content": [
        "**distance**: The function of distance is to calculate the maximum absolute difference between the x-coordinates and y-coordinates of two given points.\n\n**parameters**:\n- posX: The x-coordinate of the first point.\n- posY: The y-coordinate of the first point.\n- posX2: The x-coordinate of the second point.\n- posY2: The y-coordinate of the second point.\n\n**Code Description**:\nThe distance function takes in four parameters: posX, posY, posX2, and posY2. It calculates the difference between the x-coordinates (dx) and the difference between the y-coordinates (dy) of the two given points. The function then returns the maximum absolute difference between dx and dy.\n\nThis function is used to measure the distance between two points in a two-dimensional space. It can be used in various applications, such as determining the proximity of objects or calculating the distance between two locations.\n\nIn the project, this distance function is called in multiple places. \n\nIn the code of the `Entity` class, the distance function is used to check the distance between the current entity and the traffic lights. If the distance is less than the radius of the traffic light, and the traffic light is red, the velocity of the entity is reduced. This ensures that the entity slows down when approaching a red traffic light.\n\nThe distance function is also used to check the distance between the current entity and other entities. If the distance is less than a certain threshold, the velocity of the entity is reduced. This prevents entities from colliding with each other.\n\nIn the code of the `Camera` class, the distance function is used to determine if an entity is within the view radius of the camera. If an entity is within the view radius, the camera informs an informer object about the entity.\n\nIn the code of the `streetcolor` function, the distance function is used to calculate the distance between a given point and the position of the camera. If the distance is less than the view radius of the camera, the function returns a specific color code.\n\n**Note**: \n- The distance function assumes a two-dimensional Cartesian coordinate system.\n- The function returns the maximum absolute difference between the x-coordinates and y-coordinates, which represents the maximum distance between the two points in either the x or y direction.\n- The distance function does not take into account any units of measurement. It operates purely on the numerical values of the coordinates.\n- The distance function does not perform any error checking or validation of the input parameters. It assumes that the input parameters are valid numerical values.\n\n**Output Example**: \nIf the input parameters are posX=1, posY=2, posX2=4, posY2=6, the distance function will calculate the differences dx=1-4=-3 and dy=2-6=-4. The maximum absolute difference between dx and dy is 4, so the function will return 4."
      ],
      "code_start_line": 7,
      "code_end_line": 10,
      "parent": null,
      "params": [
        "posX",
        "posY",
        "posX2",
        "posY2"
      ],
      "have_return": true,
      "code_content": "def distance(posX, posY, posX2, posY2):\n    dx = posX - posX2\n    dy = posY - posY2\n    return max(abs(dx), abs(dy))\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\trafficpredict.py/Entity",
        "OpenNARS-for-Applications\\misc\\Python\\trafficpredict.py/Camera/see",
        "OpenNARS-for-Applications\\misc\\Python\\trafficpredict.py/streetcolor"
      ],
      "reference_who": []
    },
    "Street": {
      "type": "ClassDef",
      "name": "Street",
      "md_content": [
        "**Street**: The function of Street is to represent a street in a traffic prediction system.\n\n**attributes**:\n- forCarsOnly: A boolean value indicating whether the street is only for cars.\n- startX: The x-coordinate of the starting point of the street.\n- startY: The y-coordinate of the starting point of the street.\n- endX: The x-coordinate of the ending point of the street.\n- endY: The y-coordinate of the ending point of the street.\n\n**Code Description**: The Street class is used to define and represent a street in a traffic prediction system. It has attributes to store the starting and ending coordinates of the street, as well as a flag to indicate whether the street is exclusively for cars.\n\nThe constructor method `__init__` is called when a new instance of the Street class is created. It takes five parameters: `forCarsOnly`, `startX`, `startY`, `endX`, and `endY`. These parameters are used to initialize the corresponding attributes of the Street object.\n\nThe `forCarsOnly` parameter is a boolean value that determines whether the street is only for cars. If set to `True`, it means that the street is exclusively for cars. If set to `False`, it means that the street can be used by other types of vehicles as well.\n\nThe `startX` and `startY` parameters represent the coordinates of the starting point of the street. These coordinates define the position where the street begins.\n\nSimilarly, the `endX` and `endY` parameters represent the coordinates of the ending point of the street. These coordinates define the position where the street ends.\n\nOnce the Street object is created, the constructor assigns the parameter values to the corresponding attributes of the object using the `self` keyword. This allows the object to store and access these values throughout its lifetime.\n\n**Note**: When creating a new instance of the Street class, make sure to provide the appropriate values for the `forCarsOnly`, `startX`, `startY`, `endX`, and `endY` parameters. These values will be used to initialize the attributes of the Street object."
      ],
      "code_start_line": 12,
      "code_end_line": 18,
      "parent": null,
      "params": [],
      "have_return": false,
      "code_content": "class Street:\n    def __init__(self,forCarsOnly, startX, startY, endX, endY):\n        self.startX = startX;\n        self.startY = startY;\n        self.endX = endX;\n        self.endY = endY;\n        self.forCarsOnly = forCarsOnly;\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "Entity": {
      "type": "ClassDef",
      "name": "Entity",
      "md_content": [
        "**Entity**: The Entity class represents an entity in the traffic prediction system. It serves as a base class for other specific entity classes such as Car and Pedestrian.\n\n**Attributes**:\n- entityID: An integer representing the unique identifier of the entity.\n- label: A string representing the label of the entity.\n- posX: A float value representing the X-coordinate of the entity's position.\n- posY: A float value representing the Y-coordinate of the entity's position.\n- width: A float value representing the width of the entity.\n- height: A float value representing the height of the entity.\n- velocity: A float value representing the velocity of the entity.\n- angle: A float value representing the angle of the entity's movement.\n- id: An integer representing the ID of the entity.\n- scale: A float value representing the scale of the entity.\n- maxSpeed: A float value representing the maximum speed of the entity.\n- pedestrianIgnoreTrafficLight: A boolean value indicating whether the pedestrian ignores traffic lights.\n- carIgnoreTrafficLight: A boolean value indicating whether the car ignores traffic lights.\n- isPredicted: A boolean value indicating whether the entity is predicted.\n- lastPosX: An integer representing the last X-coordinate of the entity's position.\n- lastPosY: An integer representing the last Y-coordinate of the entity's position.\n\n**Constructor**:\nThe constructor initializes the Entity object with the provided parameters:\n- id: An integer representing the unique identifier of the entity.\n- posX: A float value representing the X-coordinate of the entity's initial position.\n- posY: A float value representing the Y-coordinate of the entity's initial position.\n- velocity: A float value representing the initial velocity of the entity.\n- angle: A float value representing the initial angle of the entity's movement.\n\n**hasMoved**:\nThe hasMoved method determines whether the entity has moved based on its velocity. It calculates the distance traveled by the entity and returns True if the distance is greater than or equal to 0.1, indicating that the entity has moved. Otherwise, it returns False.\n\n**simulate**:\nThe simulate method is responsible for simulating the movement of the entity in the traffic system. It takes in the current state of the traffic system, including the traffic lights, entities, and streets, and updates the position and velocity of the entity based on the current state.\n\nThe method starts by initializing a boolean variable called \"accelerate\" to True. This variable will be used to determine if the entity should accelerate.\n\nNext, it checks the distance between the entity and each traffic light. If the distance is less than the radius of the traffic light and the traffic light is red, the velocity of the entity is reduced by multiplying it by 0.5. The \"accelerate\" variable is set to False to indicate that the entity should not accelerate.\n\nThen, it checks the distance between the entity and each other entity. If the distance is less than a certain threshold, the velocity of the entity is reduced by multiplying it by 0.8. The \"accelerate\" variable is set to False to indicate that the entity should not accelerate.\n\nAfter that, if the \"accelerate\" variable is True and the velocity of the entity is less than the maximum speed, the velocity is increased by 0.02.\n\nNext, the X and Y components of the acceleration are calculated based on the angle of the entity's movement.\n\nThen, the position of the entity is updated by adding the X component of the acceleration multiplied by the velocity to the current X-coordinate, and adding the Y component of the acceleration multiplied by the velocity to the current Y-coordinate.\n\nFinally, the position of the entity is checked to ensure that it stays within the boundaries of the traffic system. If the entity goes beyond the boundaries, its position is adjusted accordingly.\n\n**Note**:\n- The Entity class provides a basic representation of an entity in the traffic system.\n- The simulate method assumes the existence of the distance function, which is used to calculate the distance between two points.\n- The simulate method assumes the existence of the random module, which is used to generate random numbers.\n- The simulate method assumes the existence of the math module, which is used for mathematical calculations.\n- The simulate method assumes the existence of the trafficLights, entities, and streets variables, which represent the current state of the traffic system.\n- The simulate method assumes that the entity has attributes such as posX, posY, velocity, angle, maxSpeed, pedestrianIgnoreTrafficLight, and carIgnoreTrafficLight.\n- The simulate method assumes that the entity has methods such as distance and hasMoved.\n- The simulate method assumes that the entity has attributes such as lastPosX and lastPosY to keep track of the previous position of the entity.\n- The simulate method assumes that the entity has attributes such as entityID, label, width, height, id, scale, and isPredicted, which are not used in the given code snippet.\n\n**Output Example**: \nIf the entity's velocity is 0.5, the distance traveled by"
      ],
      "code_start_line": 20,
      "code_end_line": 85,
      "parent": null,
      "params": [],
      "have_return": true,
      "code_content": "class Entity:\n    entityID = 0\n    label = \"\";\n    posX = 0.0\n    posY = 0.0\n    width = 1.0\n    height = 1.0\n    velocity = 0.0\n    angle = 0.0\n    id = 0\n    scale = 1.0\n    maxSpeed = 2.0\n    pedestrianIgnoreTrafficLight = False\n    carIgnoreTrafficLight = False\n    isPredicted = False\n    lastPosX = 0\n    lastPosY = 0\n    def __init__(self, id, posX, posY, velocity, angle):\n        self.id = id\n        self.posX = posX\n        self.posY = posY\n        self.velocity = velocity\n        self.angle = angle\n\n    def hasMoved(self):\n        dist = self.velocity;\n        return dist >= 0.1\n\n    def simulate(self, trafficLights, entities, streets):\n        accelerate = True;\n        for l in trafficLights:\n            if distance(self.posX, self.posY, l.posX, l.posY) < l.radius:\n                if l.colour == l.RED:\n                    if random.uniform(0,1) > 0.3 and ((isinstance(self,Car) and not self.carIgnoreTrafficLight) or (isinstance(self, Pedestrian) and not self.pedestrianIgnoreTrafficLight)):\n                        self.velocity *= 0.5;\n                        accelerate = False\n        for e in entities:\n            collidable = not (isinstance(self,Pedestrian) and isinstance(e,Pedestrian))\n            if e != self and collidable:\n                nearEnough = 10\n                k = 0\n                while k<nearEnough:\n                    k += 0.1\n                    pXNew = self.posX + k * math.cos(self.angle)\n                    pYNew = self.posY + k * math.sin(self.angle)\n                    if distance(pXNew, pYNew, e.posX, e.posY) < nearEnough:\n                        self.velocity *= 0.8\n                        accelerate = False\n        if accelerate and self.velocity < self.maxSpeed:\n            self.velocity += 0.02\n        aX = math.cos(self.angle)\n        aY = math.sin(self.angle)\n        self.posX += aX * self.velocity\n        self.posY += aY * self.velocity\n        epsilon = 1\n        if self.posY < 0:\n            self.posY = 1000 - epsilon\n            #this.id = entityID++;\n        if self.posY > 1000:\n            self.posY = epsilon\n            #this.id = entityID++;\n        if self.posX < 0:\n            self.posX = 1000 - epsilon\n            #this.id = entityID++;\n        if self.posX > 1000:\n            self.posX = epsilon\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\trafficpredict.py/Pedestrian",
        "OpenNARS-for-Applications\\misc\\Python\\trafficpredict.py/Car"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\trafficpredict.py/distance",
        "OpenNARS-for-Applications\\misc\\Python\\trafficpredict.py/Pedestrian",
        "OpenNARS-for-Applications\\misc\\Python\\trafficpredict.py/Car",
        "OpenNARS-for-Applications\\misc\\Python\\trafficpredict.py/TrafficLight/simulate"
      ]
    },
    "hasMoved": {
      "type": "FunctionDef",
      "name": "hasMoved",
      "md_content": [
        "**hasMoved**: The function of hasMoved is to determine whether the entity has moved based on its velocity.\n\n**parameters**:\n- None\n\n**Code Description**:\nThe hasMoved function is a method that belongs to the Entity class. It calculates the distance traveled by the entity based on its velocity and determines whether it has moved. The function first assigns the value of the entity's velocity to the variable \"dist\". It then checks if the value of \"dist\" is greater than or equal to 0.1. If the condition is true, it means that the entity has moved and the function returns True. Otherwise, if the condition is false, it means that the entity has not moved and the function returns False.\n\n**Note**:\n- This function assumes that the velocity of the entity is already defined and accessible within the class.\n- The value of 0.1 used in the comparison can be adjusted according to the specific requirements of the application.\n\n**Output Example**:\n- If the velocity of the entity is 0.5, the function will return True, indicating that the entity has moved.\n- If the velocity of the entity is 0.05, the function will return False, indicating that the entity has not moved."
      ],
      "code_start_line": 44,
      "code_end_line": 46,
      "parent": "Entity",
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def hasMoved(self):\n        dist = self.velocity;\n        return dist >= 0.1\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "Pedestrian": {
      "type": "ClassDef",
      "name": "Pedestrian",
      "md_content": [
        "**Pedestrian**: The Pedestrian class represents a pedestrian entity in the traffic system. It is a subclass of the Entity class.\n\n**Attributes**:\n- prevX: The previous X-coordinate of the pedestrian.\n- prevY: The previous Y-coordinate of the pedestrian.\n- initialAngle: The initial angle of the pedestrian's movement.\n- maxSpeed: The maximum speed of the pedestrian.\n\n**Constructor**:\nThe constructor initializes the Pedestrian object with the provided parameters:\n- id: The unique identifier of the pedestrian.\n- posX: The X-coordinate of the pedestrian's initial position.\n- posY: The Y-coordinate of the pedestrian's initial position.\n- velocity: The initial velocity of the pedestrian.\n- angle: The initial angle of the pedestrian's movement.\n\n**simulate**:\nThe simulate method is responsible for simulating the movement of the pedestrian in the traffic system. It takes in the current state of the traffic system, including the traffic lights, entities, and streets, and updates the position and angle of the pedestrian based on the current state.\n\nThe method starts by calling the simulate method of the superclass Entity to perform common simulation tasks.\n\nNext, it updates the angle of the pedestrian's movement by adding a random value between -0.05 and 0.05 to the current angle.\n\nThen, it checks if the pedestrian is on a street that allows pedestrians. If not, it resets the angle, posX, and posY of the pedestrian to their previous values to prevent the pedestrian from going onto grass.\n\nFinally, it updates the prevX and prevY attributes of the pedestrian with the current posX and posY values.\n\n**Note**:\n- The Pedestrian class inherits attributes and methods from the Entity class.\n- The simulate method assumes the existence of the discretization variable, which is not defined in the given code snippet.\n\n"
      ],
      "code_start_line": 89,
      "code_end_line": 110,
      "parent": null,
      "params": [],
      "have_return": false,
      "code_content": "class Pedestrian(Entity):\n    prevX = 0\n    prevY = 0\n    def __init__(self, id, posX, posY, velocity, angle):\n        super().__init__(id, posX, posY, velocity, angle)\n        self.initialAngle = angle\n        self.maxSpeed = 1\n    def simulate(self, trafficLights, entities, streets):\n        super().simulate(trafficLights, entities, streets)\n        self.angle+=(random.uniform(0,1)*0.1-0.05)\n        #ok pedestrian, don't go on grass\n        forPedestrians = False\n        for street in streets:\n            if not street.forCarsOnly and self.posX > street.startX and self.posX < street.endX and self.posY > street.startY + discretization and self.posY < street.endY:\n                forPedestrians = True\n                break\n        if not forPedestrians:\n            self.angle = self.initialAngle\n            self.posX = self.prevX\n            self.posY = self.prevY\n        self.prevX = self.posX\n        self.prevY = self.posY\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\trafficpredict.py/Entity"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\trafficpredict.py/Entity",
        "OpenNARS-for-Applications\\misc\\Python\\trafficpredict.py/TrafficLight/simulate"
      ]
    },
    "Car": {
      "type": "ClassDef",
      "name": "Car",
      "md_content": [
        "**Car**: The function of Car is to represent a car entity in the traffic prediction system.\n\n**Attributes**:\n- maxSpeed: A float value representing the maximum speed of the car.\n\n**Code Description**:\nThe Car class is a subclass of the Entity class. It inherits all the attributes and methods from the Entity class and adds its own specific attributes and behavior.\n\nThe Car class has a single attribute called maxSpeed, which represents the maximum speed that a car can travel.\n\nThe Car class does not have any additional methods or behavior specific to cars. It inherits the methods from the Entity class, such as `hasMoved()` and `simulate()`, which are used to determine if the car has moved and to simulate its movement based on traffic lights, other entities, and streets.\n\n**Note**:\n- The maxSpeed attribute can be used to set the maximum speed of a car entity.\n- The Car class inherits all the attributes and methods from the Entity class, allowing it to have the same basic functionality as any other entity in the system.\n- The Car class can be used to represent cars in a traffic prediction system, where their movement and behavior can be simulated based on various factors such as traffic lights and other entities."
      ],
      "code_start_line": 112,
      "code_end_line": 113,
      "parent": null,
      "params": [],
      "have_return": false,
      "code_content": "class Car(Entity):\n    maxSpeed = 2\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\trafficpredict.py/Entity",
        "OpenNARS-for-Applications\\misc\\Python\\trafficpredict.py/entityname"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\trafficpredict.py/Entity"
      ]
    },
    "positionToTerm": {
      "type": "FunctionDef",
      "name": "positionToTerm",
      "md_content": [
        "**positionToTerm**: The function of positionToTerm is to convert the given X and Y coordinates into a string representation of their corresponding position terms.\n\n**parameters**:\n- X: The X coordinate value.\n- Y: The Y coordinate value.\n- discretization: The discretization value used to divide the coordinates.\n\n**Code Description**:\nThe `positionToTerm` function takes in three parameters: X, Y, and discretization. It first calculates the posX and posY values by dividing the X and Y coordinates by the discretization value and converting them to integers using the `int()` function. Then, it concatenates the posX and posY values with an underscore \"_\" in between, and returns the resulting string.\n\nThis function is used to convert continuous coordinates into discrete position terms. It is commonly used in applications that require discretization of spatial data, such as traffic prediction systems. By converting the coordinates into position terms, it becomes easier to represent and process the data in a discrete manner.\n\nIn the given code snippet, the `positionToTerm` function is called within the `informAboutEntity` method of the `OpenNARS-for-Applications\\misc\\Python\\trafficpredict.py` file. The `informAboutEntity` method takes in the `ent`, `minX`, and `minY` parameters. It first checks if the `useMultipleIDs` flag is set to True, and if not, sets the `id` variable to \"0\". Then, it calculates the `pos` value by calling the `positionToTerm` function with the `ent.posX-minX`, `ent.posY-minY`, and `discretization` parameters. The resulting `pos` value is then used to append a string to the `inputs` list and update the `input` variable.\n\nThe `informAboutEntity` method is responsible for informing the system about an entity by generating a corresponding input string. The `pos` value, obtained using the `positionToTerm` function, represents the position of the entity relative to the minimum X and Y coordinates. This information is used to construct the input string in the format \"(*, entityname(ent), pos). :|:\".\n\n**Note**: \n- The `positionToTerm` function assumes that the input coordinates and discretization value are valid and appropriate for the given application.\n- The `informAboutEntity` method assumes that the `ent`, `minX`, `minY`, and `discretization` parameters are correctly provided.\n- The `informAboutEntity` method assumes that the `entityname` function is defined and returns the name of the entity.\n\n**Output Example**:\nIf the `positionToTerm` function is called with X=10, Y=20, and discretization=5, the function will return the string \"2_4\"."
      ],
      "code_start_line": 116,
      "code_end_line": 119,
      "parent": null,
      "params": [
        "X",
        "Y",
        "discretization"
      ],
      "have_return": true,
      "code_content": "def positionToTerm(X, Y, discretization):\n    posX = int(X / discretization)\n    posY = int(Y / discretization)\n    return str(posX) + \"_\" + str(posY)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\trafficpredict.py/InformPredictionNar/informAboutEntity"
      ],
      "reference_who": []
    },
    "entityname": {
      "type": "FunctionDef",
      "name": "entityname",
      "md_content": [
        "**entityname**: The function of entityname is to generate a unique identifier for an entity.\n\n**parameters**:\n- ent: An object representing an entity.\n\n**Code Description**:\nThe `entityname` function takes an entity object as input and generates a unique identifier for that entity. \n\nFirst, the function checks if the given entity is an instance of the `Car` class. If it is, the variable `C` is assigned the value \"C\". Otherwise, `C` is assigned the value \"P\". This is done using the `isinstance()` function, which checks if the given object is an instance of a specified class.\n\nNext, the function appends the string representation of the entity's ID to `C`. The ID is obtained by accessing the `id` attribute of the entity object.\n\nFinally, the function returns the concatenated string `C+str(ent.id)`, which represents the unique identifier for the entity.\n\n**Note**:\n- The `entityname` function is used to generate a unique identifier for an entity object.\n- The function checks if the entity is an instance of the `Car` class and assigns the prefix \"C\" if it is, or \"P\" if it is not.\n- The unique identifier is obtained by concatenating the prefix with the string representation of the entity's ID.\n\n**Output Example**: \n- If `ent` is an instance of the `Car` class with ID 123, the function will return \"C123\".\n- If `ent` is not an instance of the `Car` class with ID 456, the function will return \"P456\"."
      ],
      "code_start_line": 123,
      "code_end_line": 125,
      "parent": null,
      "params": [
        "ent"
      ],
      "have_return": true,
      "code_content": "def entityname(ent):\n    C = \"C\" if isinstance(ent, Car) else \"P\"\n    return C+str(ent.id)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\trafficpredict.py/InformPredictionNar/informAboutEntity"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\trafficpredict.py/Car"
      ]
    },
    "InformPredictionNar": {
      "type": "ClassDef",
      "name": "InformPredictionNar",
      "md_content": [
        "**InformPredictionNar**: The function of InformPredictionNar is to inform the prediction system about entities and traffic lights in a given environment.\n\n**attributes**:\n- `lastInput`: A string representing the last input fed into the reasoner.\n- `input`: A string representing the current input to be fed into the reasoner.\n- `inputs`: A list of strings representing the inputs to be fed into the reasoner.\n\n**Code Description**:\nThe `InformPredictionNar` class provides methods to inform the prediction system about entities and traffic lights in a given environment. \n\nThe `informAboutEntity` method takes an entity object, `ent`, and the minimum x and y coordinates, `minX` and `minY`, as parameters. It converts the entity's position to a term using the `positionToTerm` function and appends the resulting string to the `inputs` list. It also appends the same string to the `input` string. This method is used to inform the prediction system about the presence of an entity in the environment.\n\nThe `informAboutTrafficLight` method takes a traffic light object, `light`, and the minimum x and y coordinates, `minX` and `minY`, as parameters. It determines the color of the traffic light based on the value of `light.colour` and appends the corresponding string to the `inputs` list. It also appends the same string to the `input` string. This method is used to inform the prediction system about the state of a traffic light.\n\nThe `Input` method takes a boolean parameter, `force`, which indicates whether the inputs should be forced to be fed into the reasoner. It checks if the current input is different from the last input or if `force` is True. If either condition is True, it iterates over the `inputs` list and adds each input to the reasoner using the `NAR.AddInput` function. It then updates the `lastInput` with the current `input` and clears the `input` and `inputs` lists. Finally, it returns a boolean value indicating whether any input was added to the reasoner. This method is used to feed the inputs to the reasoner.\n\n**Note**: \n- The `informAboutEntity` and `informAboutTrafficLight` methods are called to inform the prediction system about the entities and traffic lights in the environment.\n- The `Input` method is called to feed the inputs to the reasoner.\n\n**Output Example**: \nNone"
      ],
      "code_start_line": 127,
      "code_end_line": 157,
      "parent": null,
      "params": [],
      "have_return": true,
      "code_content": "class InformPredictionNar:\n    lastInput = \"\";\n    input = \"\";\n    inputs = []\n    #minX and minY define the lower end of the relative coordinate system\n    def informAboutEntity(self, ent, minX, minY):\n        id = str(ent.id)\n        useMultipleIDs = True\n        if not useMultipleIDs:\n            id = \"0\"\n        pos = positionToTerm(int(ent.posX-minX), int(ent.posY-minY), discretization);\n        self.inputs.append(\"(*,\"+entityname(ent) + \",\"+ pos + \"). :|:\");\n        self.input += self.inputs[-1]\n\n    def informAboutTrafficLight(self, light, minX, minY):\n        colour = \"green\" if light.colour == 0 else \"red\"\n        narsese = colour + \". :|:\" #\"<trafficLight --> [\"+colour+\"]>. :|:\"\n        self.inputs.append(narsese);\n        self.input+=narsese;\n\n    #param force are the inputs forced to be fed into the reasoner\n    def Input(self, force):\n        hadInput = False\n        if self.input != self.lastInput or force:\n            for inp in self.inputs:\n                NAR.AddInput(inp)\n                hadInput = True\n            self.lastInput = self.input\n        self.input = \"\";\n        self.inputs = []\n        return hadInput\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\trafficpredict.py/Camera"
      ],
      "reference_who": []
    },
    "informAboutEntity": {
      "type": "FunctionDef",
      "name": "informAboutEntity",
      "md_content": [
        "**informAboutEntity**: The function of informAboutEntity is to inform the system about an entity by generating a corresponding input string.\n\n**parameters**:\n- ent: An object representing the entity.\n- minX: The minimum X coordinate value.\n- minY: The minimum Y coordinate value.\n\n**Code Description**:\nThe `informAboutEntity` function is a method of the `InformPredictionNar` class in the `trafficpredict.py` file. It takes in three parameters: `ent`, `minX`, and `minY`. \n\nThe function first converts the `ent.id` value to a string and assigns it to the `id` variable. The `useMultipleIDs` flag is then checked, and if it is set to True, the `id` variable remains unchanged. However, if `useMultipleIDs` is False, the `id` variable is set to \"0\".\n\nNext, the function calls the `positionToTerm` function with the `ent.posX-minX`, `ent.posY-minY`, and `discretization` parameters to calculate the `pos` value. The `positionToTerm` function converts the given X and Y coordinates into a string representation of their corresponding position terms.\n\nThe `pos` value is then used to construct an input string in the format \"(*, entityname(ent), pos). :|:\". The `entityname` function is assumed to be defined and returns the name of the entity. The constructed input string is appended to the `inputs` list and also added to the `input` variable.\n\nThe `informAboutEntity` function is responsible for generating an input string that informs the system about the entity's position. By using the `positionToTerm` function, the continuous coordinates of the entity are converted into discrete position terms. This allows for easier representation and processing of the entity's position in a discrete manner.\n\n**Note**:\n- The `informAboutEntity` function assumes that the `ent`, `minX`, and `minY` parameters are correctly provided.\n- The `informAboutEntity` function assumes that the `positionToTerm` and `entityname` functions are defined and return the expected results.\n- The `informAboutEntity` function assumes that the `useMultipleIDs` flag is correctly set according to the desired behavior.\n\nThe `informAboutEntity` function is called within the `see` method of the `Camera` class in the `trafficpredict.py` file. The `see` method iterates over a list of entities and checks if their distance from the camera's position is within the view radius. If so, the `informAboutEntity` function is called to inform the system about the entity. The `minX` and `minY` values are passed as parameters to ensure the correct calculation of the entity's position.\n\nAdditionally, the `informAboutEntity` function is called within the `informAboutTrafficLight` method of the `Camera` class. This method is called when a traffic light is switched on. The `informAboutEntity` function is used to inform the system about the traffic light's position.\n\nThe `informAboutEntity` function is an essential part of the traffic prediction system, as it provides the necessary input to the system for accurate prediction and analysis of entity positions."
      ],
      "code_start_line": 132,
      "code_end_line": 139,
      "parent": "InformPredictionNar",
      "params": [
        "self",
        "ent",
        "minX",
        "minY"
      ],
      "have_return": false,
      "code_content": "    def informAboutEntity(self, ent, minX, minY):\n        id = str(ent.id)\n        useMultipleIDs = True\n        if not useMultipleIDs:\n            id = \"0\"\n        pos = positionToTerm(int(ent.posX-minX), int(ent.posY-minY), discretization);\n        self.inputs.append(\"(*,\"+entityname(ent) + \",\"+ pos + \"). :|:\");\n        self.input += self.inputs[-1]\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\trafficpredict.py/Camera/see"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\trafficpredict.py/positionToTerm",
        "OpenNARS-for-Applications\\misc\\Python\\trafficpredict.py/entityname"
      ]
    },
    "informAboutTrafficLight": {
      "type": "FunctionDef",
      "name": "informAboutTrafficLight",
      "md_content": [
        "**informAboutTrafficLight**: The function of informAboutTrafficLight is to inform the system about the state of a traffic light.\n\n**parameters**:\n- light: The traffic light object that contains information about the color of the light.\n- minX: The minimum x-coordinate of the traffic light's location.\n- minY: The minimum y-coordinate of the traffic light's location.\n\n**Code Description**:\nThe informAboutTrafficLight function takes in a traffic light object, its minimum x-coordinate, and its minimum y-coordinate as parameters. It first checks the color of the traffic light by comparing the value of light.colour. If the color is 0, it sets the variable \"colour\" to \"green\", otherwise it sets it to \"red\".\n\nNext, it constructs a Narsese string by concatenating the value of \"colour\" with \". :|:\". This string represents the state of the traffic light in a NARS (Non-Axiomatic Reasoning System) format.\n\nThe constructed Narsese string is then appended to the \"inputs\" list and added to the \"input\" string of the current object.\n\n**Note**: \n- The informAboutTrafficLight function is used to inform the system about the state of a traffic light. It is called by the \"see\" function of the \"Camera\" object in the project.\n- The \"see\" function iterates over a list of entities and checks if their distance from the camera is within the view radius. If so, it calls the informAboutEntity function of the \"informer\" object to inform the system about the entity.\n- After processing the entities, the \"see\" function also checks if any of the traffic lights have been switched on. If so, it calls the informAboutTrafficLight function of the \"informer\" object to inform the system about the traffic light.\n- The \"see\" function returns the \"input\" string of the \"informer\" object."
      ],
      "code_start_line": 141,
      "code_end_line": 145,
      "parent": "InformPredictionNar",
      "params": [
        "self",
        "light",
        "minX",
        "minY"
      ],
      "have_return": false,
      "code_content": "    def informAboutTrafficLight(self, light, minX, minY):\n        colour = \"green\" if light.colour == 0 else \"red\"\n        narsese = colour + \". :|:\" #\"<trafficLight --> [\"+colour+\"]>. :|:\"\n        self.inputs.append(narsese);\n        self.input+=narsese;\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\trafficpredict.py/Camera/see"
      ],
      "reference_who": []
    },
    "Input": {
      "type": "FunctionDef",
      "name": "Input",
      "md_content": [
        "**Input**: The function of Input is to process the input data and send it to the NAR (Non-Axiomatic Reasoning) system for further processing.\n\n**Parameters**:\n- force: A boolean value indicating whether to force the input to be processed, even if it is the same as the last input.\n\n**Code Description**:\nThe Input function is responsible for handling the input data and sending it to the NAR system for processing. It takes a boolean parameter \"force\" which determines whether the input should be processed even if it is the same as the last input.\n\nThe function starts by initializing a boolean variable \"hadInput\" to False. This variable will be used to keep track of whether any input was processed.\n\nNext, the function checks if the current input is different from the last input or if the \"force\" parameter is set to True. If either of these conditions is true, the function proceeds to process the input.\n\nInside the processing loop, the function iterates over each input in the \"inputs\" list. For each input, it calls the \"AddInput\" function from the NAR module and passes the input as a parameter. This function is responsible for sending the Narsese input to the NAR system and processing the output. If any input is processed, the \"hadInput\" variable is set to True.\n\nAfter processing all the inputs, the function updates the \"lastInput\" variable with the current input, indicating that it has been processed.\n\nFinally, the function resets the \"input\" variable to an empty string and clears the \"inputs\" list. It then returns the value of the \"hadInput\" variable, indicating whether any input was processed.\n\n**Note**:\n- The Input function assumes that the NAR system is already running and accessible.\n- The function relies on the \"AddInput\" function from the NAR module to process the input data.\n- The \"force\" parameter allows the user to override the check for the same input and force the processing of the input.\n- The function updates the \"lastInput\" variable to keep track of the last processed input.\n\n**Output Example**:\nIf the input data is different from the last input or the \"force\" parameter is set to True, the function will process the input and return True. Otherwise, it will return False."
      ],
      "code_start_line": 148,
      "code_end_line": 157,
      "parent": "InformPredictionNar",
      "params": [
        "self",
        "force"
      ],
      "have_return": true,
      "code_content": "    def Input(self, force):\n        hadInput = False\n        if self.input != self.lastInput or force:\n            for inp in self.inputs:\n                NAR.AddInput(inp)\n                hadInput = True\n            self.lastInput = self.input\n        self.input = \"\";\n        self.inputs = []\n        return hadInput\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\trafficpredict.py/Camera/see"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR.py/AddInput"
      ]
    },
    "Camera": {
      "type": "ClassDef",
      "name": "Camera",
      "md_content": [
        "**Camera**: The function of Camera is to represent a camera object in a traffic prediction system. It has attributes to store the position and view radius of the camera, and a method to detect entities and traffic lights within its view radius and inform the prediction system about them.\n\n**attributes**:\n- `radius`: An integer representing the radius of the camera.\n- `viewradius`: An integer representing the view radius of the camera.\n- `posX`: An integer representing the x-coordinate of the camera's position.\n- `posY`: An integer representing the y-coordinate of the camera's position.\n- `minX`: An integer representing the minimum x-coordinate of the camera's view area.\n- `minY`: An integer representing the minimum y-coordinate of the camera's view area.\n- `informer`: An instance of the InformPredictionNar class used to inform the prediction system.\n\n**Code Description**:\nThe `Camera` class represents a camera object in a traffic prediction system. It has an `__init__` method that initializes the camera's position and calculates the minimum x and y coordinates of its view area based on its radius. It also creates an instance of the `InformPredictionNar` class to inform the prediction system.\n\nThe `see` method takes three parameters: `entities`, `trafficLights`, and `force`. It iterates over the `entities` list and checks if each entity is within the camera's view radius. If an entity is within the view radius, it calls the `informAboutEntity` method of the `informer` object to inform the prediction system about the entity.\n\nNext, it iterates over the `trafficLights` list and checks if each traffic light is switched on. If a traffic light is switched on, it calls the `informAboutTrafficLight` method of the `informer` object to inform the prediction system about the traffic light. It then breaks out of the loop, as only one traffic light needs to be informed.\n\nFinally, it calls the `Input` method of the `informer` object with the `force` parameter and returns the result. The `Input` method feeds the inputs to the prediction system and returns a boolean value indicating whether any input was added.\n\n**Note**:\n- The `see` method is called to detect entities and traffic lights within the camera's view radius and inform the prediction system about them.\n- The `informer` object is used to inform the prediction system about entities and traffic lights.\n\n**Output Example**:\nTrue"
      ],
      "code_start_line": 159,
      "code_end_line": 177,
      "parent": null,
      "params": [],
      "have_return": true,
      "code_content": "class Camera:\n    radius=48\n    viewradius = 50\n    def __init__(self, posX, posY):\n        self.posX = posX;\n        self.posY = posY;\n        self.minX = posX-self.radius*2;\n        self.minY = posY-self.radius*2;\n        self.informer = InformPredictionNar();\n    \n    def see(self, entities, trafficLights, force):\n        for ent in entities:\n            if distance(self.posX, self.posY, ent.posX, ent.posY) < self.viewradius:\n                self.informer.informAboutEntity(ent, self.minX, self.minY)\n        for ent in trafficLights:\n            if ent.switched: # and distance(self.posX, self.posY, ent.posX, ent.posY) < self.viewradius:\n                self.informer.informAboutTrafficLight(ent, self.minX, self.minY)\n                break\n        return self.informer.Input(force);\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\trafficpredict.py/InformPredictionNar"
      ]
    },
    "see": {
      "type": "FunctionDef",
      "name": "see",
      "md_content": [
        "**see**: The function of see is to process the entities and traffic lights within the camera's view radius and inform the system about their presence.\n\n**parameters**:\n- entities: A list of objects representing entities.\n- trafficLights: A list of objects representing traffic lights.\n- force: A boolean value indicating whether to force the input to be processed, even if it is the same as the last input.\n\n**Code Description**:\nThe `see` function is a method of the `Camera` class in the `trafficpredict.py` file. It takes in three parameters: `entities`, `trafficLights`, and `force`.\n\nThe function first iterates over the `entities` list and checks if the distance between the camera's position and each entity's position is within the camera's view radius. If the distance is within the view radius, the function calls the `informAboutEntity` function of the `informer` object to inform the system about the entity's position. The `minX` and `minY` values are passed as parameters to ensure the correct calculation of the entity's position.\n\nNext, the function iterates over the `trafficLights` list and checks if any of the traffic lights have been switched on. If a traffic light is switched on, the function calls the `informAboutTrafficLight` function of the `informer` object to inform the system about the traffic light's state. The `minX` and `minY` values are passed as parameters to ensure the correct calculation of the traffic light's position.\n\nAfter processing the entities and traffic lights, the function returns the result of calling the `Input` function of the `informer` object with the `force` parameter.\n\nThe `see` function plays a crucial role in the traffic prediction system. It processes the entities and traffic lights within the camera's view radius and generates the necessary input for the system to make accurate predictions and analysis.\n\n**Note**:\n- The `see` function assumes that the `entities` and `trafficLights` parameters are correctly provided as lists of objects.\n- The `see` function relies on the `informAboutEntity` and `informAboutTrafficLight` functions of the `informer` object to inform the system about the entities and traffic lights.\n- The `see` function also relies on the `Input` function of the `informer` object to process the generated input and send it to the NAR system.\n- The `see` function assumes that the `informer` object is correctly initialized and accessible.\n\n**Output Example**:\nIf the `entities` list contains two entities within the camera's view radius and one traffic light is switched on, the `see` function will generate the corresponding input strings and return the result of calling the `Input` function."
      ],
      "code_start_line": 169,
      "code_end_line": 177,
      "parent": "Camera",
      "params": [
        "self",
        "entities",
        "trafficLights",
        "force"
      ],
      "have_return": true,
      "code_content": "    def see(self, entities, trafficLights, force):\n        for ent in entities:\n            if distance(self.posX, self.posY, ent.posX, ent.posY) < self.viewradius:\n                self.informer.informAboutEntity(ent, self.minX, self.minY)\n        for ent in trafficLights:\n            if ent.switched: # and distance(self.posX, self.posY, ent.posX, ent.posY) < self.viewradius:\n                self.informer.informAboutTrafficLight(ent, self.minX, self.minY)\n                break\n        return self.informer.Input(force);\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\trafficpredict.py/cycle"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\trafficpredict.py/distance",
        "OpenNARS-for-Applications\\misc\\Python\\trafficpredict.py/InformPredictionNar/informAboutEntity",
        "OpenNARS-for-Applications\\misc\\Python\\trafficpredict.py/InformPredictionNar/informAboutTrafficLight",
        "OpenNARS-for-Applications\\misc\\Python\\trafficpredict.py/InformPredictionNar/Input"
      ]
    },
    "TrafficLight": {
      "type": "ClassDef",
      "name": "TrafficLight",
      "md_content": [
        "**TrafficLight**: The function of TrafficLight is to simulate the behavior of a traffic light, including changing its color at regular intervals.\n\n**attributes**:\n- id: The unique identifier of the traffic light.\n- radius: The radius of the traffic light.\n- posX: The X-coordinate position of the traffic light.\n- posY: The Y-coordinate position of the traffic light.\n- colour: The current color of the traffic light.\n\n**Code Description**:\nThe TrafficLight class represents a traffic light in a simulation. It has several attributes, including id, radius, positionX, positionY, and colour. The id is a unique identifier for the traffic light, while the radius determines the size of the traffic light. The positionX and positionY attributes specify the coordinates of the traffic light on a two-dimensional plane. The colour attribute represents the current color of the traffic light.\n\nThe class has a constructor method (__init__) that initializes the attributes of the traffic light object. It takes five parameters: id, radius, positionX, positionY, and colour. These parameters are used to set the corresponding attributes of the object.\n\nThe simulate method is the main function of the TrafficLight class. It simulates the behavior of the traffic light by changing its color at regular intervals. The method takes three parameters: trafficLights, entities, and streets. These parameters represent the other objects in the simulation that the traffic light interacts with.\n\nInside the simulate method, the switched attribute is set to False initially. This attribute keeps track of whether the traffic light has switched its color during the simulation.\n\nThe method then checks if the current time (t) is divisible by 200. If it is, the color of the traffic light is changed by incrementing the colour attribute by 1 and taking the modulo 2. This ensures that the color alternates between 0 (GREEN) and 1 (RED). The switched attribute is set to True to indicate that the traffic light has switched its color.\n\nFinally, the t attribute is incremented by 1 to keep track of the simulation time.\n\n**Note**:\n- The TrafficLight class represents a single traffic light in a simulation.\n- The simulate method is called periodically to update the state of the traffic light.\n- The color of the traffic light alternates between GREEN and RED every 200 simulation time units.\n- The switched attribute can be used to determine if the traffic light has switched its color during the simulation."
      ],
      "code_start_line": 179,
      "code_end_line": 195,
      "parent": null,
      "params": [],
      "have_return": false,
      "code_content": "class TrafficLight:\n    GREEN = 0\n    RED = 1\n    t = 1\n    switched = False\n    def __init__(self, id, radius, positionX, positionY, colour):\n        self.radius = radius\n        self.id = id\n        self.posX = positionX\n        self.posY = positionY\n        self.colour = colour\n    def simulate(self, trafficLights, entities, streets):\n        self.switched = False\n        if self.t % 200 == 0:\n            self.colour = (self.colour + 1) % 2;\n            self.switched = True\n        self.t+=1\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "__init__": {
      "type": "FunctionDef",
      "name": "__init__",
      "md_content": [
        "**__init__**: The function of __init__ is to initialize the TrafficLight object with the provided parameters.\n\n**parameters**:\n- id: An identifier for the TrafficLight object.\n- radius: The radius of the TrafficLight.\n- positionX: The X-coordinate of the TrafficLight's position.\n- positionY: The Y-coordinate of the TrafficLight's position.\n- colour: The color of the TrafficLight.\n\n**Code Description**:\nThe __init__ function is a constructor method that is called when a new instance of the TrafficLight class is created. It takes in the parameters id, radius, positionX, positionY, and colour, and assigns them to the corresponding attributes of the TrafficLight object.\n\nThe id parameter is used to uniquely identify the TrafficLight object. The radius parameter specifies the size of the TrafficLight. The positionX and positionY parameters determine the position of the TrafficLight on a two-dimensional plane. The colour parameter specifies the color of the TrafficLight.\n\nInside the function, the provided parameters are assigned to the corresponding attributes of the TrafficLight object using the self keyword. The self keyword refers to the instance of the class and allows access to its attributes and methods.\n\n**Note**:\n- Make sure to provide valid values for all the parameters when creating a new instance of the TrafficLight class.\n- The id, radius, positionX, positionY, and colour attributes can be accessed and modified using dot notation (e.g., traffic_light.id, traffic_light.radius)."
      ],
      "code_start_line": 184,
      "code_end_line": 189,
      "parent": "TrafficLight",
      "params": [
        "self",
        "id",
        "radius",
        "positionX",
        "positionY",
        "colour"
      ],
      "have_return": false,
      "code_content": "    def __init__(self, id, radius, positionX, positionY, colour):\n        self.radius = radius\n        self.id = id\n        self.posX = positionX\n        self.posY = positionY\n        self.colour = colour\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "simulate": {
      "type": "FunctionDef",
      "name": "simulate",
      "md_content": [
        "**simulate**: The function of simulate is to simulate the movement of an entity (such as a car or pedestrian) in the traffic system.\n\n**parameters**:\n- trafficLights: A list of traffic light objects in the system.\n- entities: A list of entity objects (cars and pedestrians) in the system.\n- streets: A list of street objects in the system.\n\n**Code Description**:\nThe simulate function is responsible for simulating the movement of an entity in the traffic system. It takes in the current state of the traffic system, including the traffic lights, entities, and streets, and updates the position and velocity of the entity based on the current state.\n\nThe function starts by initializing a boolean variable called \"switched\" to False. This variable will be used to keep track of whether the traffic light has switched its color. \n\nNext, the function checks if the current time step (t) is a multiple of 200. If it is, the color of the traffic light is switched by incrementing the \"colour\" variable by 1 and taking the modulo 2. This ensures that the traffic light alternates between two colors. The \"switched\" variable is set to True to indicate that the traffic light has switched its color.\n\nFinally, the time step (t) is incremented by 1.\n\n**Note**: \n- The simulate function assumes that the entity has a \"t\" attribute to keep track of the current time step.\n- The simulate function assumes that the entity has a \"colour\" attribute to store the current color of the traffic light.\n- The simulate function assumes that the entity has a \"t\" attribute to keep track of the current time step.\n- The simulate function assumes that the entity has a \"t\" attribute to keep track of the current time step."
      ],
      "code_start_line": 190,
      "code_end_line": 195,
      "parent": "TrafficLight",
      "params": [
        "self",
        "trafficLights",
        "entities",
        "streets"
      ],
      "have_return": false,
      "code_content": "    def simulate(self, trafficLights, entities, streets):\n        self.switched = False\n        if self.t % 200 == 0:\n            self.colour = (self.colour + 1) % 2;\n            self.switched = True\n        self.t+=1\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\trafficpredict.py/Entity",
        "OpenNARS-for-Applications\\misc\\Python\\trafficpredict.py/Pedestrian",
        "OpenNARS-for-Applications\\misc\\Python\\trafficpredict.py/cycle"
      ],
      "reference_who": []
    },
    "cycle": {
      "type": "FunctionDef",
      "name": "cycle",
      "md_content": [
        "**cycle**: The function of cycle is to iterate over a list of cameras, call the `see` function of each camera, and then simulate the movement of entities and traffic lights.\n\n**parameters**:\n- None\n\n**Code Description**:\nThe `cycle` function is a top-level function that does not take any parameters. It begins by initializing a boolean variable called `hadInput` to False.\n\nNext, it enters a loop that iterates over each `c` in the `cameras` list. Within this loop, the variable `force` is set to True.\n\nThe code then calls the `see` function of the current camera `c` and passes in the `entities`, `trafficLights`, and `force` parameters. This function processes the entities and traffic lights within the camera's view radius and informs the system about their presence.\n\nAfter processing the entities and traffic lights for the current camera, the code enters another loop that iterates over each `e` in the concatenation of the `entities` and `trafficLights` lists. Within this loop, the `simulate` function of the current entity `e` is called, passing in the `trafficLights`, `entities`, and `streets` parameters. This function simulates the movement of the entity in the traffic system.\n\nThe `cycle` function does not return any value.\n\n**Note**:\n- The `cycle` function assumes that the `cameras`, `entities`, `trafficLights`, and `streets` variables are correctly initialized and accessible.\n- The `cycle` function relies on the `see` function of the `Camera` class to process the entities and traffic lights within the camera's view radius.\n- The `cycle` function relies on the `simulate` function of the `Entity` class to simulate the movement of entities in the traffic system.\n- The `cycle` function assumes that the `see` and `simulate` functions are correctly implemented and accessible.\n- The `cycle` function assumes that the `entities`, `trafficLights`, and `streets` variables are correctly provided as lists of objects."
      ],
      "code_start_line": 231,
      "code_end_line": 238,
      "parent": null,
      "params": [],
      "have_return": false,
      "code_content": "def cycle():\n    hadInput = False\n    for c in cameras:\n        force = True\n        #hadInput = hadInput or c.see(entities, trafficLights, force)\n        c.see(entities, trafficLights, force)\n    for e in entities + trafficLights:\n        e.simulate(trafficLights, entities, streets)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\trafficpredict.py/Camera/see",
        "OpenNARS-for-Applications\\misc\\Python\\trafficpredict.py/TrafficLight/simulate"
      ]
    },
    "streetcolor": {
      "type": "FunctionDef",
      "name": "streetcolor",
      "md_content": [
        "**streetcolor**: The function of streetcolor is to determine the color of a street based on the given coordinates (x, y) and the position of a camera.\n\n**parameters**:\n- x: The x-coordinate of the point on the street.\n- y: The y-coordinate of the point on the street.\n\n**Code Description**:\nThe streetcolor function takes in two parameters, x and y, which represent the coordinates of a point on a street. The function iterates through a list of streets and checks if the given coordinates (x, y) fall within the range of each street's start and end coordinates. If the coordinates fall within a street's range, the function proceeds to check the distance between the given coordinates and the position of the first camera in a list called \"cameras\".\n\nTo calculate the distance between the given coordinates and the camera's position, the function calls the distance function from the trafficpredict.py module. The distance function calculates the maximum absolute difference between the x-coordinates and y-coordinates of two given points. In this case, it calculates the distance between the given coordinates (x, y) and the camera's position (cameras[0].posX, cameras[0].posY).\n\nIf the calculated distance is less than the view radius of the camera (cameras[0].viewradius), the function returns the color code \"\\x1b[47m\", which represents a specific background color. Otherwise, if the distance is greater than or equal to the view radius, the function returns the color code \"\\x1b[43m\", which represents a different background color. If the given coordinates do not fall within any street's range, the function returns an empty string.\n\nThe streetcolor function is designed to be used in a traffic prediction application. It helps determine the color of a street based on the given coordinates and the position of a camera. This information can be used to visualize the proximity of a point on the street to the camera's view radius. The different colors represent different levels of proximity, with the color \"\\x1b[47m\" indicating a closer distance and the color \"\\x1b[43m\" indicating a farther distance.\n\n**Note**:\n- The streetcolor function assumes that the streets, cameras, and their properties (startX, endX, startY, endY, posX, posY, viewradius) are defined and accessible within the scope of the function.\n- The function relies on the distance function from the trafficpredict.py module to calculate the distance between the given coordinates and the camera's position.\n- The color codes \"\\x1b[47m\" and \"\\x1b[43m\" are ANSI escape codes that represent specific background colors. These codes may not be supported or displayed correctly in all environments.\n- The function returns an empty string if the given coordinates do not fall within any street's range.\n\n**Output Example**:\nIf the input parameters are x=3 and y=5, and the distance between these coordinates and the camera's position is less than the view radius, the streetcolor function will return \"\\x1b[47m\", indicating a closer proximity to the camera."
      ],
      "code_start_line": 240,
      "code_end_line": 246,
      "parent": null,
      "params": [
        "x",
        "y"
      ],
      "have_return": true,
      "code_content": "def streetcolor(x,y):\n    for street in streets:\n        if x>=street.startX and x<=street.endX and y>=street.startY and y<=street.endY:\n            if distance(x, y, cameras[0].posX, cameras[0].posY) < cameras[0].viewradius:\n                return \"\\x1b[47m\"\n            return \"\\x1b[43m\" \n    return \"\"\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\trafficpredict.py/distance"
      ]
    },
    "drawIDtoDirectionIndicator": {
      "type": "FunctionDef",
      "name": "drawIDtoDirectionIndicator",
      "md_content": [
        "**drawIDtoDirectionIndicator**: The function of drawIDtoDirectionIndicator is to convert a given drawid into a corresponding direction indicator symbol.\n\n**parameters**:\n- drawid: A string representing the drawid.\n\n**Code Description**:\nThe drawIDtoDirectionIndicator function takes a drawid as input and converts it into a corresponding direction indicator symbol. It uses a series of if statements to check the value of drawid and assigns the appropriate symbol based on the following conditions:\n- If drawid is equal to \"1\", the function assigns the symbol \"^\" to drawid.\n- If drawid is equal to \"2\", the function assigns the symbol \"v\" to drawid.\n- If drawid is equal to \"3\", the function assigns the symbol \">\" to drawid.\n- If drawid is equal to \"4\", the function assigns the symbol \"<\" to drawid.\n\nFinally, the function returns the updated value of drawid.\n\n**Note**:\n- The drawid parameter should be a string representing the drawid.\n- The function assumes that the drawid will always be one of the values \"1\", \"2\", \"3\", or \"4\". If the drawid is not one of these values, the function will not assign any symbol and the original drawid value will be returned.\n\n**Output Example**:\n- Example 1:\n  - Input: drawid = \"1\"\n  - Output: \"^\"\n- Example 2:\n  - Input: drawid = \"3\"\n  - Output: \">\""
      ],
      "code_start_line": 248,
      "code_end_line": 257,
      "parent": null,
      "params": [
        "drawid"
      ],
      "have_return": true,
      "code_content": "def drawIDtoDirectionIndicator(drawid):\n    if drawid == \"1\":\n        drawid = \"^\"\n    if drawid == \"2\":\n        drawid = \"v\"\n    if drawid == \"3\":\n        drawid = \">\"\n    if drawid == \"4\":\n        drawid = \"<\"\n    return drawid\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    }
  },
  "OpenNARS-for-Applications\\misc\\Python\\vision_to_narsese.py": {
    "BoundingBoxFromBBStr": {
      "type": "FunctionDef",
      "name": "BoundingBoxFromBBStr",
      "md_content": [
        "**BoundingBoxFromBBStr**: The function of BoundingBoxFromBBStr is to convert a string representation of bounding box coordinates into a dictionary format.\n\n**parameters**:\n- BBStr: A string representing the bounding box coordinates in the format \"label1:value1 label2:value2 ...\".\n\n**Code Description**:\nThe BoundingBoxFromBBStr function takes a string representation of bounding box coordinates as input. It first initializes an empty dictionary called M. Then, it processes the input string by removing unnecessary characters such as parentheses, colons, and spaces. The processed string is split into a list of label-value pairs.\n\nNext, the function iterates over the list of label-value pairs using a for loop. For each pair, it extracts the label and converts the corresponding value to a float. The label and value are then added to the dictionary M, with the label as the key and the value as the corresponding value.\n\nFinally, the function returns the resulting dictionary M, which represents the bounding box coordinates in a more structured format.\n\nThis function is called by the LineToNarsese function in the vision_to_narsese.py file. In the LineToNarsese function, the BoundingBoxFromBBStr function is used to convert a string representation of a bounding box into a dictionary format. The resulting dictionary is then further processed to obtain the discretized location, which is used to generate a Narsese statement.\n\n**Note**: \n- The input string should be in the format \"label1:value1 label2:value2 ...\".\n- The labels should not contain any special characters or spaces.\n- The values should be numeric.\n\n**Output Example**:\nIf the input BBStr is \"label1:0.5 label2:0.8\", the function will return the following dictionary:\n{\n  \"label1\": 0.5,\n  \"label2\": 0.8\n}"
      ],
      "code_start_line": 38,
      "code_end_line": 45,
      "parent": null,
      "params": [
        "BBStr"
      ],
      "have_return": true,
      "code_content": "def BoundingBoxFromBBStr(BBStr):\n    M = {}\n    BBlist = ' '.join(BBStr.strip().replace('(','').replace(')','').replace(':','').split()).split(' ')\n    for i in range(0,len(BBlist),2):\n        label = BBlist[i]\n        value = float(BBlist[i+1])\n        M[label] = value\n    return M\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\vision_to_narsese.py/LineToNarsese"
      ],
      "reference_who": []
    },
    "LocationFromDetection": {
      "type": "FunctionDef",
      "name": "LocationFromDetection",
      "md_content": [
        "**LocationFromDetection**: The function of LocationFromDetection is to calculate the location coordinates (x, y) based on the given bounding box.\n\n**Parameters**:\n- BB: A dictionary representing the bounding box, containing the following keys:\n  - \"left_x\": The x-coordinate of the left side of the bounding box.\n  - \"top_y\": The y-coordinate of the top side of the bounding box.\n  - \"width\": The width of the bounding box.\n  - \"height\": The height of the bounding box.\n\n**Code Description**:\nThe LocationFromDetection function takes a bounding box as input and calculates the location coordinates (x, y) based on the given bounding box. It creates an empty dictionary called \"Location\" to store the calculated coordinates. \n\nThe x-coordinate is calculated by adding the left_x coordinate of the bounding box to half of its width. Similarly, the y-coordinate is calculated by adding the top_y coordinate of the bounding box to half of its height. The calculated coordinates are then stored in the \"Location\" dictionary.\n\nFinally, the function returns the \"Location\" dictionary containing the calculated coordinates.\n\nThis function is called by the LineToNarsese function in the vision_to_narsese.py file. The LineToNarsese function splits a line into label, percent, and bounding box string. It then calls the LocationFromDetection function to calculate the location coordinates from the bounding box string. The calculated location is further processed and printed using other functions.\n\n**Note**: \n- The input bounding box dictionary should contain the keys \"left_x\", \"top_y\", \"width\", and \"height\".\n- The function assumes that the bounding box coordinates are in a valid format.\n- The function does not perform any error handling for invalid inputs.\n\n**Output Example**:\nIf the input bounding box is:\nBB = {\"left_x\": 10, \"top_y\": 20, \"width\": 30, \"height\": 40}\n\nThe function will return the following dictionary:\nLocation = {\"x\": 25, \"y\": 40}"
      ],
      "code_start_line": 47,
      "code_end_line": 51,
      "parent": null,
      "params": [
        "BB"
      ],
      "have_return": true,
      "code_content": "def LocationFromDetection(BB):\n    Location = {}\n    Location['x'] = BB[\"left_x\"]+BB[\"width\"]/2\n    Location['y'] = BB[\"top_y\"]+BB[\"height\"]/2\n    return Location\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\vision_to_narsese.py/LineToNarsese"
      ],
      "reference_who": []
    },
    "DiscretizeValue": {
      "type": "FunctionDef",
      "name": "DiscretizeValue",
      "md_content": [
        "**DiscretizeValue**: The function of DiscretizeValue is to discretize a given value based on a maximum value.\n\n**Parameters**:\n- Value: The value to be discretized.\n- MaxValue: The maximum value used for discretization.\n\n**Code Description**:\nThe DiscretizeValue function takes in a value and a maximum value as parameters. It then compares the value with one-third of the maximum value and two-thirds of the maximum value to determine the discretized value. If the value is smaller than one-third of the maximum value, the function returns \"smaller\". If the value is smaller than two-thirds of the maximum value, the function returns \"equal\". Otherwise, it returns \"larger\".\n\nThis function is used to categorize a value into one of three categories: \"smaller\", \"equal\", or \"larger\" based on the given maximum value. It is commonly used in scenarios where a continuous value needs to be represented in a discrete manner.\n\nIn the project, this function is called by the `DiscretizedLocationFromLocation` function in the `vision_to_narsese.py` file. The `DiscretizedLocationFromLocation` function takes a location as input and discretizes its x and y coordinates using the `DiscretizeValue` function. The discretized coordinates are then stored in a dictionary and returned as the output.\n\n**Note**:\n- The `DiscretizeValue` function assumes that the maximum value is a positive number.\n- The function does not handle cases where the value is equal to the maximum value."
      ],
      "code_start_line": 53,
      "code_end_line": 58,
      "parent": null,
      "params": [
        "Value",
        "MaxValue"
      ],
      "have_return": true,
      "code_content": "def DiscretizeValue(Value, MaxValue):\n    if Value < MaxValue/3.0:\n        return \"smaller\"\n    if Value < MaxValue*(2.0/3.0):\n        return \"equal\"\n    return \"larger\"\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\vision_to_narsese.py/DiscretizedLocationFromLocation"
      ],
      "reference_who": []
    },
    "DiscretizedLocationFromLocation": {
      "type": "FunctionDef",
      "name": "DiscretizedLocationFromLocation",
      "md_content": [
        "**DiscretizedLocationFromLocation**: The function of DiscretizedLocationFromLocation is to discretize the x and y coordinates of a given location based on the maximum values of ImgSizeX and ImgSizeY.\n\n**Parameters**:\n- Location: A dictionary representing the location with 'x' and 'y' coordinates.\n\n**Code Description**:\nThe DiscretizedLocationFromLocation function takes in a location as a parameter and discretizes its x and y coordinates using the DiscretizeValue function. It creates an empty dictionary called DiscretizedLocation. The x coordinate of the location is discretized by calling the DiscretizeValue function with the 'x' coordinate of the location and the maximum value ImgSizeX. The result is stored in the DiscretizedLocation dictionary with the key 'x'. Similarly, the y coordinate of the location is discretized by calling the DiscretizeValue function with the 'y' coordinate of the location and the maximum value ImgSizeY. The result is stored in the DiscretizedLocation dictionary with the key 'y'. Finally, the DiscretizedLocation dictionary is returned as the output of the function.\n\nThe DiscretizedLocationFromLocation function is used in the project to convert a continuous location into a discrete representation. This can be useful in various applications where discrete values are required, such as image processing or computer vision tasks. By discretizing the location coordinates, it becomes easier to perform further analysis or processing on the data.\n\n**Note**:\n- The DiscretizedLocationFromLocation function assumes that the maximum values ImgSizeX and ImgSizeY are positive numbers.\n- The function relies on the DiscretizeValue function to perform the actual discretization of the coordinates.\n\n**Output Example**:\nIf the input location is {'x': 0.5, 'y': 0.8}, and the maximum values ImgSizeX and ImgSizeY are 1.0, the function will return the following dictionary:\n{'x': 'equal', 'y': 'larger'}"
      ],
      "code_start_line": 60,
      "code_end_line": 64,
      "parent": null,
      "params": [
        "Location"
      ],
      "have_return": true,
      "code_content": "def DiscretizedLocationFromLocation(Location):\n    DiscretizedLocation = {}\n    DiscretizedLocation['x'] = DiscretizeValue(Location['x'], ImgSizeX)\n    DiscretizedLocation['y'] = DiscretizeValue(Location['y'], ImgSizeY)\n    return DiscretizedLocation\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\vision_to_narsese.py/LineToNarsese"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\vision_to_narsese.py/DiscretizeValue"
      ]
    },
    "Narsesefy": {
      "type": "FunctionDef",
      "name": "Narsesefy",
      "md_content": [
        "**Narsesefy**: The function of Narsesefy is to convert a given label, percentage, and discretized location into a Narsese statement.\n\n**Parameters**:\n- `label`: A string representing the label of the object.\n- `percent`: A float representing the percentage confidence of the object detection.\n- `DiscretizedLocation`: A dictionary containing the discretized location of the object along different axes.\n\n**Code Description**:\nThe `Narsesefy` function takes in a label, percentage, and discretized location as input parameters. It then iterates over the `EncodeAxes` list and constructs a string representation of the location by concatenating the discretized location values with their corresponding axis labels. The constructed location string is stored in the `Loc` variable.\n\nFinally, the function returns a Narsese statement by combining the label, location, and percentage information. The label is enclosed in angle brackets, the location is enclosed in square brackets, and the percentage is included in the Narsese statement as a confidence value. The Narsese statement is formatted as \"<label --> [location]>. :|: {1.0 confidence}\".\n\n**Note**: \n- The `EncodeAxes` list is not defined within the `Narsesefy` function. It should be defined before calling the function to ensure proper execution.\n- The `DiscretizedLocation` parameter is expected to be a dictionary with keys corresponding to the axes defined in the `EncodeAxes` list.\n\n**Output Example**:\nIf we call the `Narsesefy` function with the following parameters:\n- `label`: \"cat\"\n- `percent`: 85.0\n- `DiscretizedLocation`: {\"x\": 2, \"y\": 3, \"z\": 1}\n\nThe function will return the following Narsese statement:\n\"<cat --> [2X 3Y 1Z]>. :|: {1.0 0.85}\""
      ],
      "code_start_line": 67,
      "code_end_line": 71,
      "parent": null,
      "params": [
        "label",
        "percent",
        "DiscretizedLocation"
      ],
      "have_return": true,
      "code_content": "def Narsesefy(label, percent, DiscretizedLocation):\n    Loc = \"\"\n    for axis in EncodeAxes:\n        Loc = Loc + \" \" + DiscretizedLocation[axis] + axis.upper()\n    return \"<\" + label + \" --> [\" + Loc.strip() + \"]>. :|: {1.0 \" + str(min(99.0,percent)/100.0) + \"}\"\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Python\\vision_to_narsese.py/LineToNarsese"
      ],
      "reference_who": []
    },
    "LineToNarsese": {
      "type": "FunctionDef",
      "name": "LineToNarsese",
      "md_content": [
        "**LineToNarsese**: The function of LineToNarsese is to convert a given line into a Narsese statement by extracting the label, percentage, and discretized location from the line and passing them to the Narsesefy function.\n\n**parameters**:\n- `line`: A string representing a line of input containing the label, percentage, and bounding box information.\n\n**Code Description**:\nThe LineToNarsese function takes a line of input as a parameter. It first splits the line based on the \"%\" character to separate the label and bounding box information. The label and percentage are extracted from the first part of the split line by splitting it based on the \":\" character. The label is obtained by taking the first element of the resulting split, and the percentage is obtained by converting the second element to a float after removing any leading or trailing whitespace.\n\nThe BoundingBoxFromBBStr function is then called with the second part of the split line (representing the bounding box information) as an argument. This function converts the bounding box string into a dictionary format.\n\nThe LocationFromDetection function is called with the resulting dictionary from BoundingBoxFromBBStr as an argument. This function calculates the location coordinates (x, y) based on the given bounding box.\n\nThe DiscretizedLocationFromLocation function is called with the resulting location dictionary as an argument. This function discretizes the x and y coordinates of the location based on the maximum values of ImgSizeX and ImgSizeY.\n\nFinally, the Narsesefy function is called with the label, percentage, and discretized location as arguments. This function converts the label, percentage, and discretized location into a Narsese statement.\n\nThe resulting Narsese statement is printed as the output of the LineToNarsese function.\n\n**Note**: \n- The input line should be in the format \"label:percent%bounding_box\".\n- The label should not contain any special characters or spaces.\n- The percentage should be a numeric value.\n- The bounding box string should be in a valid format.\n- The maximum values ImgSizeX and ImgSizeY should be defined before calling the LineToNarsese function.\n\n**Example**:\nIf we call the LineToNarsese function with the following line:\n```\n\"cat:85.0%label1:0.5 label2:0.8\"\n```\nThe function will convert the line into a Narsese statement and print it as follows:\n```\n\"<cat --> [equalX largerY]>. :|: {1.0 0.85}\"\n```"
      ],
      "code_start_line": 73,
      "code_end_line": 78,
      "parent": null,
      "params": [
        "line"
      ],
      "have_return": false,
      "code_content": "def LineToNarsese(line):\n    labelPercent_BB = line.split(\"%\")\n    label = labelPercent_BB[0].split(\":\")[0]\n    percent = float(labelPercent_BB[0].split(\":\")[1].strip())\n    DiscretizedLocation = DiscretizedLocationFromLocation(LocationFromDetection(BoundingBoxFromBBStr(labelPercent_BB[1])))\n    print(Narsesefy(label, percent, DiscretizedLocation))\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\vision_to_narsese.py/BoundingBoxFromBBStr",
        "OpenNARS-for-Applications\\misc\\Python\\vision_to_narsese.py/LocationFromDetection",
        "OpenNARS-for-Applications\\misc\\Python\\vision_to_narsese.py/DiscretizedLocationFromLocation",
        "OpenNARS-for-Applications\\misc\\Python\\vision_to_narsese.py/Narsesefy"
      ]
    }
  },
  "OpenNARS-for-Applications\\misc\\ROS\\ona-channels\\ona_darknet.py": {
    "detectionToNarseseStatementsList": {
      "type": "FunctionDef",
      "name": "detectionToNarseseStatementsList",
      "md_content": [
        "**detectionToNarseseStatementsList**: The function of detectionToNarseseStatementsList is to convert a detection object into a list of Narsese statements.\n\n**parameters**:\n- detection: A dictionary representing a detection object. It should contain the following keys:\n  - \"label\": A string representing the label or class of the detected object.\n  - \"confidence\": A float representing the confidence level of the detection.\n  - \"boxes\": A list containing the coordinates and dimensions of the bounding box. It should have four elements in the following order: [x, y, width, height].\n\n**Code Description**:\nThe detectionToNarseseStatementsList function takes in a detection object and converts it into a list of Narsese statements. It first extracts the necessary information from the detection object, such as the label, confidence, and bounding box coordinates. \n\nThe function then calls the detectionPosition function to calculate the midpoint coordinates (x, y) of the bounding box. These midpoint coordinates are then passed to the foveaRelativePosition function to determine the relative position of the bounding box within a fovea. The discretizedSize function is also called to determine the size category of the object based on its width and height.\n\nUsing the extracted information and calculated values, the function calls the object_narsese function to generate a Narsese statement for each detection. The Narsese statement includes the size category, label, relative position, and confidence level of the object.\n\nThe generated Narsese statements are appended to a list, which is then returned as the output of the function.\n\n**Note**:\n- The detectionToNarseseStatementsList function assumes that the detection object is in the correct format and contains all the required keys. If the detection object is missing any key or has an incorrect format, the function may raise an error.\n- The function relies on the detectionPosition, foveaRelativePosition, discretizedSize, and object_narsese functions to perform its calculations and generate the Narsese statements. Make sure these functions are properly implemented and available in the project.\n- The Narsese statements generated by this function follow a specific format and may need to be processed further depending on the requirements of the project.\n\n**Output Example**:\nIf the detection object is:\n```\n{\n  \"label\": \"cat\",\n  \"confidence\": 0.95,\n  \"boxes\": [100, 200, 50, 60]\n}\n```\nThe detectionToNarseseStatementsList function will return the following list of Narsese statements:\n```\n[\n  \"<([average] & cat) --> [centeredX centeredY]>. :|: {1.0 0.95}\"\n]\n```"
      ],
      "code_start_line": 35,
      "code_end_line": 41,
      "parent": null,
      "params": [
        "detection"
      ],
      "have_return": true,
      "code_content": "def detectionToNarseseStatementsList(detection):\n    narseseStatementsList = []\n    (x, y) = detectionPosition(detection[\"boxes\"][0], detection[\"boxes\"][1], detection[\"boxes\"][2], detection[\"boxes\"][3])\n    (xLabel, yLabel) = foveaRelativePosition(x, y)\n    sz = discretizedSize(detection[\"boxes\"][2], detection[\"boxes\"][3])\n    narseseStatementsList.append(object_narsese(sz, detection[\"label\"], xLabel, yLabel, detection[\"confidence\"]))\n    return narseseStatementsList\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\ROS\\ona-channels\\ona_darknet.py/NARSUtility/darknet_callback"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\ROS\\ona-channels\\ona_roslib.py/detectionPosition",
        "OpenNARS-for-Applications\\misc\\ROS\\ona-channels\\ona_roslib.py/discretizedSize",
        "OpenNARS-for-Applications\\misc\\ROS\\ona-channels\\ona_roslib.py/foveaRelativePosition",
        "OpenNARS-for-Applications\\misc\\ROS\\ona-channels\\ona_roslib.py/object_narsese"
      ]
    },
    "NARSUtility": {
      "type": "ClassDef",
      "name": "NARSUtility",
      "md_content": [
        "**NARSUtility**: The function of NARSUtility is to provide utility methods for processing data from the darknet_ros package and publishing NARSese statements.\n\n**attributes**:\n- `narsese_pub`: A ROS publisher object used to publish NARSese statements.\n- `rate`: A ROS rate object used to control the publishing rate.\n\n**Code Description**:\nThe `NARSUtility` class is responsible for processing data from the darknet_ros package and publishing NARSese statements. It initializes a ROS node with the name 'NARSUtility' and sets the anonymity flag to False. It also subscribes to the '/darknet_ros/bounding_boxes' topic, expecting messages of type `BoundingBoxes`. The `darknet_callback` function is called whenever a message is received on this topic.\n\nIn the `darknet_callback` function, the bounding boxes data is extracted from the received message. For each bounding box, a dictionary is created with the label, confidence, and box coordinates. This dictionary is then passed to the `detectionToNarseseStatementsList` function, which returns a list of NARSese statements. Each statement is published using the `narsese_pub` publisher.\n\nThe `NARSUtility` class also has an attribute `rate`, which is a ROS rate object initialized with a rate of 10 Hz. This rate is used to control the publishing frequency of NARSese statements.\n\n**Note**:\n- This class assumes that the ROS environment has been properly set up and the necessary packages (darknet_ros) are installed.\n- The `detectionToNarseseStatementsList` function is not provided in the code snippet and should be implemented separately."
      ],
      "code_start_line": 43,
      "code_end_line": 56,
      "parent": null,
      "params": [],
      "have_return": false,
      "code_content": "class NARSUtility:\n\n    def __init__(self):\n        rospy.init_node('NARSUtility', anonymous=False)\n        rospy.Subscriber(\"/darknet_ros/bounding_boxes\", BoundingBoxes, self.darknet_callback)\n        self.narsese_pub = rospy.Publisher('/ona_ros/nars/narsese', String, queue_size=1)\n        self.rate = rospy.Rate(10)\n\n    def darknet_callback(self, data):\n        bboxes = data.bounding_boxes\n        for bbox in bboxes:\n            bbox = {'label': bbox.Class, 'confidence': bbox.probability, 'boxes': [bbox.xmin, bbox.ymin, bbox.xmax - bbox.xmin, bbox.ymax - bbox.ymin]}\n            for stmt in detectionToNarseseStatementsList(bbox):\n                self.narsese_pub.publish(stmt)\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "__init__": {
      "type": "FunctionDef",
      "name": "__init__",
      "md_content": [
        "**__init__**: The function of __init__ is to initialize the NARSUtility object.\n\n**parameters**:\n- None\n\n**Code Description**:\nThe __init__ function is the constructor of the NARSUtility class. It is called when a new instance of the class is created. The function performs the following tasks:\n\n1. Initializes the ROS node: The function calls the rospy.init_node() method to initialize the ROS node with the name 'NARSUtility'. The anonymous parameter is set to False, which means that the node will have a unique name.\n\n2. Subscribes to the \"/darknet_ros/bounding_boxes\" topic: The function creates a subscriber to the \"/darknet_ros/bounding_boxes\" topic using the rospy.Subscriber() method. It passes the self.darknet_callback method as the callback function to be executed when new data is received on the topic. The data received from the topic is expected to be of type BoundingBoxes.\n\n3. Initializes the Narsese publisher: The function creates a publisher object, self.narsese_pub, using the rospy.Publisher() method. The publisher is associated with the \"/ona_ros/nars/narsese\" topic and has a queue size of 1. This publisher will be used to publish Narsese statements.\n\n4. Sets the publishing rate: The function sets the publishing rate to 10 Hz using the rospy.Rate() method. This rate determines how frequently the Narsese statements will be published.\n\n**Note**:\n- The __init__ function does not take any parameters.\n- The function assumes that the necessary ROS packages and topics are properly configured in the project.\n- The self.darknet_callback method is expected to be implemented and available in the project. It is responsible for processing the data received from the \"/darknet_ros/bounding_boxes\" topic.\n- The self.narsese_pub publisher is used to publish Narsese statements to the \"/ona_ros/nars/narsese\" topic. Make sure the topic is correctly configured and subscribed to by the relevant components in the project."
      ],
      "code_start_line": 45,
      "code_end_line": 49,
      "parent": "NARSUtility",
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def __init__(self):\n        rospy.init_node('NARSUtility', anonymous=False)\n        rospy.Subscriber(\"/darknet_ros/bounding_boxes\", BoundingBoxes, self.darknet_callback)\n        self.narsese_pub = rospy.Publisher('/ona_ros/nars/narsese', String, queue_size=1)\n        self.rate = rospy.Rate(10)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\ROS\\ona-channels\\ona_darknet.py/NARSUtility/darknet_callback"
      ]
    },
    "darknet_callback": {
      "type": "FunctionDef",
      "name": "darknet_callback",
      "md_content": [
        "**darknet_callback**: The function of darknet_callback is to process the data received from the \"/darknet_ros/bounding_boxes\" topic and convert it into Narsese statements. These statements are then published to the \"/ona_ros/nars/narsese\" topic.\n\n**parameters**:\n- data: The data received from the \"/darknet_ros/bounding_boxes\" topic. It should be of type BoundingBoxes.\n\n**Code Description**:\nThe darknet_callback function takes in the data received from the \"/darknet_ros/bounding_boxes\" topic and extracts the bounding box information from it. It then iterates over each bounding box and converts it into a dictionary format. This dictionary contains the label, confidence, and coordinates of the bounding box.\n\nNext, the function calls the detectionToNarseseStatementsList function, passing the bounding box dictionary as a parameter. This function converts the bounding box into a list of Narsese statements. Each statement represents a detected object and includes information such as the label, confidence, and position of the object.\n\nFinally, the function publishes each Narsese statement to the \"/ona_ros/nars/narsese\" topic using the self.narsese_pub.publish() method.\n\n**Note**:\n- The darknet_callback function assumes that the data received from the \"/darknet_ros/bounding_boxes\" topic is in the correct format and contains the necessary information. If the data is missing any required fields or has an incorrect format, the function may raise an error.\n- The function relies on the detectionToNarseseStatementsList function to convert the bounding box into Narsese statements. Make sure this function is properly implemented and available in the project.\n- The Narsese statements generated by this function are published to the \"/ona_ros/nars/narsese\" topic. Make sure the topic is correctly configured and subscribed to by the relevant components in the project."
      ],
      "code_start_line": 51,
      "code_end_line": 56,
      "parent": "NARSUtility",
      "params": [
        "self",
        "data"
      ],
      "have_return": false,
      "code_content": "    def darknet_callback(self, data):\n        bboxes = data.bounding_boxes\n        for bbox in bboxes:\n            bbox = {'label': bbox.Class, 'confidence': bbox.probability, 'boxes': [bbox.xmin, bbox.ymin, bbox.xmax - bbox.xmin, bbox.ymax - bbox.ymin]}\n            for stmt in detectionToNarseseStatementsList(bbox):\n                self.narsese_pub.publish(stmt)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\ROS\\ona-channels\\ona_darknet.py/NARSUtility/__init__"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\ROS\\ona-channels\\ona_darknet.py/detectionToNarseseStatementsList"
      ]
    }
  },
  "OpenNARS-for-Applications\\misc\\ROS\\ona-channels\\ona_roslib.py": {
    "detectionPosition": {
      "type": "FunctionDef",
      "name": "detectionPosition",
      "md_content": [
        "**detectionPosition**: The function of detectionPosition is to calculate the midpoint coordinates of a bounding box based on its top-left corner coordinates and width and height.\n\n**Parameters**:\n- x: The x-coordinate of the top-left corner of the bounding box.\n- y: The y-coordinate of the top-left corner of the bounding box.\n- w: The width of the bounding box.\n- h: The height of the bounding box.\n\n**Code Description**:\nThe detectionPosition function takes in the coordinates (x, y) of the top-left corner of a bounding box, as well as its width (w) and height (h). It then calculates the midpoint coordinates (xmid, ymid) of the bounding box by adding half of the width to the x-coordinate and half of the height to the y-coordinate. The function assumes that the origin (0, 0) is at the top-left corner of the image.\n\nThis function is called by the detectionToNarseseStatementsList function in the ona_darknet.py file. In the detectionToNarseseStatementsList function, the detectionPosition function is used to calculate the midpoint coordinates of a bounding box obtained from a detection. The resulting midpoint coordinates are then used in further calculations to determine the relative position of the bounding box within a fovea.\n\n**Note**:\n- The detectionPosition function assumes that the origin (0, 0) is at the top-left corner of the image. If the coordinate system used in the project is different, the function should be adjusted accordingly.\n- The detectionPosition function does not perform any validation or error handling for the input parameters. It is assumed that the input parameters are valid and appropriate for the task at hand.\n\n**Output Example**:\nIf the input parameters are x = 10, y = 20, w = 30, and h = 40, the detectionPosition function will return the midpoint coordinates (xmid, ymid) as (25, 40)."
      ],
      "code_start_line": 28,
      "code_end_line": 31,
      "parent": null,
      "params": [
        "x",
        "y",
        "w",
        "h"
      ],
      "have_return": true,
      "code_content": "def detectionPosition(x, y, w, h):\n    xmid = x + w/2 #assuming x and y is at the top left\n    ymid = y + h/2 #point of the bounding box, please adjust if not!\n    return (xmid, ymid)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\ROS\\ona-channels\\ona_darknet.py/detectionToNarseseStatementsList"
      ],
      "reference_who": []
    },
    "discretizedPosition": {
      "type": "FunctionDef",
      "name": "discretizedPosition",
      "md_content": [
        "**discretizedPosition**: The function of discretizedPosition is to calculate the discretized position of a given point.\n\n**parameters**:\n- xmid: The x-coordinate of the midpoint.\n- ymid: The y-coordinate of the midpoint.\n\n**Code Description**:\nThe discretizedPosition function takes in the coordinates of a midpoint (xmid, ymid) and calculates the discretized position of a point. It does this by dividing the x-coordinate and y-coordinate of the midpoint by a discretization factor. The discretization factor is not provided in the code snippet and should be defined elsewhere in the code.\n\nThe function returns a tuple containing the discretized x-coordinate and discretized y-coordinate of the given point.\n\nThis function is called by the foveaRelativePosition function in the same module. The foveaRelativePosition function uses the discretizedPosition function to calculate the discretized position of a given point (x, y). It then compares the discretized position with the discretized midpoint position (xmid_discrete, ymid_discrete) to determine the relative position of the point with respect to the midpoint. The relative position is assigned labels based on the comparisons made.\n\n**Note**:\n- The discretization factor used in the discretizedPosition function should be defined elsewhere in the code.\n- The discretizedPosition function assumes that the discretization factor is non-zero to avoid division by zero errors.\n\n**Output Example**:\nIf the discretization factor is 10 and the midpoint coordinates are (20, 30), calling the discretizedPosition function with the point coordinates (25, 35) would return the tuple (2, 3), representing the discretized position of the point."
      ],
      "code_start_line": 33,
      "code_end_line": 34,
      "parent": null,
      "params": [
        "xmid",
        "ymid"
      ],
      "have_return": true,
      "code_content": "def discretizedPosition(xmid, ymid):\n    return (xmid / discretization, ymid / discretization)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\ROS\\ona-channels\\ona_roslib.py/foveaRelativePosition"
      ],
      "reference_who": []
    },
    "discretizedSize": {
      "type": "FunctionDef",
      "name": "discretizedSize",
      "md_content": [
        "**discretizedSize**: The function of discretizedSize is to determine the size category of an object based on its width and height.\n\n**parameters**:\n- w: The width of the object.\n- h: The height of the object.\n\n**Code Description**:\nThe discretizedSize function takes in the width and height of an object and calculates the maximum size between the two. It then compares the maximum size with predefined thresholds to determine the size category of the object. If the maximum size is less than 100, the function returns \"small\". If the maximum size is between 100 and 500, the function returns \"average\". Otherwise, if the maximum size is greater than or equal to 500, the function returns \"large\".\n\nThis function is used to categorize objects based on their size. By discretizing the size into three categories, it provides a simplified representation of the object's dimensions. This can be useful in various applications, such as object recognition or classification.\n\n**Note**:\n- The function assumes that the width and height parameters are positive integers.\n- If the width and height are equal, the function will consider that value as the maximum size.\n\n**Output Example**:\n- Example 1:\n  - Input: w = 80, h = 120\n  - Output: \"small\"\n- Example 2:\n  - Input: w = 200, h = 300\n  - Output: \"average\"\n- Example 3:\n  - Input: w = 600, h = 400\n  - Output: \"large\""
      ],
      "code_start_line": 36,
      "code_end_line": 43,
      "parent": null,
      "params": [
        "w",
        "h"
      ],
      "have_return": true,
      "code_content": "def discretizedSize(w, h):\n    sz = max(w,h)\n    if sz < 100:\n        return \"small\"\n    elif sz < 500:\n        return \"average\"\n    else:\n        return \"large\"\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\ROS\\ona-channels\\ona_darknet.py/detectionToNarseseStatementsList"
      ],
      "reference_who": []
    },
    "foveaRelativePosition": {
      "type": "FunctionDef",
      "name": "foveaRelativePosition",
      "md_content": [
        "**foveaRelativePosition**: The function of foveaRelativePosition is to determine the relative position of a given point with respect to a midpoint in a discretized manner.\n\n**parameters**:\n- x: The x-coordinate of the point.\n- y: The y-coordinate of the point.\n\n**Code Description**:\nThe foveaRelativePosition function takes in the coordinates of a point (x, y) and calculates its relative position with respect to a midpoint. It first calls the discretizedPosition function to obtain the discretized position of the point. Then, it compares the discretized position with the discretized midpoint position to determine the relative position. The relative position is assigned labels based on the comparisons made.\n\nThe function returns a tuple containing the labels for the relative position of the point in the x-axis and y-axis, respectively.\n\n**Note**:\n- The discretizedPosition function, which is called by foveaRelativePosition, assumes that the discretization factor is non-zero to avoid division by zero errors. The discretization factor should be defined elsewhere in the code.\n- The labels assigned to the relative position are \"centeredX\" and \"centeredY\" by default. If the point is to the left or right of the midpoint, the label for the x-axis will be \"lessX\" or \"moreX\", respectively. If the point is above or below the midpoint, the label for the y-axis will be \"lessY\" or \"moreY\", respectively.\n\n**Output Example**:\nIf the point coordinates are (25, 35) and the discretized midpoint coordinates are (20, 30), calling the foveaRelativePosition function would return the tuple (\"moreX\", \"moreY\"), indicating that the point is to the right and below the midpoint."
      ],
      "code_start_line": 47,
      "code_end_line": 58,
      "parent": null,
      "params": [
        "x",
        "y"
      ],
      "have_return": true,
      "code_content": "def foveaRelativePosition(x, y):\n    (x_discrete, y_discrete) = discretizedPosition(x, y)\n    (xLabel, yLabel) = (\"centeredX\", \"centeredY\")\n    if x_discrete < xmid_discrete:\n        xLabel = \"lessX\"\n    elif x_discrete > xmid_discrete:\n        xLabel = \"moreX\"\n    if y_discrete < ymid_discrete:\n        xLabel = \"lessY\"\n    elif y_discrete > ymid_discrete:\n        yLabel = \"moreY\"\n    return (xLabel, yLabel)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\ROS\\ona-channels\\ona_darknet.py/detectionToNarseseStatementsList",
        "OpenNARS-for-Applications\\misc\\ROS\\ona-channels\\ona_visp_auto_tracker.py/detectionToNarseseStatementsList"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\ROS\\ona-channels\\ona_roslib.py/discretizedPosition"
      ]
    },
    "object_narsese": {
      "type": "FunctionDef",
      "name": "object_narsese",
      "md_content": [
        "**object_narsese**: The function of object_narsese is to generate a Narsese statement based on the given parameters.\n\n**parameters**:\n- Property: A string representing the property of the object.\n- Class: A string representing the class of the object.\n- xLabel: A string representing the x-label of the object.\n- yLabel: A string representing the y-label of the object.\n- Confidence (optional): A float representing the confidence level of the object. The default value is 0.9.\n\n**Code Description**:\nThe `object_narsese` function takes in several parameters and returns a Narsese statement as a string. The Narsese statement is constructed by concatenating the given parameters in a specific format.\n\nThe Narsese statement is generated as follows:\n- The Property and Class parameters are enclosed in square brackets and combined with an ampersand (&) to represent the property and class of the object.\n- The xLabel and yLabel parameters are concatenated with a space to represent the x-label and y-label of the object.\n- The Narsese statement is enclosed in angle brackets (<>) to indicate that it is a statement.\n- The Confidence parameter, if provided, is converted to a string and appended to the Narsese statement with a confidence operator (:|:) and a confidence value in the format \"{1.0 Confidence}\".\n\nThe function returns the generated Narsese statement as a string.\n\nThis function is called by two objects in the project:\n1. `detectionToNarseseStatementsList` in the `ona_darknet.py` file:\n   - This function receives a detection object and extracts the necessary information such as position, label, and confidence.\n   - It then calls the `object_narsese` function, passing the extracted information as parameters.\n   - The generated Narsese statement is appended to a list and returned.\n\n2. `detectionToNarseseStatementsList` in the `ona_visp_auto_tracker.py` file:\n   - This function receives position and orientation information.\n   - It determines the door state based on the z orientation value.\n   - It calls the `object_narsese` function, passing the door state, \"door\" as the class, and the position information as parameters.\n   - The generated Narsese statement is appended to a list and returned.\n\n**Note**:\n- The Confidence parameter is optional and has a default value of 0.9.\n- The generated Narsese statement follows a specific format and should be used accordingly in the project.\n\n**Output Example**:\nIf the function is called with the following parameters:\n- Property: \"red\"\n- Class: \"ball\"\n- xLabel: \"A\"\n- yLabel: \"B\"\n- Confidence: 0.8\n\nThe function will return the following Narsese statement:\n\"<([red] & ball) --> [A B]>. :|: {1.0 0.8}\""
      ],
      "code_start_line": 60,
      "code_end_line": 61,
      "parent": null,
      "params": [
        "Property",
        "Class",
        "xLabel",
        "yLabel",
        "Confidence"
      ],
      "have_return": true,
      "code_content": "def object_narsese(Property, Class, xLabel, yLabel, Confidence=0.9):\n    return \"<([\" + Property + \"] & \" + Class + \") --> [\" + xLabel + \" \" + yLabel + \"]>. :|: {1.0 \" + str(Confidence) + \"}\"\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\ROS\\ona-channels\\ona_darknet.py/detectionToNarseseStatementsList",
        "OpenNARS-for-Applications\\misc\\ROS\\ona-channels\\ona_visp_auto_tracker.py/detectionToNarseseStatementsList"
      ],
      "reference_who": []
    }
  },
  "OpenNARS-for-Applications\\misc\\ROS\\ona-channels\\ona_visp_auto_tracker.py": {
    "detectionToNarseseStatementsList": {
      "type": "FunctionDef",
      "name": "detectionToNarseseStatementsList",
      "md_content": [
        "**detectionToNarseseStatementsList**: The function of detectionToNarseseStatementsList is to convert the position and orientation of a detected object into a list of Narsese statements.\n\n**parameters**:\n- position: A list representing the position of the detected object, with the x, y, and z coordinates.\n- orientation: A list representing the orientation of the detected object, with the x, y, z, and w components of the quaternion.\n\n**Code Description**:\nThe detectionToNarseseStatementsList function takes in the position and orientation of a detected object and converts them into a list of Narsese statements. It first initializes an empty list called narseseStatementsList. Then, it extracts the x and y coordinates from the position list and assigns them to variables x and y, respectively.\n\nNext, the function calls the foveaRelativePosition function from the ona_roslib.py module to obtain the relative position labels for the x and y coordinates. The foveaRelativePosition function discretizes the position and compares it with a midpoint to determine the relative position labels. The labels are assigned to variables xLabel and yLabel, respectively.\n\nThe function then determines the door state based on the z component of the orientation. If the z orientation is greater than 80 degrees, the doorstate variable is set to \"open\"; otherwise, it is set to \"closed\".\n\nFinally, the function calls the object_narsese function from the ona_roslib.py module, passing the doorstate, \"door\" as the class, and the xLabel and yLabel as parameters. The object_narsese function generates a Narsese statement based on the given parameters. The generated Narsese statement is appended to the narseseStatementsList.\n\nThe function returns the narseseStatementsList, which contains the Narsese statements representing the detected object's properties, class, and position.\n\n**Note**:\n- The foveaRelativePosition function, which is called by detectionToNarseseStatementsList, determines the relative position of a point with respect to a midpoint in a discretized manner. It assumes that the discretization factor is non-zero to avoid division by zero errors.\n- The object_narsese function, which is also called by detectionToNarseseStatementsList, generates a Narsese statement based on the given parameters. The generated Narsese statement follows a specific format and should be used accordingly in the project.\n\n**Output Example**:\nIf the position is [10, 20, 30] and the orientation is [0.1, 0.2, 90, 0.5], calling the detectionToNarseseStatementsList function would return a list containing the following Narsese statement:\n[\"<([closed] & door) --> [centeredX centeredY]>. :|: {1.0 0.9}\"]"
      ],
      "code_start_line": 32,
      "code_end_line": 40,
      "parent": null,
      "params": [
        "position",
        "orientation"
      ],
      "have_return": true,
      "code_content": "def detectionToNarseseStatementsList(position, orientation):\n    narseseStatementsList = []\n    (x, y) = (position[0], position[1])\n    (xLabel, yLabel) = foveaRelativePosition(x, y)\n    doorstate = \"closed\"\n    if orientation[2] > 80: #larger than 80 degree z orientation (TODO see if it's the relevant one, potentially convert!\n        doorstate = \"open\"\n    narseseStatementsList.append(object_narsese(doorstate, \"door\", xLabel, yLabel))\n    return narseseStatementsList\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\ROS\\ona-channels\\ona_visp_auto_tracker.py/TrackerUtility/tracker_callback"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\ROS\\ona-channels\\ona_roslib.py/foveaRelativePosition",
        "OpenNARS-for-Applications\\misc\\ROS\\ona-channels\\ona_roslib.py/object_narsese"
      ]
    },
    "TrackerUtility": {
      "type": "ClassDef",
      "name": "TrackerUtility",
      "md_content": [
        "**TrackerUtility**: The function of TrackerUtility is to provide utility functions for tracking objects using the visp_auto_tracker package in ROS.\n\n**attributes**:\n- `narsese_pub`: A ROS publisher object used to publish Narsese statements.\n- `rate`: A ROS rate object used to control the publishing rate.\n\n**Code Description**:\nThe `TrackerUtility` class is responsible for initializing the necessary ROS nodes and subscribers, as well as providing a callback function for tracking object positions. \n\nIn the `__init__` method, the class initializes a ROS node with the name \"TrackerUtility\" and sets the anonymous parameter to False. It then subscribes to the \"/visp_auto_tracker/object_position\" topic, expecting messages of type `PoseStamped`. Additionally, it creates a ROS publisher object named `narsese_pub` that publishes messages of type `String` to the \"/ona_ros/nars/narsese\" topic. The queue size for the publisher is set to 1. Finally, a ROS rate object named `rate` is created with a rate of 10 Hz.\n\nThe `tracker_callback` method is the callback function for the \"/visp_auto_tracker/object_position\" topic. It takes in the `data` parameter, which contains the pose information of the tracked object. The pose information is extracted from the `data` object and stored in the `pose`, `position`, and `orientation` variables. \n\nThe `position` variable is a list containing the x, y, and z coordinates of the object's position. The `orientation` variable is a list containing the x, y, z, and w components of the object's orientation quaternion.\n\nThe `detectionToNarseseStatementsList` function is called with the `position` and `orientation` variables as arguments. This function returns a list of Narsese statements based on the detected object's position and orientation.\n\nEach statement in the list is published using the `narsese_pub` publisher object.\n\n**Note**: \n- This class assumes that the `detectionToNarseseStatementsList` function is defined elsewhere and returns a list of Narsese statements based on the object's position and orientation.\n- The `rate` object is used to control the publishing rate of the Narsese statements. Adjust the rate value as needed for the specific application requirements."
      ],
      "code_start_line": 42,
      "code_end_line": 55,
      "parent": null,
      "params": [],
      "have_return": false,
      "code_content": "class TrackerUtility:\n\n    def __init__(self):\n        rospy.init_node('TrackerUtility', anonymous=False)\n        rospy.Subscriber(\"/visp_auto_tracker/object_position\", PoseStamped, self.tracker_callback)\n        self.narsese_pub = rospy.Publisher('/ona_ros/nars/narsese', String, queue_size=1)\n        self.rate = rospy.Rate(10)\n\n    def tracker_callback(self, data):\n        pose = data.pose\n        position = [data.pose.position.x, data.pose.position.y, data.pose.position.z]\n        orientation = [data.pose.orientation.x, data.pose.orientation.y, data.pose.orientation.z, data.pose.orientation.w]\n        for stmt in detectionToNarseseStatementsList(position, orientation):\n            self.narsese_pub.publish(stmt)\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "__init__": {
      "type": "FunctionDef",
      "name": "__init__",
      "md_content": [
        "**__init__**: The function of __init__ is to initialize the TrackerUtility object. It sets up the necessary ROS nodes, subscribers, publishers, and rate for the object.\n\n**parameters**:\n- None\n\n**Code Description**:\nThe __init__ function initializes the TrackerUtility object by performing the following steps:\n\n1. It calls the rospy.init_node() function to initialize the ROS node with the name 'TrackerUtility'. The anonymous parameter is set to False, which means that the node will have a unique name and will not be anonymous.\n\n2. It creates a rospy.Subscriber object to subscribe to the \"/visp_auto_tracker/object_position\" topic. The subscriber is set to listen for messages of type PoseStamped. The callback function self.tracker_callback is specified as the function to handle the received messages.\n\n3. It creates a rospy.Publisher object named self.narsese_pub. This publisher is used to publish messages of type String to the \"/ona_ros/nars/narsese\" topic. The queue_size parameter is set to 1, which means that only the latest message will be kept in the queue.\n\n4. It creates a rospy.Rate object named self.rate with a rate of 10 Hz. This rate is used to control the frequency at which the object performs its tasks.\n\n**Note**:\n- The rospy.init_node() function initializes the ROS node with the specified name. Make sure that the name is unique and does not conflict with other nodes in the ROS system.\n- The rospy.Subscriber object is used to subscribe to a specific topic and receive messages of a specific type. Make sure that the topic name and message type are correct and match the publisher that is publishing messages to that topic.\n- The rospy.Publisher object is used to publish messages to a specific topic. Make sure that the topic name is correct and matches the subscriber that is listening to that topic.\n- The rospy.Rate object is used to control the frequency at which the object performs its tasks. Make sure that the rate is set to an appropriate value based on the requirements of the system.\n\nPlease let me know if you need any further assistance."
      ],
      "code_start_line": 44,
      "code_end_line": 48,
      "parent": "TrackerUtility",
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def __init__(self):\n        rospy.init_node('TrackerUtility', anonymous=False)\n        rospy.Subscriber(\"/visp_auto_tracker/object_position\", PoseStamped, self.tracker_callback)\n        self.narsese_pub = rospy.Publisher('/ona_ros/nars/narsese', String, queue_size=1)\n        self.rate = rospy.Rate(10)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\ROS\\ona-channels\\ona_visp_auto_tracker.py/TrackerUtility/tracker_callback"
      ]
    },
    "tracker_callback": {
      "type": "FunctionDef",
      "name": "tracker_callback",
      "md_content": [
        "**tracker_callback**: The function of tracker_callback is to handle the callback function for the \"/visp_auto_tracker/object_position\" topic. It receives the pose data of a detected object and converts it into a list of Narsese statements using the detectionToNarseseStatementsList function. The generated Narsese statements are then published to the \"/ona_ros/nars/narsese\" topic.\n\n**parameters**:\n- data: The pose data of the detected object.\n\n**Code Description**:\nThe tracker_callback function takes in the pose data of a detected object and extracts the position and orientation information from it. It first assigns the pose data to the variable \"pose\".\n\nNext, the function extracts the x, y, and z coordinates from the position and assigns them to the \"position\" variable as a list. Similarly, it extracts the x, y, z, and w components of the quaternion from the orientation and assigns them to the \"orientation\" variable as a list.\n\nThe function then calls the detectionToNarseseStatementsList function, passing the position and orientation as parameters. The detectionToNarseseStatementsList function converts the position and orientation into a list of Narsese statements representing the detected object's properties, class, and position.\n\nFor each Narsese statement generated by the detectionToNarseseStatementsList function, the tracker_callback function publishes it to the \"/ona_ros/nars/narsese\" topic using the self.narsese_pub.publish(stmt) statement.\n\n**Note**:\n- The detectionToNarseseStatementsList function is called to convert the position and orientation of the detected object into a list of Narsese statements. Refer to the documentation of the detectionToNarseseStatementsList function for more details on its functionality.\n- The self.narsese_pub.publish(stmt) statement publishes the generated Narsese statements to the \"/ona_ros/nars/narsese\" topic. Make sure the necessary ROS setup and configuration are in place for the messages to be successfully published.\n- Ensure that the \"/visp_auto_tracker/object_position\" topic is being published with the correct message type (PoseStamped) and that the necessary ROS setup and configuration are in place for the messages to be received by the tracker_callback function."
      ],
      "code_start_line": 50,
      "code_end_line": 55,
      "parent": "TrackerUtility",
      "params": [
        "self",
        "data"
      ],
      "have_return": false,
      "code_content": "    def tracker_callback(self, data):\n        pose = data.pose\n        position = [data.pose.position.x, data.pose.position.y, data.pose.position.z]\n        orientation = [data.pose.orientation.x, data.pose.orientation.y, data.pose.orientation.z, data.pose.orientation.w]\n        for stmt in detectionToNarseseStatementsList(position, orientation):\n            self.narsese_pub.publish(stmt)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\ROS\\ona-channels\\ona_visp_auto_tracker.py/TrackerUtility/__init__"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\ROS\\ona-channels\\ona_visp_auto_tracker.py/detectionToNarseseStatementsList"
      ]
    }
  },
  "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py": {
    "pick_failed": {
      "type": "FunctionDef",
      "name": "pick_failed",
      "md_content": [
        "**pick_failed**: The function of pick_failed is to perform a sequence of actions when a pick operation fails.\n\n**parameters**:\n- None\n\n**Code Description**:\nThe `pick_failed` function is called in the `pick_with_feedback` function of the `transbot.py` file when a pick operation fails. It is responsible for executing a series of actions to handle the failure and reposition the Transbot for another attempt.\n\nFirst, the function calls the `arm_up` function to move the Transbot's gripper arm to an upward position. This ensures that the arm is clear of any obstacles before repositioning the Transbot.\n\nNext, the function calls the `backward` function twice to move the Transbot backward. This helps to create distance between the Transbot and the object that failed to be picked.\n\nAfter moving backward, the function calls the `right` function three times to make the Transbot move to the right. This allows the Transbot to reposition itself and potentially find a better angle for picking the object.\n\nFinally, the function calls the `open_gripper` function to open the gripper of the Transbot's arm. This prepares the gripper for another pick attempt.\n\nOverall, the `pick_failed` function performs a sequence of actions to handle a failed pick operation. It ensures that the Transbot is repositioned and ready for another attempt to pick the object.\n\n**Note**: It is important to note that the `pick_failed` function relies on the `arm_up`, `backward`, `right`, and `open_gripper` functions to perform the necessary actions. Therefore, these functions should be properly implemented and available before calling `pick_failed`. Additionally, the `pick_failed` function is called within the context of the `pick_with_feedback` function, which provides additional functionality and control over the pick operation."
      ],
      "code_start_line": 23,
      "code_end_line": 30,
      "parent": null,
      "params": [],
      "have_return": false,
      "code_content": "def pick_failed():\n    arm_up()\n    backward()\n    backward()\n    right()\n    right()\n    right()\n    open_gripper()\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/pick_with_feedback"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/arm_up",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/open_gripper",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/right",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/backward"
      ]
    },
    "pick_with_feedback": {
      "type": "FunctionDef",
      "name": "pick_with_feedback",
      "md_content": [
        "**pick_with_feedback**: The function of pick_with_feedback is to perform a pick operation with visual feedback using the Transbot's gripper arm.\n\n**parameters**:\n- pickobj (optional): The object to be picked. If not specified, the function will attempt to pick any object within its visual range.\n- location (optional): The desired location of the object relative to the gripper. Valid values are \"left\", \"right\", or None. If not specified, the function will attempt to pick the object in the center.\n- ForwardSleep (optional): The duration in seconds to sleep between forward movements. The default value is 0.5 seconds.\n\n**Code Description**:\nThe `pick_with_feedback` function is responsible for performing a pick operation with visual feedback using the Transbot's gripper arm. It starts by checking if the `pickobj` parameter contains the special character \" * \". If it does, the function extracts the `location` and `pickobj` values from the parameter. Otherwise, it uses the default values of `None` for `pickobj` and `location`.\n\nNext, the function checks if an object has already been picked by calling the `getPicked` function. If an object has been picked, the function returns without performing any further actions.\n\nThe function then calls the `arm_down` function to move the Transbot's gripper arm to a downward position. This ensures that the arm is clear of any obstacles before attempting to pick the object.\n\nAfter a brief pause of 1 second, the function initializes variables for the maximum number of operations (`max_ops`), the number of move steps (`move_steps`), the maximum number of swaps (`max_swaps`), and the number of swaps performed (`swaps`). It also sets the `swap_Left` and `swap_Right` variables to `False`.\n\nThe function then enters a while loop that continues indefinitely until a break statement is encountered. Within the loop, the function flushes the standard output and increments the `move_steps` variable.\n\nIf the `move_steps` variable exceeds the `max_ops` value, the function prints a feedback message indicating that the pick has failed due to the object being too far away. It then calls the `pick_failed` function and breaks out of the loop.\n\nIf the `move_steps` variable is within the `max_ops` limit, the function waits for a key press event using the `cv.waitKey` function. It also calls the `detect_objects` function to detect objects in the current frame.\n\nThe function then initializes temporary variables for the real coordinates of the object (`x_real_temp` and `y_real_temp`). If the `location` parameter is `None`, the function compares the `y_real` value of each detected object and updates the temporary variables if a higher value is found. If the `location` parameter is \"left\", the function compares the `x_real` value of each detected object and updates the temporary variables if a lower value is found. If the `location` parameter is \"right\", the function compares the `x_real` value of each detected object and updates the temporary variables if a higher value is found.\n\nIf the temporary variables have been updated, the function checks if the `y_real_temp` value is less than a predefined threshold (`y_too_far_to_grab`). If it is, the function prints a feedback message indicating that the pick has failed due to the object being too far away. It then calls the `pick_failed` function and breaks out of the loop.\n\nThe function calculates the number of turn steps required to align the object with the Transbot's visual middle using the `robotVisualMiddle` and `center_offset` variables. If the `x_real_temp` value is within the range defined by `robotVisualMiddle-center_offset` and `robotVisualMiddle+center_offset`, the function prints a feedback message indicating that the object is in the center. It then performs a series of forward movements to approach the object, with a sleep duration between each movement specified by the `ForwardSleep` parameter. After the forward movements, the function calls the `close_gripper` function to attempt to grab the object. If the grab is successful, the function calls the `arm_up` function to lift the object and checks if the gripper is still holding the object. If the gripper is still holding the object, the function sets the `picked` global variable to `True` using the `setPicked` function. It then prints a success message and checks if the Transbot has a trailer attached. If it does, the function calls the `drop_trailer` function to detach the trailer.\n\nIf the `x_real_temp` value is greater than `robotVisualMiddle+center_offset`, the function prints a feedback message indicating that the object is on the right side. It then performs a series of right rotations to align the Transbot with the object.\n\nIf the `x_real_temp` value is less than `robotVisualMiddle-center_offset`, the function prints a feedback message indicating that"
      ],
      "code_start_line": 32,
      "code_end_line": 143,
      "parent": null,
      "params": [
        "pickobj",
        "location",
        "ForwardSleep"
      ],
      "have_return": true,
      "code_content": "def pick_with_feedback(pickobj=None, location=None, ForwardSleep=0.5):\n    if \" * \" in pickobj:\n        pickobj = pickobj.replace(\"(\",\"\").replace(\")\",\"\")\n        location = pickobj.split(\" * \")[0]\n        pickobj = pickobj.split(\" * \")[1]\n    if getPicked():\n        return\n    arm_down()\n    sleep(1)\n    max_ops = 30\n    move_steps = 0\n    max_swaps = 3\n    max_ops = 30\n    swaps = 0 #left/right focus attempts\n    swap_Left = False\n    swap_Right = False\n    while True:\n        sys.stdout.flush()\n        move_steps+=1\n        if move_steps > max_ops:\n            open_gripper()\n            pick_failed()\n            break\n        action = cv.waitKey(10) & 0xFF\n        detections, frame = detect_objects()\n        y_real_temp = -1\n        x_real_temp = -1 if location != \"left\" else 9999999\n        for i, detection in enumerate(detections):\n            if i >= 2:\n                continue\n            (obj, x, y, w, h, c, color) = detection\n            x_real = x+w/2\n            y_real = y+h #down side of bb\n            if pickobj == None or pickobj == obj:\n                if location is None and y_real > y_real_temp:\n                    y_real_temp = y_real\n                    x_real_temp = x_real\n                if location == \"left\" and x_real < x_real_temp:\n                    y_real_temp = y_real\n                    x_real_temp = x_real\n                if location == \"right\" and x_real > x_real_temp:\n                    y_real_temp = y_real\n                    x_real_temp = x_real\n        if y_real_temp != -1:\n            if y_real_temp < y_too_far_to_grab:\n                print(\"//pick failed, too far away to grab\")\n                pick_failed()\n                break\n            kp = 50\n            turn_steps_required = int(abs(x_real_temp - robotVisualMiddle) / kp)\n            if (x_real_temp >= robotVisualMiddle-center_offset and x_real_temp <= robotVisualMiddle+center_offset) or swaps > 3: # Object in the center case\n                print(\"//CENTER------------\")\n                closer_to_gripper = 475\n                swaps = 0\n                if y_real_temp < closer_to_gripper: #visual feedback\n                    forward()\n                elif y_real_temp > closer_to_gripper:\n                    #left()\n                    forward(linear=0.25)\n                    if ForwardSleep is not None:\n                        time.sleep(ForwardSleep)\n                    forward(linear=0.25)\n                    if ForwardSleep is not None:\n                        time.sleep(ForwardSleep)\n                    forward(linear=0.2)\n                    if ForwardSleep is not None:\n                        time.sleep(ForwardSleep)\n                    forward(linear=0.2)\n                    success, grip_angle = close_gripper() # Grabbing object\n                    if success:\n                        arm_up()\n                        success2, _ = close_gripper(grip_angle) # Check if gripper is still holds an object after lifting\n                        if success2:\n                            setPicked(True)\n                            print(\"pick succeeded\")\n                            if get_hastrailer():\n                                drop_trailer()\n                        else:\n                            open_gripper()\n                            print(\"//pick failed, object slipped\")\n                            backward()\n                            backward()\n                            right()\n                            right()\n                            right()\n                        break\n                    else:\n                        print(\"//pick failed, sensed nothing to grab\")\n                        pick_failed()\n                        arm_up()\n                        break\n            elif x_real_temp > robotVisualMiddle+center_offset: # Object is on the RIGHT of the gripper\n                print(\"//RIGHT<<<<<<<<<<<<<<<<\")\n                turn_steps_required = max(1, turn_steps_required)\n                for i in range(abs(turn_steps_required)): right()\n                swap_Right = True\n            else: # Object is on the LEFT of the gripper\n                print(\"//LEFT>>>>>>>>>>>>>>>\")\n                turn_steps_required = max(1, turn_steps_required)\n                for i in range(abs(turn_steps_required)): left()\n                swap_Left = True\n            if swap_Left and swap_Right:\n                swap_Left = False\n                swap_Right = False\n                swaps += 1\n        else:\n            print(\"//pick failed, object disappeared visually\")\n            pick_failed()\n            break\n        #print(detections)\n        cv.imshow('frame', frame)\n        sleep(1.0)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/TransbotExecute",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/process"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/pick_failed",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/get_hastrailer",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/arm_down",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/arm_up",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/close_gripper",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/open_gripper",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/left",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/right",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/forward",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/backward",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/setPicked",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/getPicked",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/drop_trailer",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_vision.py/detect_objects"
      ]
    },
    "TransbotExecute": {
      "type": "FunctionDef",
      "name": "TransbotExecute",
      "md_content": [
        "**TransbotExecute**: The TransbotExecute function is responsible for executing a series of actions based on a list of executions. It iterates through each execution in the list and performs the corresponding action based on the operator specified in the execution. The function also handles special cases such as querying the location, saying a message, and activating or deactivating a feature.\n\n**parameters**:\n- executions: A list of dictionaries representing the actions to be executed. Each dictionary contains two keys: \"operator\" and \"arguments\". The \"operator\" key specifies the action to be performed, and the \"arguments\" key contains any additional arguments required for the action.\n\n**Code Description**:\nThe TransbotExecute function begins by initializing a boolean variable called ActionInvoked to False. This variable keeps track of whether any action has been invoked during the execution of the function.\n\nThe function then iterates through each execution in the executions list using a for loop. For each execution, it retrieves the operator and arguments from the dictionary.\n\nIf the operator is \"^forward\", the function calls the OpStop function to stop the Transbot's current movement, and then calls the forward function five times to move the Transbot forward. Afterward, it calls the OpStop function again to stop the Transbot's movement.\n\nIf the operator is \"^left\", the function calls the OpStop function to stop the Transbot's current movement, and then calls the left function four times to make the Transbot turn left. Afterward, it calls the OpStop function again to stop the Transbot's movement.\n\nIf the operator is \"^right\", the function calls the OpStop function to stop the Transbot's current movement, and then calls the right function four times to make the Transbot turn right. Afterward, it calls the OpStop function again to stop the Transbot's movement.\n\nIf the operator is \"^pick\", the function calls the OpStop function to stop the Transbot's current movement, and then calls the pick_with_feedback function with the arguments passed to the TransbotExecute function. The pick_with_feedback function is responsible for performing a pick operation with visual feedback using the Transbot's gripper arm.\n\nIf the operator is \"^drop\", the function calls the OpStop function to stop the Transbot's current movement, and then calls the drop function to release the object held by the Transbot's gripper arm.\n\nIf the operator is \"^activate\" or \"^deactivate\", the function does nothing as these actions are reserved for future use.\n\nIf the operator is \"^goto\", the function retrieves the location query answer by calling the AddInput function from the NAR.py module with a Narsese input string. It then extracts the x, y, z, and w coordinates from the location query answer and converts them to float values. Finally, it calls the OpGo function with the extracted coordinates to navigate the Transbot to the specified location.\n\nIf the operator is \"^say\", the function prints the message specified in the arguments.\n\nAfter iterating through all the executions, the function returns the ActionInvoked variable, which indicates whether any action has been invoked during the execution of the function.\n\n**Note**:\n- The TransbotExecute function assumes that the OpStop, forward, left, right, pick_with_feedback, drop, OpGo, and say functions are defined and accessible within the same module.\n- The function relies on the AddInput function from the NAR.py module to query the location and retrieve the location query answer.\n- The function assumes that the NAR.py module is imported and accessible within the same module.\n- The function assumes that the OpStop, forward, left, right, pick_with_feedback, drop, OpGo, and say functions are properly implemented and perform the desired actions.\n- The function assumes that the pick_with_feedback function handles the picking operation with visual feedback using the Transbot's gripper arm.\n- The function assumes that the OpGo function sends a goal to the action server for the Transbot to navigate to a specified location.\n- The function assumes that the say function prints a message to the console.\n\n**Output Example**:\nIf any action is invoked during the execution of the TransbotExecute function, the function will return True. Otherwise, it will return False."
      ],
      "code_start_line": 146,
      "code_end_line": 197,
      "parent": null,
      "params": [
        "executions"
      ],
      "have_return": true,
      "code_content": "def TransbotExecute(executions):\n    global Right_warning, Left_warning, Front_warning\n    ActionInvoked = False\n    for execution in executions:\n        op = execution[\"operator\"]\n        arguments = execution[\"arguments\"]\n        ActionInvoked = True\n        if op == \"^forward\":\n            OpStop()\n            #OpGo(0.5, 0.0, 0.0, 1.0, frame_id = \"base_link\") #Lidar-safe\n            forward()\n            forward()\n            forward()\n            forward()\n            forward()\n            OpStop()\n        elif op == \"^left\":\n            OpStop()\n            left()\n            left()\n            left()\n            left()\n            #OpGo(0.0, 0.0, 0.5, 1.0, frame_id = \"base_link\")\n            OpStop()\n        elif op == \"^right\":\n            OpStop()\n            right()\n            right()\n            right()\n            right()\n            #OpGo(0.0, 0.0, -0.5, 1.0, frame_id = \"base_link\")\n            OpStop()\n        elif op == \"^pick\":\n            OpStop()\n            pick_with_feedback(None if len(arguments) == 0 else arguments)\n        elif op == \"^drop\":\n            OpStop()\n            drop()\n        elif op == \"^activate\": #for later\n            None\n        elif op == \"^deactivate\": #for later\n            None\n        elif op == \"^goto\":\n            locationQueryAnswer = NAR.AddInput(\"<(%s * ?where) --> at>? :|:\" % arguments)[\"answers\"][0]\n            if locationQueryAnswer[\"term\"] != \"None\":\n                (x,y,z,w) = locationQueryAnswer[\"term\"].split(\" * \")[1].split(\") --> at>\")[0].split(\"_\")\n                (xf, yf, zf, wf) = (float(x)-valueToTermOffset, float(y)-valueToTermOffset, float(z)-valueToTermOffset, float(w)-valueToTermOffset)\n                OpGo(xf, yf, zf, wf)\n                OpStop()\n        elif op == \"^say\":\n            print(\"//SAY: \" + arguments)\n    return ActionInvoked\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/process"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR.py/AddInput",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/pick_with_feedback",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/left",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/right",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/forward",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/drop",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_nav.py/OpGo",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_nav.py/OpStop"
      ]
    },
    "valueToTerm": {
      "type": "FunctionDef",
      "name": "valueToTerm",
      "md_content": [
        "**valueToTerm**: The function of valueToTerm is to convert a numerical value into a string representation.\n\n**parameters**:\n- x: A numerical value that needs to be converted into a string.\n\n**Code Description**:\nThe valueToTerm function takes a numerical value as input and converts it into a string representation. It adds the value of the variable \"valueToTermOffset\" to the input value and then converts the result into a string. The resulting string is then truncated to the first five characters using the slice operator [:5]. The function returns the truncated string representation of the input value.\n\nThis function is called by the TransbotPerceiveAt object in the Transbot module. In the TransbotPerceiveAt function, the valueToTerm function is used to convert the elements of the \"trans\" and \"rot\" lists into string representations. These string representations are then concatenated using underscores to form the \"transXYrotZW\" string. This string is used as an input to the NAR.AddInput function.\n\n**Note**:\n- The valueToTermOffset variable is assumed to be defined and accessible within the scope of the valueToTerm function.\n- The returned string representation of the input value is truncated to the first five characters using the slice operator [:5]. If the input value is shorter than five characters, the entire string representation will be returned.\n\n**Output Example**:\nIf the input value is 10 and the valueToTermOffset is 5, the function will return the string \"15\"."
      ],
      "code_start_line": 199,
      "code_end_line": 200,
      "parent": null,
      "params": [
        "x"
      ],
      "have_return": true,
      "code_content": "def valueToTerm(x):\n    return str(x+valueToTermOffset)[:5]\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/TransbotPerceiveAt"
      ],
      "reference_who": []
    },
    "TransbotPerceiveAt": {
      "type": "FunctionDef",
      "name": "TransbotPerceiveAt",
      "md_content": [
        "**TransbotPerceiveAt**: The function of TransbotPerceiveAt is to perceive the location of an object in the environment and send the perception information to the NAR (Non-Axiomatic Reasoning) system for further processing.\n\n**parameters**:\n- obj: A string representing the object to be perceived.\n- trans: A list of three numerical values representing the translation coordinates of the object.\n- rot: A list of four numerical values representing the rotation coordinates of the object.\n\n**Code Description**:\nThe TransbotPerceiveAt function takes an object, its translation coordinates, and rotation coordinates as input. It converts the translation and rotation values into string representations using the valueToTerm function. The string representations are then concatenated using underscores to form the \"transXYrotZW\" string.\n\nThe function calls the NAR.AddInput function to send a Narsese input to the NAR system. The Narsese input is in the form \"<(obj * transXYrotZW) --> at>. :|:\". The \"<\" and \">\" symbols indicate the start and end of a statement, \"(obj * transXYrotZW)\" represents the object and its location, \"-->\" indicates a relation, and \"at\" represents the relation type. The \". :|:\" at the end of the statement is the punctuation used in Narsese.\n\n**Note**:\n- The TransbotPerceiveAt function assumes that the NAR system is already running and its standard input and output streams are accessible.\n- The function relies on the valueToTerm function to convert the translation and rotation values into string representations.\n- The function uses the NAR.AddInput function to send the perception information to the NAR system for processing.\n\nNow, let's analyze the calling situation of the TransbotPerceiveAt function in the project:\n\nThe TransbotPerceiveAt function is called by the TransbotPerceiveVisual function in the Transbot module. In the TransbotPerceiveVisual function, the TransbotPerceiveAt function is used to perceive the location of an object based on its screen coordinates and send the perception information to the NAR system. The screen coordinates are converted into translation and rotation values, which are then passed as arguments to the TransbotPerceiveAt function.\n\nThe TransbotPerceiveAt function is also called by the process function in the Transbot module. In the process function, the TransbotPerceiveAt function is called when the input line ends with \"? :|:\" and contains \"{SELF}\". The process function retrieves the translation and rotation values using the getLocation function and passes them along with the \"{SELF}\" object to the TransbotPerceiveAt function.\n\nThe TransbotPerceiveAt function is an essential part of the Transbot module as it enables the robot to perceive the location of objects in its environment and communicate this information to the NAR system for reasoning and decision-making.\n\nPlease note that the provided documentation is based on the analysis of the code and existing documentation. It is important to review and validate the documentation for accuracy and completeness before using it in a production environment."
      ],
      "code_start_line": 202,
      "code_end_line": 204,
      "parent": null,
      "params": [
        "obj",
        "trans",
        "rot"
      ],
      "have_return": false,
      "code_content": "def TransbotPerceiveAt(obj, trans, rot):\n    transXYrotZW = \"_\".join([valueToTerm(x) for x in trans[:2]]) + \"_\" + \"_\".join([valueToTerm(x) for x in rot[2:]])\n    NAR.AddInput(\"<(%s * %s) --> at>. :|:\" % (obj, transXYrotZW))\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/TransbotPerceiveVisual",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/process",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/shell_step"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR.py/AddInput",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/valueToTerm"
      ]
    },
    "TransbotPerceiveVisual": {
      "type": "FunctionDef",
      "name": "TransbotPerceiveVisual",
      "md_content": [
        "**TransbotPerceiveVisual**: The function of TransbotPerceiveVisual is to perceive the visual information of an object in the environment and send the perception information to the NAR (Non-Axiomatic Reasoning) system for further processing.\n\n**parameters**:\n- obj: A string representing the object to be perceived.\n- screenX: An integer representing the X-coordinate of the object on the screen.\n- screenY: An integer representing the Y-coordinate of the object on the screen.\n- trans: A list of three numerical values representing the translation coordinates of the object.\n- rot: A list of four numerical values representing the rotation coordinates of the object.\n\n**Code Description**:\nThe TransbotPerceiveVisual function takes an object, its screen coordinates, translation coordinates, and rotation coordinates as input. It first initializes the \"direction\" variable with the value \"front\".\n\nThe function then calls the TransbotPerceiveAt function to perceive the location of the object based on its translation and rotation coordinates. This function is responsible for sending the perception information to the NAR system.\n\nNext, the function checks the screenX value against a predefined threshold, robotVisualMiddle-center_offset, to determine the direction of the object. If the screenX value is less than the threshold, the direction is set to \"left\". If the screenX value is greater than the threshold, the direction is set to \"right\".\n\nFinally, the function calls the NAR.AddInput function to send a Narsese input to the NAR system. The Narsese input is in the form \"<(obj * direction) --> at>. :|:\". The \"<\" and \">\" symbols indicate the start and end of a statement, \"(obj * direction)\" represents the object and its direction, \"-->\" indicates a relation, and \"at\" represents the relation type. The \". :|:\" at the end of the statement is the punctuation used in Narsese.\n\n**Note**:\n- The TransbotPerceiveVisual function assumes that the NAR system is already running and its standard input and output streams are accessible.\n- The function relies on the TransbotPerceiveAt function to perceive the location of the object and send the perception information to the NAR system.\n- The function determines the direction of the object based on its screenX value and a predefined threshold.\n- The function uses the NAR.AddInput function to send the perception information to the NAR system for further processing.\n\nThe TransbotPerceiveVisual function is an important part of the Transbot module as it enables the robot to perceive the visual information of objects in its environment and communicate this information to the NAR system for reasoning and decision-making.\n\nPlease note that the provided documentation is based on the analysis of the code and existing documentation. It is important to review and validate the documentation for accuracy and completeness before using it in a production environment."
      ],
      "code_start_line": 206,
      "code_end_line": 213,
      "parent": null,
      "params": [
        "obj",
        "screenX",
        "screenY",
        "trans",
        "rot"
      ],
      "have_return": false,
      "code_content": "def TransbotPerceiveVisual(obj, screenX, screenY, trans, rot):\n    direction = \"front\" #640  -> 320 center\n    TransbotPerceiveAt(obj, trans, rot) #TODO improve\n    if screenX < robotVisualMiddle-center_offset:\n        direction = \"left\"\n    elif screenX > robotVisualMiddle+center_offset:\n        direction = \"right\"\n    NAR.AddInput(\"<%s --> [%s]>. :|:\" % (obj, direction))\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/process"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR.py/AddInput",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/TransbotPerceiveAt"
      ]
    },
    "reset_ona": {
      "type": "FunctionDef",
      "name": "reset_ona",
      "md_content": [
        "**reset_ona**: The function of reset_ona is to reset the OpenNARS system by adding background knowledge from a file and printing a message indicating that the system has been reset.\n\n**parameters**:\n- None\n\n**Code Description**:\nThe reset_ona function begins by opening the \"knowledge.nal\" file in read mode using the open() function and assigning the contents of the file to the BackgroundKnowledge variable.\n\nNext, the function iterates over each line of the concatenated string of Configuration and BackgroundKnowledge, split by the newline character. Each line is stripped of leading and trailing whitespace and assigned to the bgstr variable.\n\nIf the length of bgstr is greater than 0, indicating that the line is not empty, the function calls the AddInput function from the NAR module to add the Narsese input represented by bgstr to the NAR system.\n\nAfter adding all the background knowledge, the function prints the message \"//transbot.py (ONA) go!\" using the print() function.\n\n**Note**:\n- The reset_ona function assumes that the \"knowledge.nal\" file exists in the same directory as the transbot.py file.\n- The function relies on the AddInput function from the NAR module to add Narsese inputs to the NAR system.\n- The Configuration variable is assumed to be defined and accessible within the same module as the reset_ona function.\n- The function does not return any value.\n\n**Calling Situation**:\nThe reset_ona function is called in the process function from the transbot.py file. The process function is responsible for processing user input and performing corresponding actions in the OpenNARS system.\n\nIn the process function, if the user input is \"*reset\", the reset_ona function is called to reset the OpenNARS system. This is done by adding background knowledge from the \"knowledge.nal\" file and printing a message indicating that the system has been reset.\n\n**Note**:\n- The process function assumes that the reset_ona function is defined and accessible within the same module as the process function.\n- The process function is assumed to be called in the context of the Transbot application, where the OpenNARS system is used for reasoning and decision-making."
      ],
      "code_start_line": 228,
      "code_end_line": 235,
      "parent": null,
      "params": [],
      "have_return": false,
      "code_content": "def reset_ona():\n    with open(\"knowledge.nal\", 'r') as f:\n        BackgroundKnowledge = f.read()\n    for bg in (Configuration + BackgroundKnowledge).split(\"\\n\"):\n        bgstr = bg.strip()\n        if len(bgstr) > 0:\n            NAR.AddInput(bgstr)\n    print(\"//transbot.py (ONA) go!\")\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/process"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\NAR.py/AddInput"
      ]
    },
    "process": {
      "type": "FunctionDef",
      "name": "process",
      "md_content": [
        "**process**: The function of process is to handle different types of input lines and perform corresponding actions based on the content of the input.\n\n**parameters**:\n- line: A string representing the input line to be processed.\n\n**Code Description**:\nThe `process` function takes an input line and performs different actions based on the content of the line. It first checks if the line is not empty. If it is not empty and ends with \"? :|:\" and contains \"{SELF}\", it calls the `getLocation` function to get the current location and then invokes the `TransbotPerceiveAt` function to perceive the location of the transbot at \"{SELF}\".\n\nNext, it checks if the line ends with \"! :|:\" or is equal to \"*internal\". If the `getPicked` function returns True, it adds the input \"<gripper --> [hold]>. :|:\" to the NAR (Non-Axiomatic Reasoning) system. Otherwise, it adds the input \"<gripper --> [open]>. :|:\".\n\nThen, it checks if the line ends with \"! :|:\" or is equal to \"*see\". It calls the `getCollision` function to get the collision status and the `getLocation` function to get the current location. It also waits for a key event using the `cv.waitKey` function and detects objects using the `detect_objects` function. It then sorts the detections based on their size and selects the nearest object. If there is a valid object, it calculates the real-world coordinates of the object and calls the `TransbotPerceiveVisual` function to perceive the visual information of the object.\n\nIf the object is too far to grab, it checks if there are at least two detections and if the first two detections have the same object. If they do, it extracts color and size vectors from the detections and uses the `Nalifier` class to compare the color and size vectors. Based on the comparison result, it adds corresponding statements to the NAR system. If the first two detections have different objects, it iterates over the first two detections, calculates the real-world coordinates, and calls the `TransbotPerceiveVisual` function to perceive the visual information of the objects.\n\nNext, it checks if the object is too far to grab or if there is an obstacle on the right side. If either condition is true, it adds the corresponding obstacle input to the NAR system.\n\nAfter that, it displays the frame using the `cv.imshow` function.\n\nIf the line ends with \"! :|:\", it adds the input line to the NAR system and retrieves the number of executions from the result. It then enters a loop with a reasoning time limit and adds the input \"1\" to the NAR system in each iteration. It invokes the `TransbotExecute` function with the accumulated executions and checks if an action has been invoked. If an action has been invoked, it adds the remaining thinking time to the NAR system and breaks out of the loop.\n\nIf the line ends with \".\", \". :|:\", \"?\", or \"? :|:\", it simply adds the input line to the NAR system.\n\nIf the line is equal to \"*pick_with_feedback\", it calls the `pick_with_feedback` function.\n\nIf the line is equal to \"*left\", it calls the `left` function with an angular value of 0.6.\n\nIf the line is equal to \"*right\", it calls the `right` function with an angular value of 0.6.\n\nIf the line is equal to \"*forward\", it calls the `forward` function with a linear value of 0.6.\n\nIf the line is equal to \"*backward\", it calls the `backward` function with a linear value of 0.6.\n\nIf the line is equal to \"*arm_down\", it calls the `arm_down` function.\n\nIf the line is equal to \"*arm_up\", it calls the `arm_up` function.\n\nIf the line is equal to \"*pick\", it stops the operation using the `OpStop` function and then calls the `pick` function with the force parameter set to True.\n\nIf the line is equal to \"*drop\", it stops the operation using the `OpStop` function and then calls the `drop` function with the force parameter set to True.\n\nIf the line is equal to \"*droptrailer\", it calls the `drop_trailer` function with the force parameter set to True.\n\nIf the line is equal to \"*reset\", it sets the picked status to False using the `setPicked` function, stops the operation using the `OpStop` function, initializes the pose using the `init_pose` function, and resets the NAR system using the `reset_ona` function.\n\nIf the line is a digit or starts with \"*volume\", \"*motorbabbling\", or ends with \"}\", it adds the line to the NAR system.\n\nFinally, the function returns the value of the `ActionInvoked` variable.\n\n**Note**: \n- The `process` function handles different"
      ],
      "code_start_line": 237,
      "code_end_line": 344,
      "parent": null,
      "params": [
        "line"
      ],
      "have_return": true,
      "code_content": "def process(line):\n    ActionInvoked = False\n    if line != \"\":\n        if line.endswith(\"? :|:\") and \"{SELF}\" in line:\n            (trans, rot) = getLocation()\n            TransbotPerceiveAt(\"{SELF}\", trans, rot)\n        if line.endswith(\"! :|:\") or line == \"*internal\":\n            if getPicked():\n                NAR.AddInput(\"<gripper --> [hold]>. :|:\")\n            else:\n                NAR.AddInput(\"<gripper --> [open]>. :|:\")\n        if line.endswith(\"! :|:\") or line == \"*see\":\n            collision = getCollision()\n            (trans, rot) = getLocation()\n            action = cv.waitKey(10) & 0xFF\n            detections, frame = detect_objects()\n            (obj_temp, x_real_temp, y_real_temp, w_temp, h_temp, c_temp, color_temp) = (\"\", -1, -1, -1, -1, 0, (0,0,0))\n            detections.sort(key=lambda d: -(d[2]+d[4]))\n            if len(detections) > 0:\n                (obj, x, y, w, h, c, color) = detections[0] #nearest\n                x_real = x+w/2\n                y_real = y+h #down side of bb\n                (obj_temp, x_real_temp, y_real_temp, w_temp, h_temp, c_temp, color_temp) = (obj, x_real, y_real, w, h, c, color)\n            if y_real_temp != -1 and y_real_temp >= y_too_far_to_grab:\n                if len(detections) >=2 and detections[0][0] == detections[1][0]: #same object, compare using Nalifier!\n                    detections_xsorted = [detections[0], detections[1]]\n                    detections_xsorted.sort(key=lambda x: x[1])\n                    color_insensitivity = 2.0\n                    size_insensitivity = 1.0\n                    maxSizeX = max(detections[0][3], detections[1][3])\n                    maxSizeY = max(detections[0][4], detections[1][4])\n                    extractVectors = lambda detection: ([detection[6][0]/(255.0 * color_insensitivity), detection[6][1]/(255.0 * color_insensitivity), detection[6][2]/(255.0 * color_insensitivity)],\n                                                        [detection[3]/(maxSizeX * size_insensitivity), detection[4]/(maxSizeY*size_insensitivity)]) #color and size thus far\n                    dleft = detections_xsorted[0]\n                    dright = detections_xsorted[1]\n                    color_left, size_left = extractVectors(dleft)\n                    color_right, size_right = extractVectors(dright)\n                    nalifier = Nalifier(1)\n                    nalifier.AddInputVector(\"left\", color_left, dimname=\"color\", UseHistogram=False)\n                    nalifier.AddInputVector(\"left\", size_left, dimname=\"size\", UseHistogram=False)\n                    nalifier.AddInput(\"1\", Print=False)\n                    nalifier.InstanceCreation = False\n                    nalifier.AddInputVector(\"right\", color_right, dimname=\"color\", UseHistogram=False)\n                    nalifier.AddInputVector(\"right\", size_right, dimname=\"size\", UseHistogram=False)\n                    nalifier.SUFFICIENT_MATCH_EXP = 0.0 #find nearest node\n                    nalifier.AddInput(\"1\", Print=True)\n                    #print(\"//color_left:\", color_left, \"color_right:\", color_right)\n                    #print(\"//size_left:\", size_left, \"size_right:\", size_right)\n                    biggestDifference = nalifier.BiggestDifference\n                    if biggestDifference[0] == \"+\":\n                        statement1 = f\"<({dright[0]} * [left]) --> (+ {biggestDifference[1]})>\"\n                        statement2 = f\"<([right] * {dleft[0]}) --> (+ {biggestDifference[1]})>\"\n                        NAR.AddInput(f\"({statement1} && {statement2}). :|:\")\n                    else:\n                        statement1 = f\"<([left] * {dright[0]}) --> (+ {biggestDifference[1]})>\"\n                        statement2 = f\"<({dleft[0]} * [right]) --> (+ {biggestDifference[1]})>\"\n                        NAR.AddInput(f\"({statement1} && {statement2}). :|:\")\n                else:\n                    for detection in detections[0:2]:\n                        (obj, x, y, w, h, c, color) = detection\n                        x_real = x+w/2\n                        y_real = y+h #down side of bb\n                        TransbotPerceiveVisual(obj, x_real, y_real, trans, rot)\n            if y_real_temp == -1 or y_real_temp < y_too_far_to_grab or x_real_temp > robotVisualMiddle-center_offset or collision != \"free\": #right side blocked by arm\n                NAR.AddInput(\"<obstacle --> [\" + collision + \"]>. :|:\")\n            cv.imshow('frame', frame)\n        if line.endswith(\"! :|:\"):\n            executions = NAR.AddInput(line)[\"executions\"] #account for mental op\n            reasoningtime = 10\n            for i in range(reasoningtime): #time limit to act\n                executions += NAR.AddInput(\"1\")[\"executions\"]\n                ActionInvoked = TransbotExecute(executions)\n                if ActionInvoked:\n                    NAR.AddInput(str(reasoningtime-(i+1))) #still same think time even when already reacted\n                    break #acted, done\n                executions = []\n        if line.endswith(\".\") or line.endswith(\". :|:\") or line.endswith(\"?\") or line.endswith(\"? :|:\"):\n            NAR.AddInput(line)\n        elif line == \"*pick_with_feedback\":\n            pick_with_feedback()\n        elif line == \"*left\":\n            left(angular=0.6)\n        elif line == \"*right\":\n            right(angular=0.6)\n        elif line == \"*forward\":\n            forward(linear=0.6)\n        elif line == \"*backward\":\n            backward(linear=0.6)\n        elif line == \"*arm_down\":\n            arm_down()\n        elif line == \"*arm_up\":\n            arm_up()\n        elif line == \"*pick\":\n            OpStop()\n            pick(force=True)\n        elif line == \"*drop\":\n            OpStop()\n            drop(force=True)\n        elif line == \"*droptrailer\":\n            drop_trailer(force=True)\n        elif line == \"*reset\":\n            setPicked(False)\n            OpStop()\n            init_pose()\n            reset_ona()\n        elif line.isdigit() or line.startswith(\"*volume\") or line.startswith(\"*motorbabbling\") or line.endswith(\"}\"):\n            NAR.AddInput(line)\n        return ActionInvoked\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/shell_step"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Nalifier",
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Nalifier/AddInput",
        "OpenNARS-for-Applications\\misc\\Python\\Nalifier.py/Nalifier/AddInputVector",
        "OpenNARS-for-Applications\\misc\\Python\\NAR.py/AddInput",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/pick_with_feedback",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/TransbotExecute",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/TransbotPerceiveAt",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/TransbotPerceiveVisual",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/reset_ona",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/arm_down",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/arm_up",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/init_pose",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/left",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/right",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/forward",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/backward",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/setPicked",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/getPicked",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/pick",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/drop",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/drop_trailer",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_lidar.py/getCollision",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_nav.py/OpStop",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_nav.py/getLocation",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_vision.py/detect_objects"
      ]
    },
    "shell_step": {
      "type": "FunctionDef",
      "name": "shell_step",
      "md_content": [
        "**shell_step**: The function of `shell_step` is to process the input line and perform various actions based on its content. It handles different types of commands and executes corresponding operations accordingly.\n\n**Parameters**:\n- `lastLine` (optional): A string representing the previous input line (default value: \"\").\n\n**Code Description**:\nThe `shell_step` function takes an input line as a parameter and performs different actions based on the content of the line. It first tries to read an input line from the user and removes any trailing newline characters. If an exception occurs during the input process, the function exits.\n\nNext, it checks if the input line is empty. If it is empty, it assigns the value of the previous input line to the `line` variable. Otherwise, it assigns the current input line to the `line` variable.\n\nThe function then prints the processed line by appending \"//PROCESSED LINE: \" to the line.\n\nThe function further checks if the line ends with \"! :|:\". If it does, it assigns the line to the `lastGoal` variable.\n\nIf the line starts with \"*clearpoints\", the `points` list is cleared, and the line is returned.\n\nIf the line starts with \"*point\", it extracts the location coordinates using the `getLocation` function and appends them to the `points` list. The line is then returned.\n\nIf the line starts with \"*patrol \", it extracts the number of repetitions from the line and iterates over the `points` list. For each point, it calls the `OpGo` function to navigate to the specified location, and then calls the `TransbotPerceiveAt` function to perceive the location of the transbot and the specified point. It also checks the `lastGoal` for a certain number of checkpoint decisions. If the `process` function returns True, indicating a successful decision, the loop breaks. The line is returned.\n\nIf the line starts with \"*savepoints\", it opens a file named \"points.json\" in write mode and writes the `points` list to the file in JSON format. The line is returned.\n\nIf the line starts with \"*loadpoints\", it opens a file named \"points.json\" in read mode and loads the contents of the file into the `points` list. The line is returned.\n\nIf the line starts with \"*hastrailer \", it extracts the value after the prefix and sets the global variable `hastrailer` to the corresponding boolean value. The line is returned.\n\nIf the line is equal to \"*loop\", it enters an infinite loop and repeatedly calls the `process` function with the `lastGoal` as the input.\n\nIf the line starts with \"*steps \", it extracts the number of steps from the line and iterates over the range of steps. In each iteration, it calls the `process` function with the `lastGoal` as the input. After the loop, it prints \"//\\*steps DONE\" to indicate the completion of the steps. The line is returned.\n\nFinally, the function calls the `process` function with the current input line and returns the line.\n\n**Note**:\n- The `shell_step` function relies on the `input` function to read user input from the console.\n- The `shell_step` function uses global variables `lastGoal` and `points` to store and retrieve data.\n- The `shell_step` function interacts with other functions such as `getLocation`, `OpGo`, and `TransbotPerceiveAt` to perform specific actions.\n- The `shell_step` function handles various commands and their corresponding operations, providing flexibility in controlling the behavior of the transbot.\n\n**Output Example**:\nIf the input line is \"*patrol 2\", the function will navigate to the specified points and perform the desired actions. The line \"*patrol 2\" will be returned."
      ],
      "code_start_line": 348,
      "code_end_line": 398,
      "parent": null,
      "params": [
        "lastLine"
      ],
      "have_return": true,
      "code_content": "def shell_step(lastLine = \"\"):\n    global lastGoal, points\n    #Get input line and forward potential command\n    try:\n        line = input().rstrip(\"\\n\").replace(\"leave\",\"Pleft\") #\"the green cat quickly eats the yellow mouse in the old house\"\n    except:\n        exit(0)\n    if len(line.strip()) == 0:\n        line = lastLine;\n    print(\"//PROCESSED LINE: \" + line)\n    if line.endswith(\"! :|:\"):\n        lastGoal = line\n    if line.startswith(\"*clearpoints\"):\n        points = []\n        return line\n    if line.startswith(\"*point\"): #define checkpoint\n        P = getLocation()\n        points.append(P)\n        return line\n    if line.startswith(\"*patrol \"): #how often to patrol the points that have been defined\n        repetitions = int(line.split(\"*patrol \")[1])\n        for i in range(repetitions):\n            for j, (trans, rot) in enumerate(points):\n                OpGo(trans[0], trans[1], rot[2], rot[3])\n                TransbotPerceiveAt(\"{P\" + str(j) + \"}\", trans, rot)\n                TransbotPerceiveAt(\"{SELF}\", trans, rot)\n                for i in range(checkpointdecisions):\n                    if process(lastGoal):\n                        break\n        return line\n    if line.startswith(\"*savepoints\"):\n        with open(\"points.json\", \"w\") as json_file:\n            json.dump(points, json_file)\n        return line\n    if line.startswith(\"*loadpoints\"):\n        with open(\"points.json\") as json_file:\n            points = json.load(json_file)\n        return line\n    if line.startswith(\"*hastrailer \"):\n        set_hastrailer(line.split(\"*hastrailer \")[1] in [\"true\", \"True\"])\n        return line\n    if line == \"*loop\": #endless sense-act cycle if desired\n        while True:\n            process(lastGoal)\n    if line.startswith(\"*steps \"): #k steps\n        steps = int(line.split(\"*steps \")[1])\n        for i in range(steps):\n            process(lastGoal)\n        print(\"//*steps DONE\")\n    process(line)\n    return line\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/transbot_shell"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/TransbotPerceiveAt",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/process",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/set_hastrailer",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_nav.py/OpGo",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_nav.py/getLocation"
      ]
    },
    "transbot_shell": {
      "type": "FunctionDef",
      "name": "transbot_shell",
      "md_content": [
        "**transbot_shell**: The function of `transbot_shell` is to create a shell for the transbot, allowing users to interact with the transbot and control its behavior through various commands.\n\n**Parameters**:\n- None\n\n**Code Description**:\nThe `transbot_shell` function initializes the `lastLine` variable with the value \"G! :|:\". It then enters an infinite loop, where it repeatedly calls the `shell_step` function with the `lastLine` as the input.\n\nWithin each iteration of the loop, the `shell_step` function processes the input line and performs various actions based on its content. It first tries to read an input line from the user and removes any trailing newline characters. If an exception occurs during the input process, the function exits.\n\nNext, it checks if the input line is empty. If it is empty, it assigns the value of the previous input line to the `line` variable. Otherwise, it assigns the current input line to the `line` variable.\n\nThe function then prints the processed line by appending \"//PROCESSED LINE: \" to the line.\n\nThe function further checks if the line ends with \"! :|:\". If it does, it assigns the line to the `lastGoal` variable.\n\nIf the line starts with \"*clearpoints\", the `points` list is cleared, and the line is returned.\n\nIf the line starts with \"*point\", it extracts the location coordinates using the `getLocation` function and appends them to the `points` list. The line is then returned.\n\nIf the line starts with \"*patrol \", it extracts the number of repetitions from the line and iterates over the `points` list. For each point, it calls the `OpGo` function to navigate to the specified location, and then calls the `TransbotPerceiveAt` function to perceive the location of the transbot and the specified point. It also checks the `lastGoal` for a certain number of checkpoint decisions. If the `process` function returns True, indicating a successful decision, the loop breaks. The line is returned.\n\nIf the line starts with \"*savepoints\", it opens a file named \"points.json\" in write mode and writes the `points` list to the file in JSON format. The line is returned.\n\nIf the line starts with \"*loadpoints\", it opens a file named \"points.json\" in read mode and loads the contents of the file into the `points` list. The line is returned.\n\nIf the line starts with \"*hastrailer \", it extracts the value after the prefix and sets the global variable `hastrailer` to the corresponding boolean value. The line is returned.\n\nIf the line is equal to \"*loop\", it enters an infinite loop and repeatedly calls the `process` function with the `lastGoal` as the input.\n\nIf the line starts with \"*steps \", it extracts the number of steps from the line and iterates over the range of steps. In each iteration, it calls the `process` function with the `lastGoal` as the input. After the loop, it prints \"//\\*steps DONE\" to indicate the completion of the steps. The line is returned.\n\nFinally, the function calls the `process` function with the current input line and returns the line.\n\n**Note**:\n- The `transbot_shell` function provides a shell interface for users to interact with the transbot and control its behavior.\n- The function relies on the `shell_step` function to process user input and perform various actions.\n- The function uses global variables `lastLine`, `lastGoal`, and `points` to store and retrieve data.\n- The function interacts with other functions such as `getLocation`, `OpGo`, and `TransbotPerceiveAt` to perform specific actions.\n- The function handles various commands and their corresponding operations, providing flexibility in controlling the behavior of the transbot.\n\n**Output Example**:\nIf the input line is \"*patrol 2\", the function will navigate to the specified points and perform the desired actions. The line \"*patrol 2\" will be returned."
      ],
      "code_start_line": 400,
      "code_end_line": 403,
      "parent": null,
      "params": [],
      "have_return": false,
      "code_content": "def transbot_shell():\n    lastLine = \"G! :|:\"\n    while True:\n        lastLine = shell_step(lastLine)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/shell_step"
      ]
    }
  },
  "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py": {
    "get_hastrailer": {
      "type": "FunctionDef",
      "name": "get_hastrailer",
      "md_content": [
        "**get_hastrailer**: The function of get_hastrailer is to return the value of the variable \"hastrailer\".\n\n**parameters**:\nThis Function does not take any parameters.\n\n**Code Description**:\nThe code for the get_hastrailer function is quite simple. It consists of a single line that returns the value of the variable \"hastrailer\". The purpose of this function is to provide access to the value of \"hastrailer\" to other parts of the code.\n\nIn the calling situation, the get_hastrailer function is called by the pick_with_feedback function in the transbot.py file. The pick_with_feedback function is responsible for picking up objects with the transbot robot. It checks if an object has been picked already and performs various actions based on the position of the object relative to the gripper. If the get_hastrailer function returns True, indicating that the transbot has a trailer attached, the pick_with_feedback function calls the drop_trailer function to detach the trailer before picking up a new object.\n\n**Note**:\nThere are no specific notes about the use of the get_hastrailer function.\n\n**Output Example**:\nIf the value of \"hastrailer\" is True, the get_hastrailer function will return True."
      ],
      "code_start_line": 8,
      "code_end_line": 9,
      "parent": null,
      "params": [],
      "have_return": true,
      "code_content": "def get_hastrailer():\n    return hastrailer\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/pick_with_feedback"
      ],
      "reference_who": []
    },
    "set_hastrailer": {
      "type": "FunctionDef",
      "name": "set_hastrailer",
      "md_content": [
        "**set_hastrailer**: The function of set_hastrailer is to set the value of the global variable \"hastrailer\" to the given input.\n\n**parameters**:\n- has: A boolean value indicating whether the transbot has a trailer or not.\n\n**Code Description**:\nThe set_hastrailer function is a simple function that takes a boolean value as input and assigns it to the global variable \"hastrailer\". The purpose of this function is to update the value of \"hastrailer\" based on the input provided.\n\nThis function is called in the \"shell_step\" function of the \"transbot.py\" file in the \"Transbot\" module of the \"misc\" package. In the \"shell_step\" function, if the input line starts with \"*hastrailer \", the value after the prefix is extracted and passed as an argument to the set_hastrailer function. The extracted value is then converted to a boolean value and assigned to the \"hastrailer\" global variable.\n\nThe \"set_hastrailer\" function is used to update the state of whether the transbot has a trailer or not. This information can be used in other parts of the code to determine the behavior or actions of the transbot when it has a trailer.\n\n**Note**: It is important to note that the \"set_hastrailer\" function directly modifies the global variable \"hastrailer\". Therefore, any changes made to \"hastrailer\" will affect the behavior of the transbot throughout the code."
      ],
      "code_start_line": 10,
      "code_end_line": 12,
      "parent": null,
      "params": [
        "has"
      ],
      "have_return": false,
      "code_content": "def set_hastrailer(has):\n    global hastrailer\n    hastrailer = has\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/shell_step"
      ],
      "reference_who": []
    },
    "jointangle": {
      "type": "FunctionDef",
      "name": "jointangle",
      "md_content": [
        "**jointangle**: The function of jointangle is to set the angle of a specific joint in the Transbot's gripper arm.\n\n**parameters**:\n- id: The ID of the joint to be set.\n- angle: The desired angle to set for the joint.\n\n**Code Description**:\nThe jointangle function begins by initializing a local variable `arm` as an instance of the Arm class. The function then sets the angle of the joint with the given ID to the specified angle by accessing the global `joints` list and updating the `angle` attribute of the corresponding joint. After setting the angle, the function sleeps for a duration specified by the `runtime` variable divided by 1000 to pause the execution for the given duration.\n\nNext, the function appends three joints (with IDs 7, 8, and 9) to the `joint` attribute of the `arm` object. Finally, the function publishes the `arm` object using the `pub_Arm` publisher.\n\nFrom a functional perspective, the `jointangle` function is responsible for adjusting the angle of a specific joint in the Transbot's gripper arm. It allows for precise control over the position of the gripper arm by setting the desired angle for a particular joint. This function is typically used in conjunction with other functions to perform complex movements or actions with the gripper arm.\n\nThe `jointangle` function is called by several other functions in the Transbot project:\n- `arm_down`: This function calls `jointangle` multiple times to move the gripper arm to a downward position.\n- `arm_up`: This function calls `jointangle` multiple times to move the gripper arm to an upward position.\n- `init_pose`: This function calls `jointangle` to set the angle of the joint with ID 9 to 30, as part of initializing the gripper arm to a specific pose.\n- `close_gripper`: This function calls `jointangle` to adjust the angle of the joint with ID 9 to gradually close the gripper.\n- `open_gripper`: This function calls `jointangle` to adjust the angle of the joint with ID 9 to open the gripper.\n\n**Note**: It is important to note that the `jointangle` function relies on the global `joints` list, which should be properly initialized and updated with the correct joint objects before calling this function. Additionally, the `runtime` variable should be set to an appropriate value to control the duration of the sleep between angle adjustments."
      ],
      "code_start_line": 30,
      "code_end_line": 38,
      "parent": null,
      "params": [
        "id",
        "angle"
      ],
      "have_return": false,
      "code_content": "def jointangle(id, angle):\n    global joints\n    arm = Arm()\n    joints[id].angle = angle\n    sleep(float(runtime)/1000.0)\n    arm.joint.append(joints[7])\n    arm.joint.append(joints[8])\n    arm.joint.append(joints[9])\n    pub_Arm.publish(arm)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/arm_down",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/arm_up",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/init_pose",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/close_gripper",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/open_gripper"
      ],
      "reference_who": []
    },
    "arm_down": {
      "type": "FunctionDef",
      "name": "arm_down",
      "md_content": [
        "**arm_down**: The function of arm_down is to move the gripper arm of the Transbot robot to a downward position.\n\n**Code Description**:\nThe `arm_down` function is responsible for moving the gripper arm of the Transbot robot to a downward position. It achieves this by calling the `jointangle` function multiple times with specific joint IDs and angles.\n\nThe function begins by calling the `jointangle` function with the joint ID 7 and an angle of 180. This sets the angle of the joint to 180 degrees. The function then sleeps for 0.5 seconds to pause the execution.\n\nNext, the `jointangle` function is called again with the joint ID 7 and the angle 180. This ensures that the joint angle remains at 180 degrees. The function sleeps for another 0.5 seconds.\n\nThe `jointangle` function is then called with the joint ID 8 and an angle of 220. This sets the angle of the joint to 220 degrees. The function sleeps for 0.5 seconds.\n\nSimilarly, the `jointangle` function is called again with the joint ID 8 and the angle 220 to maintain the joint angle. The function sleeps for another 0.5 seconds.\n\nFinally, the `jointangle` function is called with the joint ID 7 and an angle of 55. This sets the angle of the joint to 55 degrees. The function sleeps for 0.5 seconds.\n\nThe `jointangle` function is called once more with the joint ID 7 and the angle 55 to keep the joint angle at 55 degrees. The function sleeps for a final 0.5 seconds.\n\nOverall, the `arm_down` function moves the gripper arm of the Transbot robot to a downward position by adjusting the angles of specific joints using the `jointangle` function.\n\n**Note**: It is important to ensure that the `joints` list is properly initialized and updated with the correct joint objects before calling the `arm_down` function. Additionally, the `runtime` variable should be set to an appropriate value to control the duration of the sleep between angle adjustments."
      ],
      "code_start_line": 40,
      "code_end_line": 52,
      "parent": null,
      "params": [],
      "have_return": false,
      "code_content": "def arm_down():\n    jointangle(7, 180)\n    sleep(0.5)\n    jointangle(7, 180)\n    sleep(0.5)\n    jointangle(8, 220)\n    sleep(0.5)\n    jointangle(8, 220)\n    sleep(0.5)\n    jointangle(7, 55)\n    sleep(0.5)\n    jointangle(7, 55)\n    sleep(0.5)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/pick_with_feedback",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/process",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/pick",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/drop"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/jointangle"
      ]
    },
    "arm_up": {
      "type": "FunctionDef",
      "name": "arm_up",
      "md_content": [
        "**arm_up**: The function of arm_up is to move the Transbot's gripper arm to an upward position.\n\n**Code Description**:\nThe `arm_up` function is responsible for moving the Transbot's gripper arm to an upward position. It achieves this by calling the `jointangle` function multiple times with specific joint IDs and angles. The function starts by calling `jointangle(7, 180)` twice, which sets the angle of joint 7 to 180 degrees. It then sleeps for 0.5 seconds.\n\nNext, the function calls `jointangle(8, 60 if hastrailer else 30)` twice. The angle of joint 8 is set to 60 degrees if the `hastrailer` variable is true, otherwise it is set to 30 degrees. Again, the function sleeps for 0.5 seconds.\n\nFinally, the function calls `jointangle(7, 210)` twice, setting the angle of joint 7 to 210 degrees. It sleeps for another 0.5 seconds.\n\nOverall, the `arm_up` function performs a sequence of joint angle adjustments to move the gripper arm to an upward position. It ensures precise control over the position of the arm by setting specific angles for the relevant joints.\n\n**Note**: It is important to note that the `arm_up` function relies on the `jointangle` function to adjust the angles of the joints. Therefore, the `jointangle` function should be properly implemented and available before calling `arm_up`. Additionally, the `hastrailer` variable may affect the angle of joint 8, so its value should be set appropriately before calling `arm_up`."
      ],
      "code_start_line": 54,
      "code_end_line": 66,
      "parent": null,
      "params": [],
      "have_return": false,
      "code_content": "def arm_up():\n    jointangle(7, 180)\n    sleep(0.5)\n    jointangle(7, 180)\n    sleep(0.5)\n    jointangle(8, 60 if hastrailer else 30)\n    sleep(0.5)\n    jointangle(8, 60 if hastrailer else 30)\n    sleep(0.5)\n    jointangle(7, 210)\n    sleep(0.5)\n    jointangle(7, 210)\n    sleep(0.5)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/pick_failed",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/pick_with_feedback",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/process",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/init_pose",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/pick",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/drop"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/jointangle"
      ]
    },
    "init_pose": {
      "type": "FunctionDef",
      "name": "init_pose",
      "md_content": [
        "**init_pose**: The function of init_pose is to initialize the pose of the Transbot's gripper arm.\n\n**Code Description**:\nThe `init_pose` function is responsible for initializing the pose of the Transbot's gripper arm. It achieves this by calling the `arm_up` function, which moves the gripper arm to an upward position. The `arm_up` function adjusts the angles of specific joints in the gripper arm to achieve the desired pose.\n\nThe `init_pose` function starts by calling the `arm_up` function, which sets the angles of the relevant joints to move the gripper arm to an upward position. It then sleeps for a duration of 0.5 seconds.\n\nAfter the sleep, the `init_pose` function calls the `jointangle` function twice. The `jointangle` function is responsible for setting the angle of a specific joint in the gripper arm. In this case, the `jointangle` function is called with the arguments `9` and `30`, which sets the angle of the joint with ID 9 to 30 degrees. The `jointangle` function then sleeps for another 0.5 seconds.\n\nOverall, the `init_pose` function initializes the pose of the Transbot's gripper arm by first moving it to an upward position using the `arm_up` function, and then setting the angle of the joint with ID 9 to 30 degrees using the `jointangle` function.\n\n**Note**: It is important to note that the `init_pose` function relies on the `arm_up` and `jointangle` functions to adjust the angles of the joints in the gripper arm. Therefore, these functions should be properly implemented and available before calling `init_pose`. Additionally, the duration of the sleep between angle adjustments can be adjusted by modifying the sleep duration in the code."
      ],
      "code_start_line": 68,
      "code_end_line": 73,
      "parent": null,
      "params": [],
      "have_return": false,
      "code_content": "def init_pose():\n    arm_up()\n    jointangle(9, 30)\n    sleep(0.5)\n    jointangle(9, 30)\n    sleep(0.5)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/process"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/jointangle",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/arm_up"
      ]
    },
    "angles": {
      "type": "FunctionDef",
      "name": "angles",
      "md_content": [
        "**angles**: The function of angles is to retrieve the joint angles of a robot arm.\n\n**parameters**:\n- None\n\n**Code Description**:\nThe `angles` function is responsible for obtaining the joint angles of a robot arm. It first waits for the RobotArm_client service to be available. Then, it creates a `RobotArmRequest` object and sets the `apply` attribute to \"getJoint\". \n\nNext, it initializes an empty dictionary called `joints` to store the joint angles. Inside a try-except block, it calls the RobotArm_client with the request. If the response received is an instance of `RobotArmResponse`, it prints the joint angles and iterates over each joint in the response. For each joint, it adds the joint ID and its corresponding angle to the `joints` dictionary.\n\nIf any exception occurs during the call to the RobotArm_client, it prints a message indicating that the joint angle couldn't be obtained.\n\nFinally, the function returns the `joints` dictionary containing the joint IDs and their respective angles.\n\nThis function is called by the `read_gripper_angle` function in the `transbot_gripper.py` file. The `read_gripper_angle` function initializes an empty dictionary called `ang` and enters a while loop until the joint angle with ID 9 is present in the `ang` dictionary. Inside the loop, it calls the `angles` function to retrieve the joint angles and assigns the result to the `ang` dictionary. Once the joint angle with ID 9 is present in the `ang` dictionary, it returns the corresponding angle.\n\n**Note**:\n- This function assumes that the `RobotArm_client` service is available.\n- The joint angles are stored in a dictionary where the keys are the joint IDs and the values are the corresponding angles.\n\n**Output Example**:\n```\n{\n    1: 0.5236,\n    2: -1.0472,\n    3: 0.7854,\n    4: -0.5236,\n    5: 1.0472,\n    6: -0.7854,\n    7: 0.5236,\n    8: -1.0472,\n    9: 0.7854\n}\n```"
      ],
      "code_start_line": 77,
      "code_end_line": 90,
      "parent": null,
      "params": [],
      "have_return": true,
      "code_content": "def angles():\n    RobotArm_client.wait_for_service()\n    request = RobotArmRequest()\n    request.apply = \"getJoint\"\n    joints = {}\n    try:\n        response = RobotArm_client.call(request)\n        if isinstance(response, RobotArmResponse):\n            print(response.RobotArm.joint)\n            for joint in response.RobotArm.joint:\n                joints[joint.id] = joint.angle\n    except Exception:\n        print(\"//couldn't get joint angle\")\n    return joints\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/read_gripper_angle"
      ],
      "reference_who": []
    },
    "read_gripper_angle": {
      "type": "FunctionDef",
      "name": "read_gripper_angle",
      "md_content": [
        "**read_gripper_angle**: The function of read_gripper_angle is to retrieve the angle of the gripper joint in a robot arm.\n\n**parameters**:\n- None\n\n**Code Description**:\nThe `read_gripper_angle` function is responsible for obtaining the angle of the gripper joint in a robot arm. It initializes an empty dictionary called `ang` to store the joint angles. \n\nInside a while loop, it checks if the joint angle with ID 9 is present in the `ang` dictionary. If not, it calls the `angles` function to retrieve the joint angles and assigns the result to the `ang` dictionary. This loop continues until the joint angle with ID 9 is present in the `ang` dictionary.\n\nOnce the joint angle with ID 9 is present in the `ang` dictionary, the function returns the corresponding angle.\n\nThis function relies on the `angles` function, which is responsible for obtaining the joint angles of a robot arm. The `angles` function waits for the RobotArm_client service to be available and then sends a request to retrieve the joint angles. The joint angles are stored in a dictionary where the keys are the joint IDs and the values are the corresponding angles.\n\n**Note**:\n- This function assumes that the `RobotArm_client` service is available.\n- The joint angles are stored in a dictionary where the keys are the joint IDs and the values are the corresponding angles.\n\n**Output Example**:\n{\n    9: 0.7854\n}"
      ],
      "code_start_line": 92,
      "code_end_line": 96,
      "parent": null,
      "params": [],
      "have_return": true,
      "code_content": "def read_gripper_angle():\n    ang = {}\n    while 9 not in ang:\n        ang = angles()\n    return ang[9]\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/close_gripper"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/angles"
      ]
    },
    "close_gripper": {
      "type": "FunctionDef",
      "name": "close_gripper",
      "md_content": [
        "**close_gripper**: The function of close_gripper is to gradually close the gripper of the Transbot's arm until it reaches the target angle.\n\n**parameters**:\n- target_angle (optional): The desired angle to which the gripper should be closed. The default value is 30.\n\n**Code Description**:\nThe `close_gripper` function is responsible for closing the gripper of the Transbot's arm until it reaches the specified target angle. The function starts by initializing two local variables, `step_size` and `tolerance`, which determine the increment and the acceptable difference between the current angle and the target angle, respectively.\n\nThe function then defines a lambda function called `comparable`, which compares two angles and returns True if their absolute difference is less than or equal to the tolerance. This lambda function is used later to check if the current angle is close enough to the target angle.\n\nNext, the function initializes two empty lists, `last_angles` and `last_target_angles`, which will be used to store the previous angles and target angles for comparison.\n\nInside a while loop, the function checks if the target angle is less than or equal to 180 minus the step size. If not, it means that the gripper has reached or exceeded the maximum angle, and the function prints a feedback message and returns False along with the current target angle.\n\nIf the target angle is within the acceptable range, the function calls the `read_gripper_angle` function to retrieve the current angle of the gripper. It then prints a feedback message with the current angle and target angle, and appends the current angle and target angle to the respective lists.\n\nThe function then checks if the current angle is greater than or equal to 80 and if the previous two angles in the `last_angles` list are different and the difference between them is less than or equal to 3. If these conditions are met, it means that the gripper has encountered an obstacle and needs to stop. In this case, the function calls the `jointangle` function to adjust the angle of the gripper to the previous target angle, prints a feedback message, sleeps for 0.7 seconds, and returns True along with the current target angle.\n\nIf the current angle is not close enough to the target angle, the function checks if the target angle is comparable to the current angle using the `comparable` lambda function. If it is, the function increments the target angle by the step size, calls the `jointangle` function to adjust the angle of the gripper to the new target angle, sleeps for 0.7 seconds, and continues to the next iteration of the while loop.\n\nIf the current angle is not close enough to the target angle and not comparable, it means that the gripper cannot reach the target angle. In this case, the function returns False along with the current target angle.\n\nFinally, if the while loop exits without returning, it means that the gripper has reached the target angle. The function returns False along with the current target angle.\n\n**Note**: It is important to note that the `close_gripper` function relies on the `read_gripper_angle` and `jointangle` functions, which should be properly implemented and available before calling this function. Additionally, the function uses the global `joints` list to access and update the angle of the gripper joint.\n\n**Output Example**:\nFalse, 30"
      ],
      "code_start_line": 98,
      "code_end_line": 123,
      "parent": null,
      "params": [
        "target_angle"
      ],
      "have_return": true,
      "code_content": "def close_gripper(target_angle = 30):\n    step_size = 5.0\n    tolerance = 14.0\n    comparable = lambda x,y: abs(x-y) <= tolerance\n    last_angles = []\n    last_target_angles = []\n    while(target_angle <= 180-step_size):\n        if target_angle >= 160:\n            print(\"//FEEDBACK STOP 0\")\n            return False, target_angle\n        current_angle = read_gripper_angle()\n        print(\"//current angle and target angle %d %d\" % (current_angle, target_angle))\n        last_angles.append(current_angle)\n        last_target_angles.append(target_angle)\n        if current_angle >= 80 and len(last_angles) >= 2 and last_angles[-2] != last_angles[-1] and last_angles[-2] + 3 >= last_angles[-1]:\n            jointangle(9, last_target_angles[-2])\n            print(\"//FEEDBACK STOP 1\")\n            sleep(0.7)\n            return True, target_angle\n        if comparable(target_angle, current_angle):\n            target_angle += step_size\n            jointangle(9, target_angle)\n            sleep(0.7)\n        else:\n            return False, target_angle\n    return False, target_angle\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/pick_with_feedback",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/pick"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/jointangle",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/read_gripper_angle"
      ]
    },
    "open_gripper": {
      "type": "FunctionDef",
      "name": "open_gripper",
      "md_content": [
        "**open_gripper**: The function of open_gripper is to open the gripper of the Transbot's arm.\n\n**parameters**:\n- None\n\n**Code Description**:\nThe open_gripper function is responsible for opening the gripper of the Transbot's arm. It achieves this by calling the jointangle function twice with the same parameters. The jointangle function is used to set the angle of a specific joint in the gripper arm.\n\nThe open_gripper function first calls the jointangle function with the joint ID 9 and an angle of 30. This sets the angle of the joint to 30, which corresponds to an open position for the gripper. After setting the angle, the function pauses the execution for 1 second using the sleep function.\n\nNext, the function calls the jointangle function again with the same parameters. This ensures that the gripper remains in the open position for another 1 second before the function completes.\n\nThe open_gripper function is typically used in conjunction with other functions to perform actions such as picking up or releasing objects. By calling the jointangle function with the appropriate parameters, the open_gripper function allows for precise control over the position of the gripper arm.\n\n**Note**: It is important to note that the open_gripper function does not take any parameters. The gripper arm should be properly initialized and the global `joints` list should be correctly updated with the joint objects before calling this function. Additionally, the `runtime` variable should be set to an appropriate value to control the duration of the sleep between angle adjustments."
      ],
      "code_start_line": 125,
      "code_end_line": 129,
      "parent": null,
      "params": [],
      "have_return": false,
      "code_content": "def open_gripper():\n    jointangle(9, 30)\n    sleep(1)\n    jointangle(9, 30)\n    sleep(1)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/pick_failed",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/pick_with_feedback",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/pick",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/drop",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/drop_trailer"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/jointangle"
      ]
    },
    "left": {
      "type": "FunctionDef",
      "name": "left",
      "md_content": [
        "**left**: The function of left is to control the movement of the transbot gripper to the left.\n\n**parameters**:\n- angular: (optional) The angular velocity of the transbot gripper. Default value is the angular velocity defined in the transbot_gripper.py module.\n\n**Code Description**:\nThe `left` function is responsible for moving the transbot gripper to the left. It first creates a `Twist` object to store the linear and angular velocities. The linear velocity in the x-axis is set to 0, indicating no movement in that direction. The angular velocity in the z-axis is set to the provided `angular` value or the default angular velocity defined in the `transbot_gripper.py` module.\n\nAfter setting the velocities, the function publishes the `Twist` message to the `pub_vel` topic using the `pub_vel.publish(twist)` command. This allows the transbot to receive the velocity commands and execute the corresponding movement.\n\nA sleep of 0.2 seconds is added to ensure that the transbot has enough time to process the velocity command before executing the next set of commands.\n\nFinally, the function sets the linear and angular velocities to 0, effectively stopping the movement of the transbot gripper, and publishes the updated `Twist` message to the `pub_vel` topic.\n\n**Note**: \n- The `angular` parameter is optional and can be used to adjust the angular velocity of the transbot gripper. If not provided, the default angular velocity defined in the `transbot_gripper.py` module will be used.\n- It is important to ensure that the `pub_vel` topic is properly configured and subscribed to by the transbot in order for the movement commands to be executed correctly."
      ],
      "code_start_line": 137,
      "code_end_line": 145,
      "parent": null,
      "params": [
        "angular"
      ],
      "have_return": false,
      "code_content": "def left(angular=angular):\n    twist = Twist()\n    twist.linear.x = 0\n    twist.angular.z = angular\n    pub_vel.publish(twist)\n    sleep(0.2)\n    twist.linear.x = 0\n    twist.angular.z = 0\n    pub_vel.publish(twist)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/pick_with_feedback",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/TransbotExecute",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/process",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/drop_trailer"
      ],
      "reference_who": []
    },
    "right": {
      "type": "FunctionDef",
      "name": "right",
      "md_content": [
        "**right**: The function of right is to make the Transbot move to the right by adjusting its angular velocity.\n\n**parameters**:\n- angular: (optional) The angular velocity of the Transbot. Default value is the angular velocity of the Transbot.\n\n**Code Description**:\nThe `right` function is responsible for making the Transbot move to the right. It achieves this by adjusting the angular velocity of the Transbot. \n\nFirst, a `Twist` object is created to store the linear and angular velocities of the Transbot. The linear velocity in the x-axis is set to 0, indicating that the Transbot should not move in a straight line. The angular velocity in the z-axis is set to the negative value of the `angular` parameter, which determines the speed at which the Transbot rotates to the right.\n\nNext, the `pub_vel` object publishes the updated twist message, causing the Transbot to move to the right. A sleep of 0.2 seconds is then executed to allow the Transbot to move for a short duration.\n\nAfter the sleep, the twist message is reset to stop the Transbot's movement. The linear velocity is set to 0, indicating no movement in a straight line, and the angular velocity is set to 0, indicating no rotation.\n\nFinally, the updated twist message is published again using the `pub_vel` object, effectively stopping the Transbot's movement.\n\nFrom a functional perspective, the `right` function is called in the `pick_failed` function of the `transbot.py` file. In this context, the `right` function is used to adjust the Transbot's position after a failed attempt to pick an object. By moving to the right, the Transbot can reposition itself and make another attempt to pick the object.\n\n**Note**: It is important to note that the `right` function relies on the `pub_vel` object to publish the twist message and control the Transbot's movement. Additionally, the `angular` parameter allows for customization of the angular velocity, providing flexibility in adjusting the Transbot's rotation speed."
      ],
      "code_start_line": 147,
      "code_end_line": 155,
      "parent": null,
      "params": [
        "angular"
      ],
      "have_return": false,
      "code_content": "def right(angular=angular):\n    twist = Twist()\n    twist.linear.x = 0\n    twist.angular.z = -angular\n    pub_vel.publish(twist)\n    sleep(0.2)\n    twist.linear.x = 0\n    twist.angular.z = 0\n    pub_vel.publish(twist)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/pick_failed",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/pick_with_feedback",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/TransbotExecute",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/process",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/drop",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/drop_trailer"
      ],
      "reference_who": []
    },
    "forward": {
      "type": "FunctionDef",
      "name": "forward",
      "md_content": [
        "**forward**: The function of forward is to move the transbot gripper forward in a straight line with a specified linear velocity.\n\n**Parameters**:\n- linear: (optional) The linear velocity of the transbot gripper. Default value is 'linear'.\n\n**Code Description**:\nThe 'forward' function starts by creating a new instance of the 'Twist' class from the 'geometry_msgs.msg' module. This instance is used to set the linear and angular velocities of the transbot gripper's movement. The linear velocity is set to the value of the 'linear' parameter, while the angular velocity is set to 0.\n\nNext, the 'twist' object is published to the 'pub_vel' topic using the 'publish' method. This publishes the twist message, which represents the desired movement of the transbot gripper.\n\nAfter publishing the twist message, the function pauses for 0.2 seconds using the 'sleep' function from the 'time' module.\n\nThen, the linear and angular velocities of the twist message are set to 0, effectively stopping the transbot gripper's movement. The updated twist message is published again.\n\n**Note**: \n- The 'linear' parameter determines the speed at which the transbot gripper moves forward. Positive values make it move forward, while negative values make it move backward.\n- The 'pub_vel' topic is assumed to be a publisher for the twist message, which controls the movement of the transbot gripper."
      ],
      "code_start_line": 157,
      "code_end_line": 165,
      "parent": null,
      "params": [
        "linear"
      ],
      "have_return": false,
      "code_content": "def forward(linear=linear):\n    twist = Twist()\n    twist.linear.x = linear\n    twist.angular.z = 0\n    pub_vel.publish(twist)\n    sleep(0.2)\n    twist.linear.x = 0\n    twist.angular.z = 0\n    pub_vel.publish(twist)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/pick_with_feedback",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/TransbotExecute",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/process",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/pick",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/drop",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/drop_trailer"
      ],
      "reference_who": []
    },
    "backward": {
      "type": "FunctionDef",
      "name": "backward",
      "md_content": [
        "**backward**: The function of backward is to make the transbot move backward with a specified linear velocity.\n\n**Parameters**:\n- linear: (optional) The linear velocity of the transbot. Default value is the value of the variable 'linear'.\n\n**Code Description**:\nThe 'backward' function initializes a Twist object named 'twist'. It sets the linear velocity of 'twist' to the negative value of the 'linear' parameter, and sets the angular velocity to 0. Then, it publishes the 'twist' message to the 'pub_vel' topic. After a sleep of 0.2 seconds, it sets the linear and angular velocities of 'twist' to 0, and publishes the updated 'twist' message to the 'pub_vel' topic again.\n\nThis function is called by the following objects in the project:\n1. 'pick_failed' function in the 'transbot.py' file: This function is called twice in the 'pick_failed' function to move the transbot backward.\n2. 'pick_with_feedback' function in the 'transbot.py' file: This function is not directly called by 'pick_with_feedback', but it is indirectly called by the 'pick_failed' function, which is called by 'pick_with_feedback'.\n3. 'process' function in the 'transbot.py' file: This function is not directly called by 'process', but it is indirectly called by the 'pick_failed' function, which is called by 'process'.\n\n**Note**: The 'backward' function can be used to make the transbot move backward with a specified linear velocity. The linear velocity determines the speed at which the transbot moves backward."
      ],
      "code_start_line": 167,
      "code_end_line": 175,
      "parent": null,
      "params": [
        "linear"
      ],
      "have_return": false,
      "code_content": "def backward(linear=linear):\n    twist = Twist()\n    twist.linear.x = -linear\n    twist.angular.z = 0\n    pub_vel.publish(twist)\n    sleep(0.2)\n    twist.linear.x = 0\n    twist.angular.z = 0\n    pub_vel.publish(twist)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/pick_failed",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/pick_with_feedback",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/process",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/pick",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/drop",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/drop_trailer"
      ],
      "reference_who": []
    },
    "setPicked": {
      "type": "FunctionDef",
      "name": "setPicked",
      "md_content": [
        "**setPicked**: The function of setPicked is to set the value of the global variable \"picked\" to the specified input value.\n\n**parameters**:\n- value: The value to be assigned to the global variable \"picked\".\n\n**Code Description**:\nThe setPicked function is a simple function that sets the value of the global variable \"picked\" to the specified input value. The global keyword is used to indicate that the variable \"picked\" is a global variable and can be accessed and modified from anywhere in the code.\n\nThis function is called by the following objects in the project:\n\n1. OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/pick_with_feedback:\n   - The pick_with_feedback function is a complex function that involves object detection and manipulation using a robot arm. It checks if an object has already been picked by calling the getPicked function. If an object has not been picked, it performs a series of actions to detect and pick the desired object. If the pick is successful, it calls the setPicked function with the value True to indicate that an object has been picked.\n\n2. OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/process:\n   - The process function is a function that processes a line of input. It performs various actions based on the input line. If the input line ends with \"! :|:\" or is equal to \"*internal\", it checks if an object has been picked by calling the getPicked function. If an object has been picked, it calls the setPicked function with the value True. If an object has not been picked, it calls the setPicked function with the value False.\n\n**Note**: The setPicked function is a simple function that is used to set the value of the global variable \"picked\". It is called in different contexts within the project to indicate whether an object has been picked or not."
      ],
      "code_start_line": 178,
      "code_end_line": 180,
      "parent": null,
      "params": [
        "value"
      ],
      "have_return": false,
      "code_content": "def setPicked(value):\n    global picked\n    picked = value\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/pick_with_feedback",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/process"
      ],
      "reference_who": []
    },
    "getPicked": {
      "type": "FunctionDef",
      "name": "getPicked",
      "md_content": [
        "**getPicked**: The function of getPicked is to return the value of the variable \"picked\".\n\n**Code Description**: The getPicked function is a simple function that returns the value of the variable \"picked\". It does not take any parameters. The purpose of this function is to provide the current value of the \"picked\" variable to other parts of the code.\n\nIn the code provided, the getPicked function is called by the \"pick_with_feedback\" function in the \"transbot.py\" file. This function checks if an object has already been picked by calling the getPicked function. If an object has already been picked, the function returns without performing any further actions. If no object has been picked, the function continues with the rest of its logic.\n\n**Note**: The getPicked function does not modify the value of the \"picked\" variable. It only returns its current value.\n\n**Output Example**: \nIf the value of the \"picked\" variable is True, the getPicked function will return True.\nIf the value of the \"picked\" variable is False, the getPicked function will return False."
      ],
      "code_start_line": 181,
      "code_end_line": 182,
      "parent": null,
      "params": [],
      "have_return": true,
      "code_content": "def getPicked():\n    return picked\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/pick_with_feedback",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/process"
      ],
      "reference_who": []
    },
    "pick": {
      "type": "FunctionDef",
      "name": "pick",
      "md_content": [
        "**pick**: The function of pick is to pick up an object using the Transbot's gripper arm.\n\n**parameters**:\n- force (optional): A boolean parameter that determines whether the pick action should be forced, regardless of the current state of the gripper. The default value is False.\n\n**Code Description**:\nThe `pick` function is responsible for picking up an object using the Transbot's gripper arm. It begins by checking the global variable `picked` and the `force` parameter to determine if the pick action should be performed. If `picked` is True and `force` is False, the function immediately returns without performing any actions.\n\nIf the pick action is not skipped, the function proceeds to call the `arm_down` function, which moves the gripper arm to a downward position. This is done by adjusting the angles of specific joints using the `jointangle` function.\n\nAfter moving the arm down, the function calls the `forward` function to move the Transbot forward in a straight line. The linear velocity of the Transbot can be specified using the `linear` parameter of the `forward` function.\n\nNext, the function calls the `close_gripper` function to gradually close the gripper until it reaches the target angle. The target angle can be specified using the `target_angle` parameter of the `close_gripper` function.\n\nIf the `close_gripper` function returns False, indicating that the gripper failed to close, the function calls the `open_gripper` function to open the gripper.\n\nThe function then updates the global variable `picked` with the feedback from the `close_gripper` function. If the gripper successfully closed, `picked` is set to True. Otherwise, it is set to False.\n\nAfter picking up the object, the function calls the `arm_up` function to move the gripper arm to an upward position.\n\nFinally, the function calls the `backward` function to move the Transbot backward, effectively reversing the previous forward movement. The linear velocity of the Transbot can be specified using the `linear` parameter of the `backward` function.\n\nThe function returns the feedback from the `close_gripper` function, indicating whether the gripper successfully closed or not.\n\n**Note**: \n- The `pick` function relies on several other functions, including `arm_down`, `forward`, `close_gripper`, `open_gripper`, `arm_up`, and `backward`. These functions should be properly implemented and available before calling the `pick` function.\n- The global variable `picked` should be properly initialized and updated with the correct state of the gripper before calling the `pick` function.\n- The `force` parameter can be used to override the current state of the gripper and force the pick action to be performed.\n- The `linear` parameter of the `forward` and `backward` functions determines the speed at which the Transbot moves forward or backward.\n- The `target_angle` parameter of the `close_gripper` function determines the desired angle to which the gripper should be closed.\n- The `picked` variable is updated with the feedback from the `close_gripper` function, indicating whether the gripper successfully closed or not.\n- The `picked` variable can be used to check the current state of the gripper after calling the `pick` function.\n- It is important to ensure that the necessary hardware and software components are properly set up and configured for the Transbot robot before using the `pick` function.\n\n**Output Example**:\nTrue"
      ],
      "code_start_line": 184,
      "code_end_line": 196,
      "parent": null,
      "params": [
        "force"
      ],
      "have_return": true,
      "code_content": "def pick(force=False):\n    global picked\n    if picked and not force:\n        return\n    arm_down()\n    forward()\n    feedback = close_gripper()\n    if not feedback:\n        open_gripper()\n    picked = feedback\n    arm_up()\n    backward()\n    return feedback\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/process"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/arm_down",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/arm_up",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/close_gripper",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/open_gripper",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/forward",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/backward"
      ]
    },
    "drop": {
      "type": "FunctionDef",
      "name": "drop",
      "md_content": [
        "**drop**: The function of drop is to release the object held by the Transbot's gripper arm.\n\n**Parameters**:\n- force: (optional) A boolean value indicating whether to force the release of the object. Default value is False.\n\n**Code Description**:\nThe `drop` function is responsible for releasing the object held by the Transbot's gripper arm. It first checks if there is an object held by the gripper arm and if the `force` parameter is set to False. If there is no object held and `force` is False, the function simply returns without performing any action.\n\nIf there is an object held or `force` is True, the function proceeds with the following steps:\n1. It calls the `forward` function to move the Transbot forward.\n2. It calls the `arm_down` function to move the gripper arm to a downward position.\n3. It calls the `open_gripper` function to open the gripper.\n4. It calls the `arm_up` function to move the gripper arm to an upward position.\n5. It calls the `backward` function multiple times to move the Transbot backward.\n6. It calls the `right` function multiple times to make the Transbot move to the right.\n7. It sets the global variable `picked` to False, indicating that there is no object held by the gripper arm.\n\nThe `drop` function provides a sequence of actions to release the object held by the Transbot's gripper arm. It ensures that the gripper arm is properly positioned and the gripper is open before releasing the object. By moving the Transbot backward and to the right, it allows for a controlled release of the object.\n\n**Note**: It is important to note that the `drop` function relies on the `forward`, `arm_down`, `open_gripper`, `arm_up`, `backward`, and `right` functions to perform the necessary actions. Therefore, these functions should be properly implemented and available before calling the `drop` function. Additionally, the `force` parameter can be used to override the check for an object held by the gripper arm and force the release of the object."
      ],
      "code_start_line": 198,
      "code_end_line": 212,
      "parent": null,
      "params": [
        "force"
      ],
      "have_return": true,
      "code_content": "def drop(force=False):\n    global picked\n    if not picked and not force:\n        return\n    forward()\n    arm_down()\n    open_gripper()\n    arm_up()\n    backward()\n    backward()\n    backward()\n    backward()\n    right()\n    right()\n    picked = False\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/TransbotExecute",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/process"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/arm_down",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/arm_up",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/open_gripper",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/right",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/forward",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/backward"
      ]
    },
    "drop_trailer": {
      "type": "FunctionDef",
      "name": "drop_trailer",
      "md_content": [
        "**drop_trailer**: The function of drop_trailer is to release the trailer that has been picked up by the Transbot's gripper arm.\n\n**parameters**:\n- force: (optional) A boolean value indicating whether to force the trailer to be dropped even if it has not been picked up. The default value is False.\n- t: (optional) The duration in seconds for each movement step. The default value is 0.7.\n\n**Code Description**:\nThe `drop_trailer` function is responsible for releasing the trailer that has been picked up by the Transbot's gripper arm. It first checks if the trailer has been picked up and if the `force` parameter is set to False. If either condition is not met, the function returns without performing any actions.\n\nIf the trailer has been picked up and the `force` parameter is set to True or if the conditions for not returning have been met, the function proceeds to execute a series of movements to release the trailer.\n\nThe function starts by executing a loop that rotates the Transbot to the right using the `right` function with an angular velocity of 0.6. This rotation is performed for a total of 32 steps, with each step lasting for the duration specified by the `t` parameter.\n\nAfter the rotation, the Transbot moves forward in a straight line using the `forward` function with a linear velocity of 0.6. The duration of this movement step is also specified by the `t` parameter.\n\nNext, the Transbot performs another forward movement step to ensure that the trailer is completely released. This step is also executed using the `forward` function with a linear velocity of 0.6 and a duration of `t`.\n\nOnce the Transbot has moved forward, the `open_gripper` function is called to open the gripper of the Transbot's arm, releasing the trailer.\n\nAfter releasing the trailer, the Transbot moves backward in a straight line using the `backward` function with a linear velocity of 0.6. This movement step is performed for the duration specified by `t`.\n\nFinally, the Transbot performs another backward movement step to ensure that it is in the correct position after releasing the trailer. This step is executed using the `backward` function with a linear velocity of 0.6 and a duration of `t`.\n\nThe function then executes another loop to rotate the Transbot to the left using the `left` function with an angular velocity of 0.6. This rotation is performed for a total of 30 steps, with each step lasting for the duration specified by the `t` parameter.\n\nAfter the rotation, the `picked` global variable is set to False, indicating that the trailer has been successfully dropped.\n\n**Note**: It is important to note that the `drop_trailer` function takes two optional parameters: `force` and `t`. The `force` parameter allows for the trailer to be dropped even if it has not been picked up. The `t` parameter controls the duration of each movement step. By adjusting these parameters, the function can be customized to meet specific requirements.\n\n**Output Example**: None"
      ],
      "code_start_line": 214,
      "code_end_line": 233,
      "parent": null,
      "params": [
        "force",
        "t"
      ],
      "have_return": true,
      "code_content": "def drop_trailer(force=False, t=0.7):\n    global picked\n    if not picked and not force:\n        return\n    for i in range(32):\n        right(angular=0.6)\n        sleep(t)\n    forward(linear=0.6)\n    sleep(t)\n    forward(linear=0.6)\n    sleep(t)\n    open_gripper()\n    backward(linear=0.6)\n    sleep(t)\n    backward(linear=0.6)\n    sleep(t)\n    for i in range(30):\n        left(angular=0.6)\n        sleep(t)\n    picked = False\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/pick_with_feedback",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/process"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/open_gripper",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/left",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/right",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/forward",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_gripper.py/backward"
      ]
    }
  },
  "OpenNARS-for-Applications\\misc\\Transbot\\transbot_lidar.py": {
    "registerScan": {
      "type": "FunctionDef",
      "name": "registerScan",
      "md_content": [
        "**registerScan**: The function of registerScan is to record the laser scan data and publish the position of the nearest object or point.\n\n**parameters**:\n- scan_data: The input parameter representing the laser scan data.\n\n**Code Description**:\nThe registerScan function begins by initializing the global variables Left_warning, Right_warning, and front_warning to 0. These variables will be used to keep track of the number of warnings detected in different directions.\n\nThe function then converts the scan_data.ranges into a numpy array called \"ranges\". This array represents the distances measured by the laser scanner.\n\nNext, the function sorts the indices of the \"ranges\" array in ascending order using np.argsort(). This allows the function to process the points from closer to farther distances.\n\nThe function then enters a loop that iterates over the sorted indices. Within this loop, the function checks the length of the scan_data.ranges array to determine if it is a 720-point scan or a 360-point scan.\n\nFor a 720-point scan, the function checks if the index falls within the range of 20 to LaserAngle * 2 (where LaserAngle is a predefined constant). If the distance at that index is less than the ResponseDist (another predefined constant), the Left_warning counter is incremented.\n\nSimilarly, for indices falling within the range of (720 - LaserAngle * 2) to 700, the function checks if the distance is less than ResponseDist and increments the Right_warning counter.\n\nFor indices falling outside these two ranges (i.e., (700 <= i) or (i <= 20)), the function checks if the distance is less than or equal to ResponseDist and increments the front_warning counter.\n\nFor a 360-point scan, the function follows a similar logic but with different index ranges.\n\n**Note**: It is important to note that this function assumes the input scan_data.ranges array is either 720-point or 360-point. The function also relies on the predefined constants LaserAngle and ResponseDist to determine the ranges and thresholds for warning detection."
      ],
      "code_start_line": 13,
      "code_end_line": 45,
      "parent": null,
      "params": [
        "scan_data"
      ],
      "have_return": false,
      "code_content": "def registerScan(scan_data):\n    global Left_warning, Right_warning, front_warning\n    # 记录激光扫描并发布最近物体的位置（或指向某点）\n    # Record the laser scan and publish the position of the nearest object (or point to a point)\n    ranges = np.array(scan_data.ranges)\n    # 按距离排序以检查从较近的点到较远的点是否是真实的东西\n    # Sort by distance to check whether things are real from closer points to more distant points\n    sortedIndices = np.argsort(ranges)\n    Right_warning = 0\n    Left_warning = 0\n    front_warning = 0\n    #print \"scan_data:\", len(sortedIndices)\n    # if we already have a last scan to compare to:\n    for i in sortedIndices:\n        if len(np.array(scan_data.ranges)) == 720:\n            # 通过清除不需要的扇区的数据来保留有效的数据\n            # Keep valid data by purging data from unneeded sectors\n            if 20 < i < LaserAngle * 2:\n                if ranges[i] < ResponseDist: Left_warning += 1\n            elif (720 - LaserAngle * 2) < i < 700:\n                if ranges[i] < ResponseDist: Right_warning += 1\n            elif (700 <= i ) or ( i <= 20):\n                if ranges[i] <= ResponseDist: front_warning += 1\n        elif len(np.array(scan_data.ranges)) == 360:\n            # 通过清除不需要的扇区的数据来保留有效的数据\n            # Keep valid data by purging data from unneeded sectors\n            if 10 < i < LaserAngle:\n                if ranges[i] < ResponseDist: Left_warning += 1\n            elif (350 - LaserAngle) < i < 350:\n                if ranges[i] < ResponseDist: Right_warning += 1\n            elif (350 <= i <= 360) or (0<= i <=10):\n                # print (\"i: {},dist: {}\", format(i, ranges[i]))\n                if ranges[i] < ResponseDist: front_warning += 1\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "getCollision": {
      "type": "FunctionDef",
      "name": "getCollision",
      "md_content": [
        "**getCollision**: The function of getCollision is to determine the collision status of the Transbot based on the lidar sensor readings.\n\n**parameters**:\n- No parameters are required for this function.\n\n**Code Description**:\nThe getCollision function is responsible for determining the collision status of the Transbot based on the readings from the lidar sensor. The function first prints the lidar readings for front, left, and right directions. It then compares these readings to a threshold value of 10 to determine if a collision is imminent.\n\nIf the front_warning reading is greater than 10 and is also greater than both the Left_warning and Right_warning readings, the function returns \"front\" to indicate that a collision is likely to occur in the front direction.\n\nIf the Left_warning reading is greater than 10 and is also greater than both the front_warning and Right_warning readings, the function returns \"left\" to indicate that a collision is likely to occur in the left direction.\n\nIf the Right_warning reading is greater than 10 and is also greater than both the front_warning and Left_warning readings, the function returns \"right\" to indicate that a collision is likely to occur in the right direction.\n\nIf none of the above conditions are met, the function returns \"free\" to indicate that there is no immediate collision threat.\n\n**Note**:\n- The lidar readings for front_warning, Left_warning, and Right_warning should be provided before calling this function.\n- The threshold value for determining a collision can be adjusted by modifying the value of 10 in the code.\n\n**Output Example**:\nIf the lidar readings are as follows:\n- front_warning = 15\n- Left_warning = 5\n- Right_warning = 8\n\nThe function will return \"front\" as the collision status."
      ],
      "code_start_line": 50,
      "code_end_line": 58,
      "parent": null,
      "params": [],
      "have_return": true,
      "code_content": "def getCollision():\n    print(\"//lidar (front, left, right) =\", front_warning, Left_warning, Right_warning)\n    if front_warning > 10 and front_warning > Left_warning and front_warning > Right_warning:\n        return \"front\"\n    if Left_warning > 10 and Left_warning > front_warning and Left_warning > Right_warning:\n        return \"left\"\n    if Right_warning > 10 and Right_warning > front_warning and Right_warning > Left_warning:\n        return \"right\"\n    return \"free\"\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/process"
      ],
      "reference_who": []
    }
  },
  "OpenNARS-for-Applications\\misc\\Transbot\\transbot_nav.py": {
    "OpGo": {
      "type": "FunctionDef",
      "name": "OpGo",
      "md_content": [
        "**OpGo**: The function of OpGo is to send a goal to the action server for the Transbot to navigate to a specified location.\n\n**Parameters**:\n- x: The x-coordinate of the target point.\n- y: The y-coordinate of the target point.\n- z: The z-coordinate of the target point's orientation (default value: 0).\n- w: The w-coordinate of the target point's orientation (default value: 1).\n- frame_id: The frame ID of the target point (default value: 'map').\n\n**Code Description**:\nThe OpGo function initializes a MoveBaseGoal object and sets its target pose based on the provided parameters. The target pose includes the position (x, y) and orientation (z, w) of the target point. The function then sends the goal to the action server using the client object. It waits for the server to finish performing the action and checks if the result has arrived. If the result doesn't arrive, it logs an error message and shuts down the node. Otherwise, it returns the result of executing the action.\n\n**Note**:\n- The OpGo function requires the client object to be initialized before calling this function.\n- The frame_id parameter specifies the reference frame for the target point. The default value is 'map', which is commonly used in ROS for global coordinates.\n\n**Output Example**:\nThe function returns the result of executing the action, which can be used to determine the success or failure of the navigation task."
      ],
      "code_start_line": 14,
      "code_end_line": 34,
      "parent": null,
      "params": [
        "x",
        "y",
        "z",
        "w",
        "frame_id"
      ],
      "have_return": true,
      "code_content": "def OpGo(x, y, z=0, w=1, frame_id = 'map'):\n    goal = MoveBaseGoal()\n    goal.target_pose.header.frame_id = frame_id # \"base_link\";\n    goal.target_pose.header.stamp = rospy.Time.now()\n    # The location of the target point\n    goal.target_pose.pose.position.x = x\n    goal.target_pose.pose.position.y = y\n    # The posture of the target point. z=sin(angle/2) w=cos(angle/2)\n    goal.target_pose.pose.orientation.z = z\n    goal.target_pose.pose.orientation.w = w\n    # Sends the goal to the action server.\n    client.send_goal(goal)\n    # Waits for the server to finish performing the action.\n    wait = client.wait_for_result()\n    # If the result doesn't arrive, assume the Server is not available\n    if not wait:\n        rospy.logerr(\"Action server not available!\")\n        rospy.signal_shutdown(\"Action server not available!\")\n    else:\n    # Result of executing the action\n        return client.get_result()\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/TransbotExecute",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/shell_step"
      ],
      "reference_who": []
    },
    "OpStop": {
      "type": "FunctionDef",
      "name": "OpStop",
      "md_content": [
        "**OpStop**: The function of OpStop is to publish a GoalID message to stop the robot's navigation.\n\n**parameters**:\n- None\n\n**Code Description**:\nThe OpStop function is a simple function that publishes a GoalID message to stop the robot's navigation. It is called within the TransbotExecute function in the transbot.py file. \n\nWhen OpStop is called, it publishes a GoalID message using the pub_cancelgoal object. The GoalID message is created by calling the GoalID() constructor. This message is then published, indicating that the robot should stop its current navigation operation.\n\nThe purpose of calling OpStop within the TransbotExecute function is to ensure that the robot stops before executing any other actions. It is used in various conditional statements to stop the robot's movement in different scenarios, such as when the robot needs to move forward, turn left or right, pick or drop an object, or go to a specific location.\n\nBy calling OpStop before performing any action, the TransbotExecute function ensures that the robot stops its current navigation operation and performs the desired action safely.\n\n**Note**:\n- The OpStop function does not take any parameters.\n- The GoalID message published by OpStop is used to stop the robot's navigation operation.\n- OpStop is called within the TransbotExecute function to ensure that the robot stops before performing any other action."
      ],
      "code_start_line": 36,
      "code_end_line": 37,
      "parent": null,
      "params": [],
      "have_return": false,
      "code_content": "def OpStop():\n    pub_cancelgoal.publish(GoalID())\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/TransbotExecute",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/process"
      ],
      "reference_who": []
    },
    "getLocation": {
      "type": "FunctionDef",
      "name": "getLocation",
      "md_content": [
        "**getLocation**: The function of getLocation is to retrieve the current location of the Transbot.\n\n**Parameters**:\n- None\n\n**Code Description**:\nThe `getLocation` function is responsible for acquiring the current location of the Transbot. It first acquires a lock to ensure thread safety. Then, it creates copies of the `translation` and `rotation` lists using list comprehension. After that, it releases the lock to allow other threads to access the shared resources. Finally, it returns a tuple containing the copied `translation` and `rotation` lists.\n\nThis function is called by the `process` function in the `transbot.py` file. In the `process` function, if the input line ends with \"? :|:\" and contains \"{SELF}\", the `getLocation` function is invoked to retrieve the Transbot's location. The obtained location is then used to perceive the Transbot's position in the environment.\n\n**Note**:\n- The `lock` object is used to ensure thread safety when accessing the shared `translation` and `rotation` lists.\n- The returned location is a tuple containing the copied `translation` and `rotation` lists.\n\n**Output Example**:\n```\n([1.0, 2.0, 3.0], [0.0, 0.0, 0.0, 1.0])\n```"
      ],
      "code_start_line": 47,
      "code_end_line": 52,
      "parent": null,
      "params": [],
      "have_return": true,
      "code_content": "def getLocation():\n    lock.acquire()\n    copyTrans = [x for x in translation]\n    copyRot = [x for x in rotation]\n    lock.release()\n    return (copyTrans, copyRot)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/process",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/shell_step"
      ],
      "reference_who": []
    },
    "updateLocation": {
      "type": "FunctionDef",
      "name": "updateLocation",
      "md_content": [
        "**updateLocation**: The function of updateLocation is to continuously update the translation and rotation values of the robot's location based on the data received from the tf_echo command.\n\n**parameters**:\n- No parameters are required for this function.\n\n**Code Description**:\nThe updateLocation function starts by initializing the global variables `translation` and `rotation`. It then creates a subprocess using the `subprocess.Popen` method to run the `rosrun tf tf_echo /map base_link` command and redirects the output to a pipe.\n\nInside the while loop, the function reads each line of the output from the subprocess and checks if it contains the string \"Translation:\". If it does, it acquires a lock to ensure thread safety, extracts the translation values from the line, and assigns them to the `translation` variable. The lock is then released.\n\nSimilarly, if a line contains the string \"Rotation:\", the function acquires the lock, extracts the rotation values from the line, and assigns them to the `rotation` variable. The lock is released again.\n\nAfter each iteration of the while loop, the function sleeps for 0.1 seconds using the `time.sleep` method to avoid excessive CPU usage.\n\n**Note**:\n- This function relies on the `rosrun tf tf_echo /map base_link` command being available and providing the expected output format. Make sure that the command is properly installed and configured before using this function.\n- The `translation` and `rotation` variables are assumed to be defined and accessible in the global scope. Ensure that they are properly initialized before calling this function.\n- The use of locks (`lock.acquire()` and `lock.release()`) suggests that this function may be used in a multi-threaded environment where concurrent access to the `translation` and `rotation` variables is possible."
      ],
      "code_start_line": 54,
      "code_end_line": 67,
      "parent": null,
      "params": [],
      "have_return": false,
      "code_content": "def updateLocation():\n    global translation, rotation\n    proc = subprocess.Popen(['rosrun', 'tf', 'tf_echo', '/map', 'base_link'],stdout=subprocess.PIPE)\n    while True:\n      line = str(proc.stdout.readline())\n      if \"Translation:\" in line:\n          lock.acquire()\n          translation = [float(x.replace(\",\",\"\")) for x in line.split(\"[\")[1].split(\"]\")[0].split(\" \")]\n          lock.release()\n      if \"Rotation:\" in line:\n          lock.acquire()\n          rotation = [float(x.replace(\",\",\"\")) for x in line.split(\"[\")[1].split(\"]\")[0].split(\" \")]\n          lock.release()\n      time.sleep(0.1)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    }
  },
  "OpenNARS-for-Applications\\misc\\Transbot\\transbot_simulation.py": {
    "getPicked": {
      "type": "FunctionDef",
      "name": "getPicked",
      "md_content": [
        "**getPicked**: The function of getPicked is to retrieve the value of the variable \"picked\".\n\n**Code Description**: This function does not take any parameters. It simply returns the value of the variable \"picked\". The variable \"picked\" is assumed to be defined elsewhere in the code.\n\n**Note**: It is important to note that the value of \"picked\" is dependent on the context in which this function is called. If \"picked\" has not been assigned a value before calling this function, it will return None or an undefined value.\n\n**Output Example**: \nIf the value of \"picked\" is 5, calling this function will return 5."
      ],
      "code_start_line": 16,
      "code_end_line": 17,
      "parent": null,
      "params": [],
      "have_return": true,
      "code_content": "def getPicked():\n    return picked\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "setPicked": {
      "type": "FunctionDef",
      "name": "setPicked",
      "md_content": [
        "**setPicked**: The function of setPicked is to assign a value to the variable 'picked'.\n\n**parameters**:\n- value: The value to be assigned to the variable 'picked'.\n\n**Code Description**:\nThe setPicked function takes a single parameter 'value' and assigns it to the variable 'picked'. This function is used to update the value of the 'picked' variable with a new value.\n\n**Note**:\n- It is important to ensure that the 'value' parameter passed to the setPicked function is of the correct type and format, as the function does not perform any validation or type checking."
      ],
      "code_start_line": 19,
      "code_end_line": 20,
      "parent": null,
      "params": [
        "value"
      ],
      "have_return": false,
      "code_content": "def setPicked(value):\n    picked = value\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "detect_objects": {
      "type": "FunctionDef",
      "name": "detect_objects",
      "md_content": [
        "**detect_objects**: The function of detect_objects is to detect objects in a simulated environment.\n\n**parameters**:\n- No parameters.\n\n**Code Description**:\nThe detect_objects function is responsible for detecting objects in a simulated environment. It first checks the value of the global variable \"going\". If \"going\" is True, it sets \"going\" to False and returns a list containing a tuple representing a person object. The tuple consists of the following elements: object type (\"person\"), x-coordinate (0), y-coordinate (480), width (10), height (10), confidence score (0.9), and color (black). Additionally, an empty string is returned as the second element of the list.\n\nIf \"going\" is False, the function checks if the variable \"picked\" is True. If \"picked\" is True, it sets the object type to \"bottle\". If \"picked\" is False, it randomly selects an object type from the list [\"table\", \"person\"] using the random.choice() function. The function also randomly selects a y-coordinate from the list [0, 375, 375]. The remaining elements of the tuple representing the object are the same as in the previous case. Finally, the function returns a list containing the tuple representing the object and an empty string.\n\n**Note**:\n- The global variable \"going\" is assumed to be defined and accessible from within the function.\n- The variable \"picked\" is assumed to be defined and accessible from within the function.\n- The random.choice() function is assumed to be imported and available for use.\n\n**Output Example**:\n- If \"going\" is True:\n    - Output: ([(\"person\", 0, 480, 10, 10, 0.9, (0,0,0))], \"\")\n- If \"going\" is False and \"picked\" is True:\n    - Output: ([(\"bottle\", random_y_coordinate, 480, 10, 10, 0.9, (0,0,0))], \"\")\n- If \"going\" is False and \"picked\" is False:\n    - Output: ([(\"table\" or \"person\", random_y_coordinate, 480, 10, 10, 0.9, (0,0,0))], \"\")"
      ],
      "code_start_line": 22,
      "code_end_line": 27,
      "parent": null,
      "params": [],
      "have_return": true,
      "code_content": "def detect_objects():\n    global going\n    if going:\n        going = False\n        return ([(\"person\", 0, 480, 10, 10, 0.9, (0,0,0))], \"\")\n    return ([(\"bottle\" if not picked else random.choice([\"table\", \"person\"]), random.choice([0,375,375]), 480, 10, 10, 0.9, (0,0,0))], \"\")\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "getLocation": {
      "type": "FunctionDef",
      "name": "getLocation",
      "md_content": [
        "**getLocation**: The function of getLocation is to retrieve the current location of the Transbot.\n\n**parameters**:\n- This function does not take any parameters.\n\n**Code Description**:\nThe `getLocation` function is a simple function that returns the current location of the Transbot. The function does not require any input parameters. It directly returns a list containing two tuples. The first tuple represents the position of the Transbot in a three-dimensional coordinate system, while the second tuple represents the orientation of the Transbot in a four-dimensional coordinate system.\n\nThe position tuple contains three values: `(x, y, z)`, where `x` represents the Transbot's position along the x-axis, `y` represents the position along the y-axis, and `z` represents the position along the z-axis.\n\nThe orientation tuple contains four values: `(w, x, y, z)`, where `w` represents the scalar component of the quaternion representing the Transbot's orientation, and `x`, `y`, and `z` represent the vector components of the quaternion.\n\n**Note**:\n- This function assumes that the Transbot's location is already known and can be retrieved.\n- The position and orientation values are represented using tuples for convenience and to maintain the integrity of the returned data structure.\n\n**Output Example**:\nA possible example of the return value of the `getLocation` function is:\n```\n[(0, 0, 0), (0, 0, 0, 0)]\n```\nThis indicates that the Transbot is currently located at the position `(0, 0, 0)` and has an orientation represented by the quaternion `(0, 0, 0, 0)`."
      ],
      "code_start_line": 29,
      "code_end_line": 30,
      "parent": null,
      "params": [],
      "have_return": true,
      "code_content": "def getLocation():\n    return [(0,0,0),(0,0,0,0)]\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "getCollision": {
      "type": "FunctionDef",
      "name": "getCollision",
      "md_content": [
        "**getCollision**: The function of getCollision is to determine the collision status of a transbot.\n\n**parameters**:\n- This function does not take any parameters.\n\n**Code Description**:\nThe `getCollision` function is a simple function that determines the collision status of a transbot. It uses a random number generator to generate a random value between 0 and 1. If the generated value is greater than 0.3, the function returns \"free\", indicating that there is no collision. Otherwise, the function randomly selects one of the values from the list [\"front\", \"left\", \"right\"] and returns it, indicating the direction of the collision.\n\n**Note**:\n- This function does not require any parameters.\n- The collision status is determined randomly based on the generated value. The probability of returning \"free\" is 70%, while the probability of returning one of the collision directions (\"front\", \"left\", \"right\") is 30%.\n- The function uses the `random` module to generate random values.\n\n**Output Example**:\n- Example 1:\n  - Output: \"free\"\n  - Explanation: The generated random value is 0.8, which is greater than 0.3. Therefore, the function returns \"free\" to indicate that there is no collision.\n\n- Example 2:\n  - Output: \"left\"\n  - Explanation: The generated random value is 0.2, which is less than or equal to 0.3. Therefore, the function randomly selects \"left\" from the list [\"front\", \"left\", \"right\"] and returns it to indicate a collision on the left side."
      ],
      "code_start_line": 32,
      "code_end_line": 33,
      "parent": null,
      "params": [],
      "have_return": true,
      "code_content": "def getCollision():\n    return \"free\" if random.random() > 0.3 else random.choice([\"front\", \"left\", \"right\"])\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "OpStop": {
      "type": "FunctionDef",
      "name": "OpStop",
      "md_content": [
        "**OpStop**: The function of OpStop is to stop the operation of the transbot.\n\n**parameters**:\n- This Function does not take any parameters.\n\n**Code Description**:\nThe OpStop function is a simple function that does not have any code implementation. It serves as a placeholder for stopping the operation of the transbot. When called, this function does nothing and returns None.\n\n**Note**:\n- This function does not have any parameters, so it can be called without providing any arguments.\n- It is important to note that calling this function will not have any effect on the operation of the transbot unless it is integrated with other parts of the code that handle the actual stopping of the transbot."
      ],
      "code_start_line": 35,
      "code_end_line": 36,
      "parent": null,
      "params": [],
      "have_return": false,
      "code_content": "def OpStop():\n    None\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "forward": {
      "type": "FunctionDef",
      "name": "forward",
      "md_content": [
        "**forward**: The function of forward is to control the forward movement of the transbot.\n\n**parameters**:\n- linear: This parameter specifies the linear velocity of the transbot. It is an optional parameter with a default value of 0. \n\n**Code Description**:\nThe `forward` function is responsible for controlling the forward movement of the transbot. However, the code snippet provided does not contain any implementation details or logic for this function. It appears to be a placeholder or a stub function that does not perform any specific action.\n\n**Note**:\n- The `linear` parameter can be used to adjust the speed of the transbot's forward movement. By providing a positive value for `linear`, the transbot will move forward at a certain velocity. The magnitude of the value determines the speed of the movement. A value of 0 for `linear` will result in no forward movement."
      ],
      "code_start_line": 38,
      "code_end_line": 39,
      "parent": null,
      "params": [
        "linear"
      ],
      "have_return": false,
      "code_content": "def forward(linear=0):\n    None\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "left": {
      "type": "FunctionDef",
      "name": "left",
      "md_content": [
        "**left**: The function of left is to control the left movement of the Transbot simulation.\n\n**parameters**:\n- angular (optional): Specifies the angular velocity of the left movement. The default value is 0.\n\n**Code Description**:\nThe `left` function is responsible for controlling the left movement of the Transbot simulation. It takes an optional parameter `angular` which specifies the angular velocity of the left movement. By default, if no value is provided for `angular`, it is set to 0.\n\nThe function does not contain any code implementation or logic. It simply returns `None`, indicating that no action is performed by the function itself.\n\n**Note**:\n- To use the `left` function, you need to import the necessary modules and ensure that the Transbot simulation environment is set up correctly.\n- The `angular` parameter allows you to control the speed at which the Transbot moves to the left. You can specify a positive or negative value to control the direction and speed of the left movement.\n- If no value is provided for `angular`, the Transbot will not move to the left and will maintain its current position."
      ],
      "code_start_line": 41,
      "code_end_line": 42,
      "parent": null,
      "params": [
        "angular"
      ],
      "have_return": false,
      "code_content": "def left(angular=0):\n    None\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "right": {
      "type": "FunctionDef",
      "name": "right",
      "md_content": [
        "**right**: The function of right is to control the movement of the Transbot to turn right with a specified angular velocity.\n\n**parameters**:\n- angular (optional): The angular velocity of the Transbot's right turn. Default value is 0.\n\n**Code Description**:\nThe `right` function is used to control the movement of the Transbot by specifying the angular velocity for a right turn. The function takes an optional parameter `angular` which represents the angular velocity of the Transbot's right turn. If no value is provided for `angular`, the default value of 0 will be used.\n\nThe function does not return any value and its purpose is to initiate the right turn of the Transbot. The actual movement and duration of the turn will depend on the implementation of the Transbot's simulation.\n\n**Note**:\n- The `angular` parameter should be a numerical value representing the angular velocity in the appropriate units.\n- The Transbot's simulation environment should be properly set up and running for the `right` function to have any effect on the Transbot's movement."
      ],
      "code_start_line": 44,
      "code_end_line": 45,
      "parent": null,
      "params": [
        "angular"
      ],
      "have_return": false,
      "code_content": "def right(angular=0):\n    None\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "backward": {
      "type": "FunctionDef",
      "name": "backward",
      "md_content": [
        "**backward**: The function of backward is to control the backward movement of the Transbot.\n\n**parameters**:\n- linear: This parameter is optional and has a default value of 0. It controls the linear speed of the Transbot during backward movement. \n\n**Code Description**:\nThe `backward` function is a part of the Transbot simulation code. It is responsible for controlling the backward movement of the Transbot. The function takes an optional parameter `linear`, which determines the linear speed of the Transbot during backward movement. By default, the linear speed is set to 0, indicating that the Transbot will not move linearly while moving backward.\n\nThe implementation of the `backward` function is not provided in the code snippet. However, based on the available information, it can be inferred that the function does not perform any specific actions or operations. It simply returns `None`, indicating that no further processing or calculations are performed within the function.\n\n**Note**:\n- It is important to note that the `backward` function is a part of the Transbot simulation code and is specifically designed for controlling the backward movement of the Transbot.\n- The `linear` parameter can be used to adjust the linear speed of the Transbot during backward movement. Developers can pass a desired value for `linear` to control the speed accordingly.\n- If no value is provided for the `linear` parameter, the Transbot will not move linearly while moving backward."
      ],
      "code_start_line": 47,
      "code_end_line": 48,
      "parent": null,
      "params": [
        "linear"
      ],
      "have_return": false,
      "code_content": "def backward(linear=0):\n    None\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "pick": {
      "type": "FunctionDef",
      "name": "pick",
      "md_content": [
        "**pick**: The function of pick is to perform a specific action, but the code implementation is not provided.\n\n**parameters**:\n- This function does not have any parameters.\n\n**Code Description**:\nThe code for the `pick` function is not provided, so it is not possible to provide a detailed analysis or description of its implementation. However, based on the function name, it can be inferred that the purpose of this function is to perform a \"pick\" action. The specific details of how the pick action is performed, such as what is being picked and how it is being picked, are not available in the code snippet.\n\n**Note**:\nSince the code implementation is not provided, it is not possible to provide any specific points to note about the use of the code. Developers who intend to use this function should refer to the code implementation or any additional documentation that may be available to understand its usage and any specific considerations."
      ],
      "code_start_line": 50,
      "code_end_line": 51,
      "parent": null,
      "params": [],
      "have_return": false,
      "code_content": "def pick():\n    None\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "arm_down": {
      "type": "FunctionDef",
      "name": "arm_down",
      "md_content": [
        "**arm_down**: The function of arm_down is to perform a downward movement of the arm.\n\n**parameters**:\n- This function does not take any parameters.\n\n**Code Description**:\nThe `arm_down` function is a simple function that does not have any code implementation. It serves as a placeholder for the downward movement of the arm in the Transbot simulation. This function can be used as a reference point for developers to understand where the downward movement of the arm should be implemented in the code.\n\n**Note**:\n- This function does not have any code implementation and does not perform any action. It is meant to be filled with the appropriate code for the downward movement of the arm in the Transbot simulation."
      ],
      "code_start_line": 53,
      "code_end_line": 54,
      "parent": null,
      "params": [],
      "have_return": false,
      "code_content": "def arm_down():\n    None\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "arm_up": {
      "type": "FunctionDef",
      "name": "arm_up",
      "md_content": [
        "**arm_up**: The function of arm_up is to perform an action of lifting the arm.\n\n**parameters**:\n- This Function does not take any parameters.\n\n**Code Description**:\nThe `arm_up` function is a simple function that does not have any code implementation. It is used to represent the action of lifting the arm in a simulated environment. This function can be called to initiate the lifting action of the arm.\n\n**Note**:\n- This function does not have any parameters, so it can be called without passing any arguments.\n- The implementation of the lifting action is not provided in this code snippet. It is expected that the implementation will be provided elsewhere in the codebase."
      ],
      "code_start_line": 56,
      "code_end_line": 57,
      "parent": null,
      "params": [],
      "have_return": false,
      "code_content": "def arm_up():\n    None\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "close_gripper": {
      "type": "FunctionDef",
      "name": "close_gripper",
      "md_content": [
        "**close_gripper**: The function of close_gripper is to close the gripper of the Transbot robot to a specified target angle.\n\n**parameters**:\n- target_angle: (optional) The angle at which the gripper should be closed. The default value is 30 degrees.\n\n**Code Description**:\nThe close_gripper function is responsible for closing the gripper of the Transbot robot. It takes an optional parameter, target_angle, which specifies the angle at which the gripper should be closed. If no target_angle is provided, the gripper will be closed to a default angle of 30 degrees.\n\nInside the function, the global variable picked is set to True, indicating that an object has been picked up by the gripper. Then, the function returns a tuple with two values: True and 0. The first value indicates the success of the gripper closing operation, and the second value represents any additional information related to the operation.\n\n**Note**:\n- The close_gripper function assumes that the Transbot robot is capable of closing its gripper to the specified angle.\n- The target_angle parameter is optional, and if not provided, the gripper will close to a default angle of 30 degrees.\n- The global variable picked is used to keep track of whether an object has been picked up by the gripper. It is set to True inside the close_gripper function.\n\n**Output Example**:\n(True, 0)"
      ],
      "code_start_line": 59,
      "code_end_line": 62,
      "parent": null,
      "params": [
        "target_angle"
      ],
      "have_return": true,
      "code_content": "def close_gripper(target_angle = 30):\n    global picked\n    picked = True\n    return True, 0\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "open_gripper": {
      "type": "FunctionDef",
      "name": "open_gripper",
      "md_content": [
        "**open_gripper**: The function of open_gripper is to perform the action of opening the gripper.\n\n**parameters**:\n- This function does not take any parameters.\n\n**Code Description**:\nThe `open_gripper` function is a simple function that does not take any parameters. It is responsible for opening the gripper. However, the code implementation of this function is not provided, so it is not possible to provide a detailed analysis of the code.\n\n**Note**:\n- This function assumes that the gripper is in a closed state before it is called.\n- It is important to ensure that the gripper is properly calibrated and functioning correctly before calling this function.\n- This function does not return any value, as its purpose is to perform an action rather than to provide a result."
      ],
      "code_start_line": 64,
      "code_end_line": 65,
      "parent": null,
      "params": [],
      "have_return": false,
      "code_content": "def open_gripper():\n    None\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "OpGo": {
      "type": "FunctionDef",
      "name": "OpGo",
      "md_content": [
        "**OpGo**: The function of OpGo is to set the global variable \"going\" to True if the given frame_id is equal to 'map'.\n\n**parameters**:\n- x: The x-coordinate of the destination.\n- y: The y-coordinate of the destination.\n- z: The z-coordinate of the destination (default value is 0).\n- w: The weight of the destination (default value is 1).\n- frame_id: The frame identifier (default value is 'map').\n\n**Code Description**:\nThe OpGo function is used to set the global variable \"going\" to True if the given frame_id is equal to 'map'. This function takes in five parameters: x, y, z, w, and frame_id. The x and y parameters represent the coordinates of the destination, while the z parameter represents the z-coordinate of the destination (default value is 0). The w parameter represents the weight of the destination (default value is 1). The frame_id parameter represents the frame identifier (default value is 'map').\n\nInside the function, there is a global variable called \"going\" which is set to True if the frame_id is equal to 'map'. This means that if the frame_id is not 'map', the \"going\" variable will not be changed.\n\n**Note**:\n- It is important to note that the OpGo function only sets the \"going\" variable to True if the frame_id is equal to 'map'. If the frame_id is different, the \"going\" variable will not be modified.\n- The OpGo function does not return any value. Its purpose is to update the global variable \"going\" based on the given frame_id."
      ],
      "code_start_line": 67,
      "code_end_line": 70,
      "parent": null,
      "params": [
        "x",
        "y",
        "z",
        "w",
        "frame_id"
      ],
      "have_return": false,
      "code_content": "def OpGo(x, y, z=0, w=1, frame_id = 'map'):\n    global going\n    if frame_id == 'map':\n        going = True\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "drop": {
      "type": "FunctionDef",
      "name": "drop",
      "md_content": [
        "**drop**: The function of drop is to set the global variable \"picked\" to False.\n\n**parameters**:\n- None\n\n**Code Description**:\nThe \"drop\" function is a simple function that sets the global variable \"picked\" to False. The global keyword is used to indicate that the variable \"picked\" is a global variable and not a local variable within the function. By setting \"picked\" to False, it indicates that the object has dropped whatever it was previously holding.\n\n**Note**:\n- This function does not take any parameters.\n- The global keyword is used to modify the variable \"picked\" in the global scope."
      ],
      "code_start_line": 72,
      "code_end_line": 75,
      "parent": null,
      "params": [],
      "have_return": false,
      "code_content": "def drop():\n    global picked\n    picked = False\n    None\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "get_hastrailer": {
      "type": "FunctionDef",
      "name": "get_hastrailer",
      "md_content": [
        "**get_hastrailer**: The function of get_hastrailer is to determine whether the transbot has a trailer attached to it.\n\n**Code Description**: This function is a simple boolean function that returns False. It does not take any parameters.\n\n**Note**: This function does not have any parameters and always returns False. It is used to check if the transbot has a trailer attached to it. If the function returns False, it means that the transbot does not have a trailer.\n\n**Output Example**: The function will always return False."
      ],
      "code_start_line": 77,
      "code_end_line": 78,
      "parent": null,
      "params": [],
      "have_return": true,
      "code_content": "def get_hastrailer():\n    return False\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "FakeCV": {
      "type": "ClassDef",
      "name": "FakeCV",
      "md_content": [
        "**FakeCV**: The function of FakeCV is to provide basic computer vision functionalities for image processing and display.\n\n**attributes**:\n- None\n\n**Code Description**:\nThe FakeCV class is a simple implementation of computer vision functionalities for image processing and display. It contains two methods: `waitKey` and `imshow`.\n\nThe `waitKey` method takes a single parameter `wtf`, which is not used in the method. It returns 0, indicating that no key was pressed. This method is typically used to introduce a delay in the execution of a program until a key is pressed.\n\nThe `imshow` method takes two parameters: `frame` and `k`. The `frame` parameter represents the image frame to be displayed, while the `k` parameter is not used in the method. This method does not perform any actual image display, as the implementation is not provided. It simply returns None. The `imshow` method is commonly used to display images in computer vision applications.\n\n**Note**:\n- The `waitKey` method is often used in conjunction with the `imshow` method to display images and wait for user input.\n- The `imshow` method does not provide an actual image display implementation. Developers need to implement the image display functionality separately.\n\n**Output Example**:\nA possible usage of the `waitKey` method:\n```\nfake_cv = FakeCV()\nkey = fake_cv.waitKey(0)\nprint(key)\n```\nOutput:\n```\n0\n```\n\nA possible usage of the `imshow` method:\n```\nfake_cv = FakeCV()\nframe = load_image(\"image.jpg\")\nfake_cv.imshow(frame, 0)\n```"
      ],
      "code_start_line": 80,
      "code_end_line": 84,
      "parent": null,
      "params": [],
      "have_return": true,
      "code_content": "class FakeCV:\n    def waitKey(self, wtf):\n        return 0\n    def imshow(self, frame, k):\n        None\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "waitKey": {
      "type": "FunctionDef",
      "name": "waitKey",
      "md_content": [
        "**waitKey**: The function of waitKey is to wait for a keyboard event and return the key code of the pressed key.\n\n**parameters**:\n- wtf: This parameter is not used in the function and can be ignored.\n\n**Code Description**:\nThe waitKey function is a method of the Transbot class. It takes one parameter, wtf, which is not used in the function. The purpose of this function is to pause the program execution and wait for a keyboard event. Once a key is pressed, the function will return the key code of the pressed key.\n\n**Note**:\n- The waitKey function is typically used in computer vision applications to allow the user to interact with the program by pressing keys on the keyboard.\n- The key code returned by waitKey can be used to perform different actions based on the key pressed. For example, different keys can be mapped to different functions or operations within the program.\n\n**Output Example**:\nThe waitKey function returns an integer value representing the key code of the pressed key. In this case, the function always returns 0, indicating that no key has been pressed."
      ],
      "code_start_line": 81,
      "code_end_line": 82,
      "parent": "FakeCV",
      "params": [
        "self",
        "wtf"
      ],
      "have_return": true,
      "code_content": "    def waitKey(self, wtf):\n        return 0\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "imshow": {
      "type": "FunctionDef",
      "name": "imshow",
      "md_content": [
        "**imshow**: The function of imshow is to display an image frame.\n\n**parameters**:\n- frame: The image frame to be displayed.\n- k: The index of the frame.\n\n**Code Description**:\nThe `imshow` function is a method of the `transbot_simulation.py` module in the `Transbot` package of the `misc` module in the `OpenNARS-for-Applications` project. This function is used to display an image frame. It takes two parameters: `frame`, which represents the image frame to be displayed, and `k`, which is the index of the frame.\n\nHowever, the code implementation of this function does not contain any specific logic or operations. It simply returns `None`, indicating that there is no further processing or functionality associated with this function.\n\n**Note**:\nThere are no specific notes or considerations for using this code."
      ],
      "code_start_line": 83,
      "code_end_line": 84,
      "parent": "FakeCV",
      "params": [
        "self",
        "frame",
        "k"
      ],
      "have_return": false,
      "code_content": "    def imshow(self, frame, k):\n        None\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    }
  },
  "OpenNARS-for-Applications\\misc\\Transbot\\transbot_vision.py": {
    "rgbtopic": {
      "type": "FunctionDef",
      "name": "rgbtopic",
      "md_content": [
        "**rgbtopic**: The function of rgbtopic is to process the RGB image data received as a message and update the global frame variable with the decoded and resized image.\n\n**parameters**:\n- msg: The message containing the RGB image data.\n\n**Code Description**:\nThe rgbtopic function first checks if the received message is an instance of the CompressedImage class. If it is not, the function returns without performing any further processing.\n\nNext, the function acquires the framelock, which is a global lock used to ensure thread safety when accessing the frame variable.\n\nThe function then converts the image data in the message to a NumPy array using the np.fromstring() function. The data is interpreted as unsigned 8-bit integers (np.uint8).\n\nThe NumPy array is then decoded using the cv.imdecode() function from the OpenCV library. The decoding process converts the compressed image data into a BGR image.\n\nAfter decoding, the image is resized using the cv.resize() function. The desired width and height for the resized image are specified using the transbot_vision_WIDTH and transbot_vision_HEIGHT variables.\n\nFinally, the framelock is released to allow other threads to access the frame variable.\n\n**Note**:\n- This function expects the received message to be of type CompressedImage. If the message is not of this type, the function will return without performing any further processing.\n- The global variables frame and framelock are assumed to be defined and accessible within the scope of this function.\n\n**Output Example**:\nThe updated frame variable will contain the decoded and resized RGB image data."
      ],
      "code_start_line": 29,
      "code_end_line": 37,
      "parent": null,
      "params": [
        "msg"
      ],
      "have_return": true,
      "code_content": "def rgbtopic(msg):\n    global frame, framelock\n    if not isinstance(msg, CompressedImage):\n        return\n    framelock.acquire()\n    np_arr = np.fromstring(msg.data, np.uint8)\n    frame = cv.imdecode(np_arr, cv.IMREAD_ANYCOLOR)\n    frame = cv.resize(frame, (transbot_vision_WIDTH, transbot_vision_HEIGHT))\n    framelock.release()\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": []
    },
    "cropImage": {
      "type": "FunctionDef",
      "name": "cropImage",
      "md_content": [
        "**cropImage**: The function of cropImage is to crop an image based on the given bounding box.\n\n**Parameters**:\n- img: The input image to be cropped.\n- BB: The bounding box coordinates (x, y, width, height) specifying the region to be cropped.\n\n**Code Description**:\nThe cropImage function takes an image and a bounding box as input. The bounding box is represented by a tuple (x, y, w, h), where (x, y) is the top-left corner of the box, and w and h are the width and height of the box, respectively.\n\nThe function then uses the bounding box coordinates to extract the region of interest from the input image. This is done by slicing the image array using the y:y+h and x:x+w indices, which selects the rows and columns within the specified range.\n\nFinally, the cropped image is returned as the output of the function.\n\nThe cropImage function is called by the applyYOLO function in the transbot_vision.py file. In the applyYOLO function, the cropImage function is used to crop the image based on the bounding box coordinates of detected objects. The cropped image is then further processed to extract dominant colors and perform other operations.\n\n**Note**:\n- The cropImage function assumes that the input image and bounding box coordinates are valid and within the image dimensions.\n- The function does not perform any error handling or validation for the input parameters.\n\n**Output Example**:\nA cropped image based on the provided bounding box coordinates."
      ],
      "code_start_line": 54,
      "code_end_line": 57,
      "parent": null,
      "params": [
        "img",
        "BB"
      ],
      "have_return": true,
      "code_content": "def cropImage(img, BB): #crop image according to boundinx box\n    (x,y,w,h) = BB\n    crop = img[y:y+h, x:x+w]\n    return crop\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_vision.py/applyYOLO"
      ],
      "reference_who": []
    },
    "dominantColorsWithPixelCounts": {
      "type": "FunctionDef",
      "name": "dominantColorsWithPixelCounts",
      "md_content": [
        "**dominantColorsWithPixelCounts**: The function of dominantColorsWithPixelCounts is to calculate the dominant colors in an image along with their corresponding pixel counts.\n\n**parameters**:\n- img: The input image for which the dominant colors need to be calculated.\n\n**Code Description**:\nThe function first converts the input image from the BGR color space to the RGB color space using the cvtColor function from the OpenCV library. This is done because the kmeans function, which is used later, requires the input to be in the RGB color space.\n\nNext, the function reshapes the image into a 2D array of pixels using the reshape function. Each pixel is represented as a 3-element array containing the RGB values.\n\nThe function then specifies the number of color clusters to be used for the k-means clustering algorithm. In this case, the value is set to 5.\n\nThe kmeans function is then called with the input pixels, number of color clusters, and other parameters. This function performs k-means clustering on the input pixels and returns the cluster labels and the cluster centers (palette).\n\nUsing the cluster labels, the function calculates the counts of each cluster using the unique function from the numpy library.\n\nThe function then combines the palette and counts into a list of tuples, where each tuple contains a color from the palette and its corresponding count.\n\nOptionally, the list of tuples can be sorted in descending order based on the counts using the sort function and a lambda function as the key.\n\nFinally, the function returns the list of tuples representing the dominant colors with their pixel counts.\n\n**Note**: \n- This function assumes that the input image is in the BGR color space. If the input image is already in the RGB color space, the conversion step can be skipped.\n- The number of color clusters used for k-means clustering can be adjusted based on the desired level of color detail.\n- The sorting step using the sort function is not necessary if the order of the dominant colors is not important.\n\n**Output Example**:\n[(255, 0, 0), 1000], [(0, 255, 0), 800], [(0, 0, 255), 600], [(255, 255, 0), 400], [(0, 255, 255), 200]"
      ],
      "code_start_line": 59,
      "code_end_line": 67,
      "parent": null,
      "params": [
        "img"
      ],
      "have_return": true,
      "code_content": "def dominantColorsWithPixelCounts(img):\n    im_rgb = cv.cvtColor(img, cv.COLOR_BGR2RGB)\n    pixels = np.float32(im_rgb.reshape(-1, 3))\n    n_color_clusters = 5\n    _, labels, palette = cv.kmeans(pixels, n_color_clusters, None, (cv.TERM_CRITERIA_EPS + cv.TERM_CRITERIA_MAX_ITER, 200, .1), 10, cv.KMEANS_RANDOM_CENTERS)\n    _, counts = np.unique(labels, return_counts=True)\n    DominantColorsWithCounts = list(zip(palette, counts))\n    DominantColorsWithCounts.sort(key=lambda x: -x[1]) #not necessary\n    return DominantColorsWithCounts\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_vision.py/applyYOLO"
      ],
      "reference_who": []
    },
    "applyYOLO": {
      "type": "FunctionDef",
      "name": "applyYOLO",
      "md_content": [
        "**applyYOLO**: The function of applyYOLO is to apply the YOLO (You Only Look Once) object detection algorithm to an input image and return the image with bounding boxes drawn around the detected objects, as well as a list of detections.\n\n**Parameters**:\n- img: The input image on which the YOLO algorithm will be applied.\n\n**Code Description**:\nThe applyYOLO function first sets a detection confidence threshold to 0.3. This threshold determines the minimum confidence level required for an object detection to be considered valid.\n\nNext, the function calls the detect function from the yolo object, passing in the input image and the detection confidence threshold. The detect function returns three arrays: boxes, confs, and clss. These arrays contain the bounding box coordinates, confidence scores, and class labels for the detected objects, respectively.\n\nThe function then initializes an empty list called detections. It iterates over the class labels array and performs the following operations for each detected object:\n\n- Retrieves the class ID, bounding box coordinates, and class name from the corresponding arrays.\n- Checks if the warn_person_car flag is enabled and if the class name is either \"person\" or \"car\". If both conditions are met, it calculates the y-coordinate of the bottom of the bounding box and compares it to the warn_distance threshold. If the y-coordinate is greater than or equal to the threshold, it sets the bot to beep with a frequency of 1000 Hz.\n- Calls the cropImage function, passing in the input image and the bounding box coordinates. This function crops the image based on the specified bounding box.\n- Calls the dominantColorsWithPixelCounts function, passing in the cropped image. This function calculates the dominant colors in the cropped image along with their corresponding pixel counts.\n- Appends a list containing the class name, bounding box coordinates, confidence score, and dominant color to the detections list.\n- Draws a rectangle around the detected object on the input image using the bounding box coordinates and a color based on the class ID.\n- Writes the class name and the top-left coordinates of the bounding box as text on the input image.\n\nAfter processing all the detected objects, the detections list is sorted in descending order based on the sum of the y-coordinate and height of the bounding box. This sorting is done to prioritize objects that are closer to the camera.\n\nFinally, the function returns the input image with the bounding boxes drawn around the detected objects and the detections list.\n\n**Note**:\n- The applyYOLO function assumes that the yolo object, COCO_CLASSES_LIST, warn_person_car flag, warn_distance threshold, bot object, COLORS array, cv module, cropImage function, and dominantColorsWithPixelCounts function are all defined and accessible within the scope of the function.\n- The function does not handle any exceptions or errors that may occur during the execution of the code.\n- The output image and detections list may vary depending on the input image and the performance of the YOLO object detection algorithm.\n\n**Output Example**:\nA modified input image with bounding boxes drawn around the detected objects and a list of detections:\n```\nimg: modified input image\ndetections: [\n    [\"person\", x1, y1, width1, height1, confidence1, (r1, g1, b1)],\n    [\"car\", x2, y2, width2, height2, confidence2, (r2, g2, b2)],\n    ...\n]\n```"
      ],
      "code_start_line": 69,
      "code_end_line": 88,
      "parent": null,
      "params": [
        "img"
      ],
      "have_return": true,
      "code_content": "def applyYOLO(img):\n    detection_confidence_threshold = 0.3\n    boxes, confs, clss = yolo.detect(img, detection_confidence_threshold)\n    detections = []\n    for i in range(len(clss)):\n        class_id = int(clss[i])\n        box = boxes[i]\n        class_name = COCO_CLASSES_LIST[class_id]\n        if warn_person_car and class_name in [\"person\", \"car\"]:\n            y = box[1] + (box[3] - box[1])\n            if y >= warn_distance:\n                bot.set_beep(1000)\n        imagecropped = cropImage(img, (box[0], box[1], box[2]-box[0], box[3]-box[1]))\n        dominantColor = dominantColorsWithPixelCounts(imagecropped)[0][0]\n        detections.append([class_name, box[0], box[1], box[2]-box[0], box[3]-box[1], confs[i], (dominantColor[0], dominantColor[1], dominantColor[2])])\n        color = COLORS[class_id]\n        cv.rectangle(img, (box[0], box[1]), (box[2], box[3]), color, thickness=2)\n        cv.putText(img, class_name +\":\"+str(box[0]) + \",\" + str(box[1]), (box[0], box[1] - 5), cv.FONT_HERSHEY_SIMPLEX, 1, color, 2)\n    detections.sort(key = lambda x: -(x[2] + x[4])) #sort by distance (Y as proxy for distance for now since camera is tilted slightly towards floor)\n    return img, detections\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_vision.py/detect_objects"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_vision.py/cropImage",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_vision.py/dominantColorsWithPixelCounts"
      ]
    },
    "detect_objects": {
      "type": "FunctionDef",
      "name": "detect_objects",
      "md_content": [
        "**detect_objects**: The function of detect_objects is to detect objects in a given frame using the YOLO (You Only Look Once) object detection algorithm. It returns a list of detections and the modified frame with bounding boxes drawn around the detected objects.\n\n**Parameters**:\n- None\n\n**Code Description**:\nThe detect_objects function begins by acquiring a lock on the global frame variable to ensure thread safety. It then creates a copy of the frame and releases the lock. \n\nNext, the function checks if the frame is not empty. If it is not empty, it proceeds to apply the YOLO algorithm to the frame by calling the applyYOLO function. This function takes the frame copy as input and returns the modified frame with bounding boxes drawn around the detected objects, as well as a list of detections.\n\nThe function calculates the frames per second (FPS) by measuring the time taken to apply the YOLO algorithm. It then adds the FPS value as text to the modified frame using the cv.putText function.\n\nThe modified frame is displayed using the cv.imshow function. Finally, the function returns the list of detections and the modified frame.\n\n**Note**:\n- The applyYOLO function is called within the detect_objects function, so it must be defined and accessible within the scope of the function.\n- The global variables frame and framelock are used to store and access the current frame.\n- The code includes commented out sections related to depth frame processing, which are currently not used.\n- The cv module is used for image processing and display.\n- The returned detections list contains information about the detected objects, including the class name, bounding box coordinates, confidence score, and dominant color.\n- The modified frame is displayed with bounding boxes drawn around the detected objects and the FPS value as text.\n\n**Output Example**:\nA modified frame with bounding boxes drawn around the detected objects and a list of detections:\n```\ndetections: [\n    [\"person\", x1, y1, width1, height1, confidence1, (r1, g1, b1)],\n    [\"car\", x2, y2, width2, height2, confidence2, (r2, g2, b2)],\n    ...\n]\nframe: modified frame\n```"
      ],
      "code_start_line": 90,
      "code_end_line": 110,
      "parent": null,
      "params": [],
      "have_return": true,
      "code_content": "def detect_objects():\n    global frame, framelock\n    framecopy = None\n    framelock.acquire()\n    framecopy = frame.copy()\n    framelock.release()\n    #depthframecopy = None\n    #depthframelock.acquire()\n    #depthframecopy = depthframe.copy()\n    #depthframelock.release()\n    if frame != \"\":\n        start = time.time()\n        (framecopy, detections) = applyYOLO(framecopy)\n        end = time.time()\n        fps = 1 / (end - start)\n        text = \"FPS : \" + str(int(fps))\n        cv.putText(framecopy, text, (20, 30), cv.FONT_HERSHEY_SIMPLEX, 0.9, (100, 200, 200), 1)\n        cv.imshow('frame', framecopy)\n        #cv.imshow('depthframe', depthframecopy)\n        return detections, framecopy\n    return None, None\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/pick_with_feedback",
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot.py/process"
      ],
      "reference_who": [
        "OpenNARS-for-Applications\\misc\\Transbot\\transbot_vision.py/applyYOLO"
      ]
    }
  }
}